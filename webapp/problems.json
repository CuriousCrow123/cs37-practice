{
  "version": "1.0",
  "course": "CS37",
  "categories": [
    {
      "id": "control-structures",
      "title": "Control Structures & Operators",
      "order": 1
    },
    {
      "id": "functions-scope",
      "title": "Functions, Scope & References",
      "order": 2
    },
    {
      "id": "pointers",
      "title": "Pointers & Dereferencing",
      "order": 3
    },
    {
      "id": "arrays-iteration",
      "title": "Arrays & Iteration",
      "order": 4
    },
    {
      "id": "classes-constructors",
      "title": "Classes & Constructors",
      "order": 5
    },
    {
      "id": "operator-overloading",
      "title": "Operator Overloading & Object Behavior",
      "order": 6
    },
    {
      "id": "inheritance-polymorphism",
      "title": "Inheritance & Polymorphism",
      "order": 7
    },
    {
      "id": "dynamic-memory",
      "title": "Dynamic Memory & Rule of 3",
      "order": 8
    }
  ],
  "sections": [],
  "problems": [
    {
      "id": "ctrl-001",
      "categoryId": "control-structures",
      "concept": "`&&` operator behavior",
      "code": "int main() {\n    cout << (true && true) << (true && false) << (false && true) << (false && false);\n}",
      "output": "1000",
      "tags": [
        "control-flow",
        "operators"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "evaluate",
            "description": "Evaluate `true && true` = 1 (both operands true)",
            "concepts": [
              "logical-and"
            ]
          },
          {
            "line": 2,
            "action": "output",
            "description": "Output 1",
            "output": "1"
          },
          {
            "line": 2,
            "action": "evaluate",
            "description": "Evaluate `true && false` = 0 (second operand false)",
            "concepts": [
              "logical-and"
            ]
          },
          {
            "line": 2,
            "action": "output",
            "description": "Output 0",
            "output": "0"
          },
          {
            "line": 2,
            "action": "evaluate",
            "description": "Evaluate `false && true` = 0 (first operand false)",
            "concepts": [
              "logical-and"
            ]
          },
          {
            "line": 2,
            "action": "output",
            "description": "Output 0",
            "output": "0"
          },
          {
            "line": 2,
            "action": "evaluate",
            "description": "Evaluate `false && false` = 0 (both operands false)",
            "concepts": [
              "logical-and"
            ]
          },
          {
            "line": 2,
            "action": "output",
            "description": "Output 0",
            "output": "0"
          }
        ],
        "finalOutput": "1000",
        "keyInsight": "Logical AND (`&&`) returns true (1) only when BOTH operands are true"
      }
    },
    {
      "id": "ctrl-002",
      "categoryId": "control-structures",
      "concept": "`||` operator behavior",
      "code": "int main() {\n    cout << (true || true) << (true || false) << (false || true) << (false || false);\n}",
      "output": "1110",
      "tags": [
        "control-flow",
        "operators"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "evaluate",
            "description": "Evaluate `true || true` = 1 (at least one true)",
            "concepts": [
              "logical-or"
            ]
          },
          {
            "line": 2,
            "action": "output",
            "description": "Output 1",
            "output": "1"
          },
          {
            "line": 2,
            "action": "evaluate",
            "description": "Evaluate `true || false` = 1 (first operand true)",
            "concepts": [
              "logical-or"
            ]
          },
          {
            "line": 2,
            "action": "output",
            "description": "Output 1",
            "output": "1"
          },
          {
            "line": 2,
            "action": "evaluate",
            "description": "Evaluate `false || true` = 1 (second operand true)",
            "concepts": [
              "logical-or"
            ]
          },
          {
            "line": 2,
            "action": "output",
            "description": "Output 1",
            "output": "1"
          },
          {
            "line": 2,
            "action": "evaluate",
            "description": "Evaluate `false || false` = 0 (neither operand true)",
            "concepts": [
              "logical-or"
            ]
          },
          {
            "line": 2,
            "action": "output",
            "description": "Output 0",
            "output": "0"
          }
        ],
        "finalOutput": "1110",
        "keyInsight": "Logical OR (`||`) returns true (1) when AT LEAST ONE operand is true"
      }
    },
    {
      "id": "ctrl-003",
      "categoryId": "control-structures",
      "concept": "Short-circuit evaluation",
      "code": "int main() {\n    int x = 5;\n    if (false && ++x) {}\n    cout << x;\n}",
      "output": "5",
      "tags": [
        "control-flow"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "declare",
            "description": "Declare `x` and initialize to 5",
            "state": {
              "x": 5
            },
            "concepts": [
              "variable-declaration"
            ]
          },
          {
            "line": 3,
            "action": "evaluate",
            "description": "Evaluate left side of `&&`: false",
            "concepts": [
              "short-circuit"
            ]
          },
          {
            "line": 3,
            "action": "branch",
            "description": "Short-circuit: since left is false, right side `++x` is NEVER evaluated",
            "state": {
              "x": 5
            },
            "concepts": [
              "short-circuit"
            ]
          },
          {
            "line": 4,
            "action": "output",
            "description": "Output x=5 (unchanged)",
            "output": "5"
          }
        ],
        "finalOutput": "5",
        "keyInsight": "Short-circuit evaluation: if left side of `&&` is false, right side is never evaluated"
      }
    },
    {
      "id": "ctrl-004",
      "categoryId": "control-structures",
      "concept": "`!` logical NOT",
      "code": "int main() {\n    cout << !0 << !1 << !5 << !(-1);\n}",
      "output": "1000",
      "tags": [
        "control-flow"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "evaluate",
            "description": "Evaluate `!0`: 0 is falsy, so !0 = true = 1",
            "concepts": [
              "logical-not",
              "truthy-falsy"
            ]
          },
          {
            "line": 2,
            "action": "output",
            "description": "Output 1",
            "output": "1"
          },
          {
            "line": 2,
            "action": "evaluate",
            "description": "Evaluate `!1`: 1 is truthy, so !1 = false = 0",
            "concepts": [
              "logical-not"
            ]
          },
          {
            "line": 2,
            "action": "output",
            "description": "Output 0",
            "output": "0"
          },
          {
            "line": 2,
            "action": "evaluate",
            "description": "Evaluate `!5`: 5 is truthy (non-zero), so !5 = 0",
            "concepts": [
              "logical-not",
              "truthy-falsy"
            ]
          },
          {
            "line": 2,
            "action": "output",
            "description": "Output 0",
            "output": "0"
          },
          {
            "line": 2,
            "action": "evaluate",
            "description": "Evaluate `!(-1)`: -1 is truthy (non-zero), so !(-1) = 0",
            "concepts": [
              "logical-not"
            ]
          },
          {
            "line": 2,
            "action": "output",
            "description": "Output 0",
            "output": "0"
          }
        ],
        "finalOutput": "1000",
        "keyInsight": "Logical NOT (`!`) returns 1 for 0 (falsy) and 0 for any non-zero value (truthy)"
      }
    },
    {
      "id": "ctrl-005",
      "categoryId": "control-structures",
      "concept": "Double negation `!!`",
      "code": "int main() {\n    cout << !!0 << !!1 << !!5 << !!(-3);\n}",
      "output": "0111",
      "tags": [
        "control-flow"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "evaluate",
            "description": "Evaluate `!!0`: !0=1, then !1=0",
            "concepts": [
              "double-negation"
            ]
          },
          {
            "line": 2,
            "action": "output",
            "description": "Output 0",
            "output": "0"
          },
          {
            "line": 2,
            "action": "evaluate",
            "description": "Evaluate `!!1`: !1=0, then !0=1",
            "concepts": [
              "double-negation"
            ]
          },
          {
            "line": 2,
            "action": "output",
            "description": "Output 1",
            "output": "1"
          },
          {
            "line": 2,
            "action": "evaluate",
            "description": "Evaluate `!!5`: !5=0, then !0=1",
            "concepts": [
              "double-negation",
              "truthy-falsy"
            ]
          },
          {
            "line": 2,
            "action": "output",
            "description": "Output 1",
            "output": "1"
          },
          {
            "line": 2,
            "action": "evaluate",
            "description": "Evaluate `!!(-3)`: !(-3)=0, then !0=1",
            "concepts": [
              "double-negation"
            ]
          },
          {
            "line": 2,
            "action": "output",
            "description": "Output 1",
            "output": "1"
          }
        ],
        "finalOutput": "0111",
        "keyInsight": "Double negation `!!` converts any value to its boolean equivalent: 0 stays 0, non-zero becomes 1"
      }
    },
    {
      "id": "ctrl-006",
      "categoryId": "control-structures",
      "concept": "Boolean-to-integer conversion",
      "code": "int main() {\n    int a = true + true + false;\n    cout << a;\n}",
      "output": "2",
      "tags": [
        "control-flow"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "evaluate",
            "description": "Evaluate `true + true + false`: true=1, true=1, false=0",
            "concepts": [
              "bool-to-int"
            ]
          },
          {
            "line": 2,
            "action": "evaluate",
            "description": "Calculate 1 + 1 + 0 = 2",
            "concepts": [
              "arithmetic"
            ]
          },
          {
            "line": 2,
            "action": "declare",
            "description": "Store result in `a`",
            "state": {
              "a": 2
            }
          },
          {
            "line": 3,
            "action": "output",
            "description": "Output 2",
            "output": "2"
          }
        ],
        "finalOutput": "2",
        "keyInsight": "Boolean values convert to integers: true becomes 1, false becomes 0"
      }
    },
    {
      "id": "ctrl-007",
      "categoryId": "control-structures",
      "concept": "`?:` ternary operator",
      "code": "int main() {\n    int x = 5;\n    cout << (x > 3 ? \"yes\" : \"no\");\n}",
      "output": "yes",
      "tags": [
        "control-flow",
        "operators"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "declare",
            "description": "Declare `x` and initialize to 5",
            "state": {
              "x": 5
            },
            "concepts": [
              "variable-declaration"
            ]
          },
          {
            "line": 3,
            "action": "evaluate",
            "description": "Evaluate condition `x > 3`: 5 > 3 is true",
            "concepts": [
              "comparison"
            ]
          },
          {
            "line": 3,
            "action": "evaluate",
            "description": "Condition true, select first branch: \"yes\"",
            "concepts": [
              "ternary-operator"
            ]
          },
          {
            "line": 3,
            "action": "output",
            "description": "Output \"yes\"",
            "output": "yes"
          }
        ],
        "finalOutput": "yes",
        "keyInsight": "Ternary operator `?:` selects first expression if condition is true, second if false"
      }
    },
    {
      "id": "ctrl-008",
      "categoryId": "control-structures",
      "concept": "Ternary operator right-associativity",
      "code": "int main() {\n    int a = 1, b = 2, c = 3;\n    cout << (a > b ? a : b > c ? b : c);\n}",
      "output": "3",
      "tags": [
        "control-flow",
        "operators"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "declare",
            "description": "Declare a=1, b=2, c=3",
            "state": {
              "a": 1,
              "b": 2,
              "c": 3
            },
            "concepts": [
              "variable-declaration"
            ]
          },
          {
            "line": 3,
            "action": "evaluate",
            "description": "Parse as: `a > b ? a : (b > c ? b : c)` (right-associative)",
            "concepts": [
              "ternary-operator",
              "right-associativity"
            ]
          },
          {
            "line": 3,
            "action": "evaluate",
            "description": "Evaluate `a > b`: 1 > 2 is false",
            "concepts": [
              "comparison"
            ]
          },
          {
            "line": 3,
            "action": "evaluate",
            "description": "Select else branch: evaluate `b > c ? b : c`",
            "concepts": [
              "ternary-operator"
            ]
          },
          {
            "line": 3,
            "action": "evaluate",
            "description": "Evaluate `b > c`: 2 > 3 is false",
            "concepts": [
              "comparison"
            ]
          },
          {
            "line": 3,
            "action": "evaluate",
            "description": "Select `c` = 3",
            "concepts": [
              "ternary-operator"
            ]
          },
          {
            "line": 3,
            "action": "output",
            "description": "Output 3",
            "output": "3"
          }
        ],
        "finalOutput": "3",
        "keyInsight": "Ternary operator is right-associative: `a ? b : c ? d : e` parses as `a ? b : (c ? d : e)`"
      }
    },
    {
      "id": "ctrl-009",
      "categoryId": "control-structures",
      "concept": "Nested conditionals",
      "code": "int main() {\n    int x = 0;\n    cout << (x ? \"A\" : x == 0 ? \"B\" : \"C\");\n}",
      "output": "B",
      "tags": [
        "control-flow"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "declare",
            "description": "Declare `x` and initialize to 0",
            "state": {
              "x": 0
            },
            "concepts": [
              "variable-declaration"
            ]
          },
          {
            "line": 3,
            "action": "evaluate",
            "description": "Evaluate outer condition `x`: 0 is falsy",
            "concepts": [
              "truthy-falsy"
            ]
          },
          {
            "line": 3,
            "action": "evaluate",
            "description": "Select else branch: evaluate `x == 0 ? \"B\" : \"C\"`",
            "concepts": [
              "ternary-operator"
            ]
          },
          {
            "line": 3,
            "action": "evaluate",
            "description": "Evaluate `x == 0`: true",
            "concepts": [
              "comparison"
            ]
          },
          {
            "line": 3,
            "action": "evaluate",
            "description": "Select \"B\"",
            "concepts": [
              "ternary-operator"
            ]
          },
          {
            "line": 3,
            "action": "output",
            "description": "Output \"B\"",
            "output": "B"
          }
        ],
        "finalOutput": "B",
        "keyInsight": "Nested ternary: when outer condition is false, the inner ternary in the else branch is evaluated"
      }
    },
    {
      "id": "ctrl-010",
      "categoryId": "control-structures",
      "concept": "`if-else` selection",
      "code": "int main() {\n    int x = 0;\n    if (x) cout << \"A\";\n    else cout << \"B\";\n}",
      "output": "B",
      "tags": [
        "control-flow",
        "conditionals"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "declare",
            "description": "Declare `x` and initialize to 0",
            "state": {
              "x": 0
            },
            "concepts": [
              "variable-declaration"
            ]
          },
          {
            "line": 3,
            "action": "branch",
            "description": "Evaluate if condition `x`: 0 is falsy, condition is false",
            "concepts": [
              "if-else",
              "truthy-falsy"
            ]
          },
          {
            "line": 4,
            "action": "output",
            "description": "Execute else branch: output \"B\"",
            "output": "B"
          }
        ],
        "finalOutput": "B",
        "keyInsight": "In if statements, 0 is falsy (evaluates to false), any non-zero value is truthy"
      }
    },
    {
      "id": "ctrl-011",
      "categoryId": "control-structures",
      "concept": "`switch` statement",
      "code": "int main() {\n    int x = 2;\n    switch (x) {\n        case 1: cout << \"A\"; break;\n        case 2: cout << \"B\"; break;\n        case 3: cout << \"C\"; break;\n    }\n}",
      "output": "B",
      "tags": [
        "control-flow",
        "switch"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "declare",
            "description": "Declare `x` and initialize to 2",
            "state": {
              "x": 2
            },
            "concepts": [
              "variable-declaration"
            ]
          },
          {
            "line": 3,
            "action": "branch",
            "description": "Enter switch with x=2",
            "concepts": [
              "switch"
            ]
          },
          {
            "line": 4,
            "action": "branch",
            "description": "case 1: x != 1, skip",
            "concepts": [
              "case-label"
            ]
          },
          {
            "line": 5,
            "action": "branch",
            "description": "case 2: x == 2, match!",
            "concepts": [
              "case-label"
            ]
          },
          {
            "line": 5,
            "action": "output",
            "description": "Output \"B\"",
            "output": "B"
          },
          {
            "line": 5,
            "action": "branch",
            "description": "break: exit switch",
            "concepts": [
              "break"
            ]
          }
        ],
        "finalOutput": "B",
        "keyInsight": "Switch statement jumps directly to matching case label, then break exits the switch"
      }
    },
    {
      "id": "ctrl-012",
      "categoryId": "control-structures",
      "concept": "`case` labels",
      "code": "int main() {\n    char c = 'b';\n    switch (c) {\n        case 'a': cout << \"1\"; break;\n        case 'b': cout << \"2\"; break;\n    }\n}",
      "output": "2",
      "tags": [
        "control-flow"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "declare",
            "description": "Declare `c` as char 'b'",
            "state": {
              "c": "'b'"
            },
            "concepts": [
              "variable-declaration"
            ]
          },
          {
            "line": 3,
            "action": "branch",
            "description": "Enter switch with c='b'",
            "concepts": [
              "switch"
            ]
          },
          {
            "line": 4,
            "action": "branch",
            "description": "case 'a': c != 'a', skip",
            "concepts": [
              "case-label"
            ]
          },
          {
            "line": 5,
            "action": "branch",
            "description": "case 'b': c == 'b', match!",
            "concepts": [
              "case-label"
            ]
          },
          {
            "line": 5,
            "action": "output",
            "description": "Output \"2\"",
            "output": "2"
          },
          {
            "line": 5,
            "action": "branch",
            "description": "break: exit switch",
            "concepts": [
              "break"
            ]
          }
        ],
        "finalOutput": "2",
        "keyInsight": "Case labels can match character values; chars are compared by their ASCII values"
      }
    },
    {
      "id": "ctrl-013",
      "categoryId": "control-structures",
      "concept": "`break` statement in switch",
      "code": "int main() {\n    int x = 1;\n    switch (x) {\n        case 1: cout << \"A\"; break;\n        case 2: cout << \"B\";\n    }\n    cout << \"C\";\n}",
      "output": "AC",
      "tags": [
        "control-flow",
        "switch"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "declare",
            "description": "Declare `x` and initialize to 1",
            "state": {
              "x": 1
            },
            "concepts": [
              "variable-declaration"
            ]
          },
          {
            "line": 3,
            "action": "branch",
            "description": "Enter switch with x=1",
            "concepts": [
              "switch"
            ]
          },
          {
            "line": 4,
            "action": "branch",
            "description": "case 1: match!",
            "concepts": [
              "case-label"
            ]
          },
          {
            "line": 4,
            "action": "output",
            "description": "Output \"A\"",
            "output": "A"
          },
          {
            "line": 4,
            "action": "branch",
            "description": "break: exit switch immediately",
            "concepts": [
              "break"
            ]
          },
          {
            "line": 6,
            "action": "output",
            "description": "Continue after switch: output \"C\"",
            "output": "C"
          }
        ],
        "finalOutput": "AC",
        "keyInsight": "Break exits only the switch statement; code after the switch continues executing"
      }
    },
    {
      "id": "ctrl-014",
      "categoryId": "control-structures",
      "concept": "Fall-through behavior",
      "code": "int main() {\n    int x = 1;\n    switch (x) {\n        case 1: cout << \"A\";\n        case 2: cout << \"B\";\n        case 3: cout << \"C\"; break;\n        case 4: cout << \"D\";\n    }\n}",
      "output": "ABC",
      "tags": [
        "control-flow"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "declare",
            "description": "Declare `x` and initialize to 1",
            "state": {
              "x": 1
            },
            "concepts": [
              "variable-declaration"
            ]
          },
          {
            "line": 3,
            "action": "branch",
            "description": "Enter switch with x=1",
            "concepts": [
              "switch"
            ]
          },
          {
            "line": 4,
            "action": "branch",
            "description": "case 1: match!",
            "concepts": [
              "case-label"
            ]
          },
          {
            "line": 4,
            "action": "output",
            "description": "Output \"A\"",
            "output": "A"
          },
          {
            "line": 5,
            "action": "branch",
            "description": "No break: fall through to case 2",
            "concepts": [
              "fall-through"
            ]
          },
          {
            "line": 5,
            "action": "output",
            "description": "Output \"B\"",
            "output": "B"
          },
          {
            "line": 6,
            "action": "branch",
            "description": "No break: fall through to case 3",
            "concepts": [
              "fall-through"
            ]
          },
          {
            "line": 6,
            "action": "output",
            "description": "Output \"C\"",
            "output": "C"
          },
          {
            "line": 6,
            "action": "branch",
            "description": "break: exit switch",
            "concepts": [
              "break"
            ]
          }
        ],
        "finalOutput": "ABC",
        "keyInsight": "Without break, execution 'falls through' to subsequent cases regardless of their labels"
      }
    },
    {
      "id": "ctrl-015",
      "categoryId": "control-structures",
      "concept": "`default` case",
      "code": "int main() {\n    int x = 99;\n    switch (x) {\n        case 1: cout << \"A\"; break;\n        default: cout << \"X\"; break;\n        case 2: cout << \"B\"; break;\n    }\n}",
      "output": "X",
      "tags": [
        "control-flow"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "declare",
            "description": "Declare `x` and initialize to 99",
            "state": {
              "x": 99
            },
            "concepts": [
              "variable-declaration"
            ]
          },
          {
            "line": 3,
            "action": "branch",
            "description": "Enter switch with x=99",
            "concepts": [
              "switch"
            ]
          },
          {
            "line": 4,
            "action": "branch",
            "description": "case 1: x != 1, skip",
            "concepts": [
              "case-label"
            ]
          },
          {
            "line": 5,
            "action": "branch",
            "description": "default: no case matched, execute default",
            "concepts": [
              "default-case"
            ]
          },
          {
            "line": 5,
            "action": "output",
            "description": "Output \"X\"",
            "output": "X"
          },
          {
            "line": 5,
            "action": "branch",
            "description": "break: exit switch",
            "concepts": [
              "break"
            ]
          }
        ],
        "finalOutput": "X",
        "keyInsight": "Default case executes when no other case matches; its position in switch doesn't matter"
      }
    },
    {
      "id": "ctrl-016",
      "categoryId": "control-structures",
      "concept": "`for` loop syntax",
      "code": "int main() {\n    for (int i = 0; i < 3; i++) cout << i;\n}",
      "output": "012",
      "tags": [
        "control-flow",
        "loops",
        "for-loop"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "loop-start",
            "description": "Initialize i=0",
            "state": {
              "i": 0
            },
            "concepts": [
              "for-loop"
            ]
          },
          {
            "line": 2,
            "action": "loop-check",
            "description": "Check i < 3: 0 < 3 true",
            "concepts": [
              "loop-condition"
            ]
          },
          {
            "line": 2,
            "action": "output",
            "description": "Output 0",
            "output": "0"
          },
          {
            "line": 2,
            "action": "evaluate",
            "description": "Increment i++",
            "state": {
              "i": 1
            }
          },
          {
            "line": 2,
            "action": "loop-check",
            "description": "Check i < 3: 1 < 3 true"
          },
          {
            "line": 2,
            "action": "output",
            "description": "Output 1",
            "output": "1"
          },
          {
            "line": 2,
            "action": "evaluate",
            "description": "Increment i++",
            "state": {
              "i": 2
            }
          },
          {
            "line": 2,
            "action": "loop-check",
            "description": "Check i < 3: 2 < 3 true"
          },
          {
            "line": 2,
            "action": "output",
            "description": "Output 2",
            "output": "2"
          },
          {
            "line": 2,
            "action": "evaluate",
            "description": "Increment i++",
            "state": {
              "i": 3
            }
          },
          {
            "line": 2,
            "action": "loop-check",
            "description": "Check i < 3: 3 < 3 false, exit loop"
          }
        ],
        "finalOutput": "012",
        "keyInsight": "For loop: init executes once, then (check condition \u2192 body \u2192 increment) repeats until condition is false"
      }
    },
    {
      "id": "ctrl-017",
      "categoryId": "control-structures",
      "concept": "`while` loop",
      "code": "int main() {\n    int i = 3;\n    while (i > 0) { cout << i; i--; }\n}",
      "output": "321",
      "tags": [
        "control-flow",
        "loops",
        "while-loop"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "declare",
            "description": "Declare `i` and initialize to 3",
            "state": {
              "i": 3
            },
            "concepts": [
              "variable-declaration"
            ]
          },
          {
            "line": 3,
            "action": "loop-check",
            "description": "Check i > 0: 3 > 0 true",
            "concepts": [
              "while-loop"
            ]
          },
          {
            "line": 3,
            "action": "output",
            "description": "Output 3",
            "output": "3"
          },
          {
            "line": 3,
            "action": "evaluate",
            "description": "Decrement i--",
            "state": {
              "i": 2
            }
          },
          {
            "line": 3,
            "action": "loop-check",
            "description": "Check i > 0: 2 > 0 true"
          },
          {
            "line": 3,
            "action": "output",
            "description": "Output 2",
            "output": "2"
          },
          {
            "line": 3,
            "action": "evaluate",
            "description": "Decrement i--",
            "state": {
              "i": 1
            }
          },
          {
            "line": 3,
            "action": "loop-check",
            "description": "Check i > 0: 1 > 0 true"
          },
          {
            "line": 3,
            "action": "output",
            "description": "Output 1",
            "output": "1"
          },
          {
            "line": 3,
            "action": "evaluate",
            "description": "Decrement i--",
            "state": {
              "i": 0
            }
          },
          {
            "line": 3,
            "action": "loop-check",
            "description": "Check i > 0: 0 > 0 false, exit loop"
          }
        ],
        "finalOutput": "321",
        "keyInsight": "While loop checks condition before each iteration; body executes while condition remains true"
      }
    },
    {
      "id": "ctrl-018",
      "categoryId": "control-structures",
      "concept": "`<` vs `<=` comparison in loops",
      "code": "int main() {\n    int a = 0, b = 0;\n    for (int i = 0; i < 3; i++) a++;\n    for (int i = 0; i <= 3; i++) b++;\n    cout << a << b;\n}",
      "output": "34",
      "tags": [
        "control-flow",
        "loops"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "declare",
            "description": "Declare a=0, b=0",
            "state": {
              "a": 0,
              "b": 0
            },
            "concepts": [
              "variable-declaration"
            ]
          },
          {
            "line": 3,
            "action": "loop-start",
            "description": "First loop: i goes 0,1,2 (i < 3)",
            "concepts": [
              "for-loop"
            ]
          },
          {
            "line": 3,
            "action": "evaluate",
            "description": "Loop runs 3 times: a becomes 3",
            "state": {
              "a": 3
            }
          },
          {
            "line": 4,
            "action": "loop-start",
            "description": "Second loop: i goes 0,1,2,3 (i <= 3)",
            "concepts": [
              "for-loop"
            ]
          },
          {
            "line": 4,
            "action": "evaluate",
            "description": "Loop runs 4 times: b becomes 4",
            "state": {
              "b": 4
            }
          },
          {
            "line": 5,
            "action": "output",
            "description": "Output a=3 and b=4",
            "output": "34"
          }
        ],
        "finalOutput": "34",
        "keyInsight": "`i < n` runs n times (0 to n-1); `i <= n` runs n+1 times (0 to n)"
      }
    },
    {
      "id": "ctrl-019",
      "categoryId": "control-structures",
      "concept": "Iteration counting",
      "code": "int main() {\n    int count = 0;\n    for (int i = 5; i < 10; i++) count++;\n    cout << count;\n}",
      "output": "5",
      "tags": [
        "control-flow"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "declare",
            "description": "Declare `count` = 0",
            "state": {
              "count": 0
            },
            "concepts": [
              "variable-declaration"
            ]
          },
          {
            "line": 3,
            "action": "loop-start",
            "description": "Loop from i=5 to i=9 (5 iterations)",
            "concepts": [
              "for-loop"
            ]
          },
          {
            "line": 3,
            "action": "evaluate",
            "description": "i=5: count++",
            "state": {
              "count": 1
            }
          },
          {
            "line": 3,
            "action": "evaluate",
            "description": "i=6: count++",
            "state": {
              "count": 2
            }
          },
          {
            "line": 3,
            "action": "evaluate",
            "description": "i=7: count++",
            "state": {
              "count": 3
            }
          },
          {
            "line": 3,
            "action": "evaluate",
            "description": "i=8: count++",
            "state": {
              "count": 4
            }
          },
          {
            "line": 3,
            "action": "evaluate",
            "description": "i=9: count++",
            "state": {
              "count": 5
            }
          },
          {
            "line": 4,
            "action": "output",
            "description": "Output 5",
            "output": "5"
          }
        ],
        "finalOutput": "5",
        "keyInsight": "Loop from a to b-1 runs (b-a) times: from 5 to 9 is 10-5=5 iterations"
      }
    },
    {
      "id": "ctrl-020",
      "categoryId": "control-structures",
      "concept": "Loop boundaries (off-by-one)",
      "code": "int main() {\n    for (int i = 1; i < 4; i++) cout << i;\n}",
      "output": "123",
      "tags": [
        "control-flow",
        "loops"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "loop-start",
            "description": "Loop starts with i=1",
            "state": {
              "i": 1
            },
            "concepts": [
              "for-loop"
            ]
          },
          {
            "line": 2,
            "action": "loop-check",
            "description": "i=1 < 4: true, output 1",
            "output": "1"
          },
          {
            "line": 2,
            "action": "loop-check",
            "description": "i=2 < 4: true, output 2",
            "output": "2"
          },
          {
            "line": 2,
            "action": "loop-check",
            "description": "i=3 < 4: true, output 3",
            "output": "3"
          },
          {
            "line": 2,
            "action": "loop-check",
            "description": "i=4 < 4: false, exit loop"
          }
        ],
        "finalOutput": "123",
        "keyInsight": "Starting at 1 with `i < 4` produces 1,2,3 (not 0,1,2,3) - watch your loop bounds!"
      }
    },
    {
      "id": "ctrl-021",
      "categoryId": "control-structures",
      "concept": "Loop termination conditions",
      "code": "int main() {\n    int i = 0;\n    while (i++ < 3) cout << i;\n}",
      "output": "123",
      "tags": [
        "control-flow",
        "loops"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "declare",
            "description": "Declare `i` = 0",
            "state": {
              "i": 0
            },
            "concepts": [
              "variable-declaration"
            ]
          },
          {
            "line": 3,
            "action": "loop-check",
            "description": "Evaluate `i++ < 3`: i=0, returns 0, then i becomes 1",
            "state": {
              "i": 1
            },
            "concepts": [
              "post-increment",
              "while-loop"
            ]
          },
          {
            "line": 3,
            "action": "evaluate",
            "description": "0 < 3 is true, enter loop"
          },
          {
            "line": 3,
            "action": "output",
            "description": "Output i=1",
            "output": "1"
          },
          {
            "line": 3,
            "action": "loop-check",
            "description": "Evaluate `i++ < 3`: i=1, returns 1, then i becomes 2",
            "state": {
              "i": 2
            }
          },
          {
            "line": 3,
            "action": "output",
            "description": "Output i=2",
            "output": "2"
          },
          {
            "line": 3,
            "action": "loop-check",
            "description": "Evaluate `i++ < 3`: i=2, returns 2, then i becomes 3",
            "state": {
              "i": 3
            }
          },
          {
            "line": 3,
            "action": "output",
            "description": "Output i=3",
            "output": "3"
          },
          {
            "line": 3,
            "action": "loop-check",
            "description": "Evaluate `i++ < 3`: i=3, returns 3, 3 < 3 is false, exit"
          }
        ],
        "finalOutput": "123",
        "keyInsight": "Post-increment in condition: comparison uses OLD value, but variable is incremented BEFORE body"
      }
    },
    {
      "id": "ctrl-022",
      "categoryId": "control-structures",
      "concept": "Truthy/falsy integer values in conditions",
      "code": "int main() {\n    int x = 3;\n    while (x) { cout << x; x--; }\n}",
      "output": "321",
      "tags": [
        "control-flow"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "declare",
            "description": "Declare `x` = 3",
            "state": {
              "x": 3
            },
            "concepts": [
              "variable-declaration"
            ]
          },
          {
            "line": 3,
            "action": "loop-check",
            "description": "Check `x`: 3 is truthy (non-zero)",
            "concepts": [
              "truthy-falsy",
              "while-loop"
            ]
          },
          {
            "line": 3,
            "action": "output",
            "description": "Output 3",
            "output": "3"
          },
          {
            "line": 3,
            "action": "evaluate",
            "description": "Decrement x--",
            "state": {
              "x": 2
            }
          },
          {
            "line": 3,
            "action": "loop-check",
            "description": "Check `x`: 2 is truthy"
          },
          {
            "line": 3,
            "action": "output",
            "description": "Output 2",
            "output": "2"
          },
          {
            "line": 3,
            "action": "evaluate",
            "description": "Decrement x--",
            "state": {
              "x": 1
            }
          },
          {
            "line": 3,
            "action": "loop-check",
            "description": "Check `x`: 1 is truthy"
          },
          {
            "line": 3,
            "action": "output",
            "description": "Output 1",
            "output": "1"
          },
          {
            "line": 3,
            "action": "evaluate",
            "description": "Decrement x--",
            "state": {
              "x": 0
            }
          },
          {
            "line": 3,
            "action": "loop-check",
            "description": "Check `x`: 0 is falsy, exit loop"
          }
        ],
        "finalOutput": "321",
        "keyInsight": "Any non-zero integer is truthy in conditions; 0 is the only falsy integer"
      }
    },
    {
      "id": "ctrl-023",
      "categoryId": "control-structures",
      "concept": "Pre-increment `++a`",
      "code": "int main() {\n    int a = 5;\n    cout << ++a << a;\n}",
      "output": "66",
      "tags": [
        "control-flow"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "declare",
            "description": "Declare `a` = 5",
            "state": {
              "a": 5
            },
            "concepts": [
              "variable-declaration"
            ]
          },
          {
            "line": 3,
            "action": "evaluate",
            "description": "Evaluate `++a`: increment a to 6, return 6",
            "state": {
              "a": 6
            },
            "concepts": [
              "pre-increment"
            ]
          },
          {
            "line": 3,
            "action": "output",
            "description": "Output 6",
            "output": "6"
          },
          {
            "line": 3,
            "action": "evaluate",
            "description": "Evaluate `a`: a is still 6"
          },
          {
            "line": 3,
            "action": "output",
            "description": "Output 6",
            "output": "6"
          }
        ],
        "finalOutput": "66",
        "keyInsight": "Pre-increment (`++a`) increments first, then returns the NEW value"
      }
    },
    {
      "id": "ctrl-024",
      "categoryId": "control-structures",
      "concept": "Post-increment `a++`",
      "code": "int main() {\n    int a = 5;\n    cout << a++ << a;\n}",
      "output": "56",
      "tags": [
        "control-flow"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "declare",
            "description": "Declare `a` = 5",
            "state": {
              "a": 5
            },
            "concepts": [
              "variable-declaration"
            ]
          },
          {
            "line": 3,
            "action": "evaluate",
            "description": "Evaluate `a++`: return 5 (old value), then increment a to 6",
            "state": {
              "a": 6
            },
            "concepts": [
              "post-increment"
            ]
          },
          {
            "line": 3,
            "action": "output",
            "description": "Output 5",
            "output": "5"
          },
          {
            "line": 3,
            "action": "evaluate",
            "description": "Evaluate `a`: a is now 6"
          },
          {
            "line": 3,
            "action": "output",
            "description": "Output 6",
            "output": "6"
          }
        ],
        "finalOutput": "56",
        "keyInsight": "Post-increment (`a++`) returns the OLD value first, then increments"
      }
    },
    {
      "id": "ctrl-025",
      "categoryId": "control-structures",
      "concept": "Pre-decrement `--a`",
      "code": "int main() {\n    int a = 5;\n    cout << --a << a;\n}",
      "output": "44",
      "tags": [
        "control-flow"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "declare",
            "description": "Declare `a` = 5",
            "state": {
              "a": 5
            },
            "concepts": [
              "variable-declaration"
            ]
          },
          {
            "line": 3,
            "action": "evaluate",
            "description": "Evaluate `--a`: decrement a to 4, return 4",
            "state": {
              "a": 4
            },
            "concepts": [
              "pre-decrement"
            ]
          },
          {
            "line": 3,
            "action": "output",
            "description": "Output 4",
            "output": "4"
          },
          {
            "line": 3,
            "action": "evaluate",
            "description": "Evaluate `a`: a is still 4"
          },
          {
            "line": 3,
            "action": "output",
            "description": "Output 4",
            "output": "4"
          }
        ],
        "finalOutput": "44",
        "keyInsight": "Pre-decrement (`--a`) decrements first, then returns the NEW value"
      }
    },
    {
      "id": "ctrl-026",
      "categoryId": "control-structures",
      "concept": "Post-decrement `n--` in condition",
      "code": "int main() {\n    int n = 3;\n    while (n--) cout << n;\n}",
      "output": "210",
      "tags": [
        "control-flow"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "declare",
            "description": "Declare `n` = 3",
            "state": {
              "n": 3
            },
            "concepts": [
              "variable-declaration"
            ]
          },
          {
            "line": 3,
            "action": "loop-check",
            "description": "Evaluate `n--`: return 3 (truthy), decrement n to 2",
            "state": {
              "n": 2
            },
            "concepts": [
              "post-decrement",
              "while-loop"
            ]
          },
          {
            "line": 3,
            "action": "output",
            "description": "Output n=2",
            "output": "2"
          },
          {
            "line": 3,
            "action": "loop-check",
            "description": "Evaluate `n--`: return 2 (truthy), decrement n to 1",
            "state": {
              "n": 1
            }
          },
          {
            "line": 3,
            "action": "output",
            "description": "Output n=1",
            "output": "1"
          },
          {
            "line": 3,
            "action": "loop-check",
            "description": "Evaluate `n--`: return 1 (truthy), decrement n to 0",
            "state": {
              "n": 0
            }
          },
          {
            "line": 3,
            "action": "output",
            "description": "Output n=0",
            "output": "0"
          },
          {
            "line": 3,
            "action": "loop-check",
            "description": "Evaluate `n--`: return 0 (falsy), exit loop"
          }
        ],
        "finalOutput": "210",
        "keyInsight": "Post-decrement in condition: loop checks OLD value, but prints DECREMENTED value"
      }
    },
    {
      "id": "ctrl-027",
      "categoryId": "control-structures",
      "concept": "Expression evaluation order with increments",
      "code": "int main() {\n    int a = 2;\n    int b = ++a + ++a;\n    cout << b;\n}",
      "output": "8",
      "tags": [
        "control-flow"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "declare",
            "description": "Declare `a` = 2",
            "state": {
              "a": 2
            },
            "concepts": [
              "variable-declaration"
            ]
          },
          {
            "line": 3,
            "action": "evaluate",
            "description": "Evaluate `++a`: a becomes 3, returns 3",
            "state": {
              "a": 3
            },
            "concepts": [
              "pre-increment"
            ]
          },
          {
            "line": 3,
            "action": "evaluate",
            "description": "Evaluate second `++a`: a becomes 4, returns 4",
            "state": {
              "a": 4
            },
            "concepts": [
              "pre-increment"
            ]
          },
          {
            "line": 3,
            "action": "evaluate",
            "description": "Add: 4 + 4 = 8 (both references see final value)",
            "concepts": [
              "evaluation-order"
            ]
          },
          {
            "line": 3,
            "action": "declare",
            "description": "Store result in b",
            "state": {
              "b": 8
            }
          },
          {
            "line": 4,
            "action": "output",
            "description": "Output 8",
            "output": "8"
          }
        ],
        "finalOutput": "8",
        "keyInsight": "Multiple increments on same variable in one expression: both operands reference final value (4+4=8)"
      }
    },
    {
      "id": "ctrl-028",
      "categoryId": "control-structures",
      "concept": "Operator side effects",
      "code": "int main() {\n    int x = 1;\n    int y = x++ + ++x;\n    cout << x << y;\n}",
      "output": "34",
      "tags": [
        "control-flow",
        "operators"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "declare",
            "description": "Declare `x` = 1",
            "state": {
              "x": 1
            },
            "concepts": [
              "variable-declaration"
            ]
          },
          {
            "line": 3,
            "action": "evaluate",
            "description": "Evaluate `x++`: returns 1, x becomes 2",
            "state": {
              "x": 2
            },
            "concepts": [
              "post-increment"
            ]
          },
          {
            "line": 3,
            "action": "evaluate",
            "description": "Evaluate `++x`: x becomes 3, returns 3",
            "state": {
              "x": 3
            },
            "concepts": [
              "pre-increment"
            ]
          },
          {
            "line": 3,
            "action": "evaluate",
            "description": "Add: 1 + 3 = 4",
            "concepts": [
              "arithmetic"
            ]
          },
          {
            "line": 3,
            "action": "declare",
            "description": "Store result in y",
            "state": {
              "y": 4
            }
          },
          {
            "line": 4,
            "action": "output",
            "description": "Output x=3, y=4",
            "output": "34"
          }
        ],
        "finalOutput": "34",
        "keyInsight": "Mixing pre/post increment: x++ returns 1 (then x=2), ++x makes x=3 and returns 3; sum is 4"
      }
    },
    {
      "id": "ctrl-029",
      "categoryId": "control-structures",
      "concept": "General operator precedence rules",
      "code": "int main() {\n    cout << (2 + 3 * 4);\n}",
      "output": "14",
      "tags": [
        "control-flow",
        "operators"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "evaluate",
            "description": "Evaluate `3 * 4` first (higher precedence): 12",
            "concepts": [
              "operator-precedence"
            ]
          },
          {
            "line": 2,
            "action": "evaluate",
            "description": "Then `2 + 12` = 14",
            "concepts": [
              "arithmetic"
            ]
          },
          {
            "line": 2,
            "action": "output",
            "description": "Output 14",
            "output": "14"
          }
        ],
        "finalOutput": "14",
        "keyInsight": "Multiplication has higher precedence than addition: 2 + 3 * 4 = 2 + 12 = 14"
      }
    },
    {
      "id": "ctrl-030",
      "categoryId": "control-structures",
      "concept": "Precedence with logical operators",
      "code": "int main() {\n    cout << (1 || 0 && 0);\n}",
      "output": "1",
      "tags": [
        "control-flow",
        "operators"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "evaluate",
            "description": "Evaluate `0 && 0` first (&& has higher precedence than ||)",
            "concepts": [
              "operator-precedence",
              "logical-and"
            ]
          },
          {
            "line": 2,
            "action": "evaluate",
            "description": "`0 && 0` = 0",
            "concepts": [
              "logical-and"
            ]
          },
          {
            "line": 2,
            "action": "evaluate",
            "description": "Then `1 || 0` = 1",
            "concepts": [
              "logical-or"
            ]
          },
          {
            "line": 2,
            "action": "output",
            "description": "Output 1",
            "output": "1"
          }
        ],
        "finalOutput": "1",
        "keyInsight": "`&&` has higher precedence than `||`: `1 || 0 && 0` parses as `1 || (0 && 0)` = 1"
      }
    },
    {
      "id": "ctrl-031",
      "categoryId": "control-structures",
      "concept": "Division by zero avoidance via short-circuit",
      "code": "int main() {\n    int x = 0;\n    if (x != 0 && 10 / x > 1) cout << \"A\";\n    else cout << \"B\";\n}",
      "output": "B",
      "tags": [
        "control-flow"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "declare",
            "description": "Declare `x` = 0",
            "state": {
              "x": 0
            },
            "concepts": [
              "variable-declaration"
            ]
          },
          {
            "line": 3,
            "action": "evaluate",
            "description": "Evaluate `x != 0`: 0 != 0 is false",
            "concepts": [
              "comparison"
            ]
          },
          {
            "line": 3,
            "action": "branch",
            "description": "Short-circuit: left side false, skip `10 / x` (would be division by zero!)",
            "concepts": [
              "short-circuit"
            ]
          },
          {
            "line": 3,
            "action": "branch",
            "description": "Entire condition is false, go to else",
            "concepts": [
              "if-else"
            ]
          },
          {
            "line": 4,
            "action": "output",
            "description": "Output \"B\"",
            "output": "B"
          }
        ],
        "finalOutput": "B",
        "keyInsight": "Short-circuit evaluation prevents division by zero: when x==0, the right side is never evaluated"
      }
    },
    {
      "id": "func-001",
      "categoryId": "functions-scope",
      "concept": "Global variables",
      "code": "int g = 10;\nint main() {\n    cout << g;\n}",
      "output": "10",
      "tags": [
        "functions",
        "scope"
      ],
      "explanation": {
        "steps": [
          {
            "line": 1,
            "action": "declare",
            "description": "Declare global variable `g` = 10",
            "state": {
              "g": 10
            },
            "concepts": [
              "global-variable"
            ]
          },
          {
            "line": 3,
            "action": "evaluate",
            "description": "Access global `g`",
            "concepts": [
              "global-scope"
            ]
          },
          {
            "line": 3,
            "action": "output",
            "description": "Output 10",
            "output": "10"
          }
        ],
        "finalOutput": "10",
        "keyInsight": "Global variables are accessible from any function in the program"
      }
    },
    {
      "id": "func-002",
      "categoryId": "functions-scope",
      "concept": "Local variables",
      "code": "int main() {\n    int x = 5;\n    cout << x;\n}",
      "output": "5",
      "tags": [
        "functions",
        "scope"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "declare",
            "description": "Declare local variable `x` = 5",
            "state": {
              "x": 5
            },
            "concepts": [
              "local-variable"
            ]
          },
          {
            "line": 3,
            "action": "output",
            "description": "Output x=5",
            "output": "5"
          }
        ],
        "finalOutput": "5",
        "keyInsight": "Local variables exist only within their function scope"
      }
    },
    {
      "id": "func-003",
      "categoryId": "functions-scope",
      "concept": "Variable shadowing",
      "code": "int x = 1;\nint main() {\n    int x = 2;\n    cout << x;\n}",
      "output": "2",
      "tags": [
        "functions",
        "scope"
      ],
      "explanation": {
        "steps": [
          {
            "line": 1,
            "action": "declare",
            "description": "Declare global `x` = 1",
            "state": {
              "global x": 1
            },
            "concepts": [
              "global-variable"
            ]
          },
          {
            "line": 3,
            "action": "declare",
            "description": "Declare local `x` = 2 (shadows global)",
            "state": {
              "local x": 2
            },
            "concepts": [
              "shadowing"
            ]
          },
          {
            "line": 4,
            "action": "output",
            "description": "Output local x=2 (shadows global)",
            "output": "2"
          }
        ],
        "finalOutput": "2",
        "keyInsight": "Local variables 'shadow' (hide) global variables with the same name"
      }
    },
    {
      "id": "func-004",
      "categoryId": "functions-scope",
      "concept": "Scope resolution operator `::`",
      "code": "int x = 10;\nint main() {\n    int x = 20;\n    cout << ::x << x;\n}",
      "output": "1020",
      "tags": [
        "functions",
        "scope",
        "operators"
      ],
      "explanation": {
        "steps": [
          {
            "line": 1,
            "action": "declare",
            "description": "Declare global `x` = 10",
            "state": {
              "global x": 10
            },
            "concepts": [
              "global-variable"
            ]
          },
          {
            "line": 3,
            "action": "declare",
            "description": "Declare local `x` = 20",
            "state": {
              "local x": 20
            },
            "concepts": [
              "local-variable"
            ]
          },
          {
            "line": 4,
            "action": "evaluate",
            "description": "`::x` accesses global x (scope resolution)",
            "concepts": [
              "scope-resolution"
            ]
          },
          {
            "line": 4,
            "action": "output",
            "description": "Output global x=10",
            "output": "10"
          },
          {
            "line": 4,
            "action": "evaluate",
            "description": "`x` accesses local x"
          },
          {
            "line": 4,
            "action": "output",
            "description": "Output local x=20",
            "output": "20"
          }
        ],
        "finalOutput": "1020",
        "keyInsight": "Scope resolution operator `::` accesses global scope, bypassing local shadowing"
      }
    },
    {
      "id": "func-005",
      "categoryId": "functions-scope",
      "concept": "Block scope `{}`",
      "code": "int main() {\n    int x = 1;\n    { int x = 2; cout << x; }\n    cout << x;\n}",
      "output": "21",
      "tags": [
        "functions",
        "scope"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "declare",
            "description": "Declare outer `x` = 1",
            "state": {
              "outer x": 1
            },
            "concepts": [
              "local-variable"
            ]
          },
          {
            "line": 3,
            "action": "declare",
            "description": "Enter inner block, declare `x` = 2",
            "state": {
              "inner x": 2
            },
            "concepts": [
              "block-scope"
            ]
          },
          {
            "line": 3,
            "action": "output",
            "description": "Output inner x=2",
            "output": "2"
          },
          {
            "line": 4,
            "action": "evaluate",
            "description": "Exit inner block, inner x destroyed",
            "concepts": [
              "variable-lifetime"
            ]
          },
          {
            "line": 4,
            "action": "output",
            "description": "Output outer x=1",
            "output": "1"
          }
        ],
        "finalOutput": "21",
        "keyInsight": "Block scope `{}` creates a new scope; variables declared inside are destroyed when block exits"
      }
    },
    {
      "id": "func-006",
      "categoryId": "functions-scope",
      "concept": "Nested scopes",
      "code": "int main() {\n    int x = 1;\n    { int x = 2;\n      { int x = 3; cout << x; }\n      cout << x;\n    }\n    cout << x;\n}",
      "output": "321",
      "tags": [
        "functions",
        "scope"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "declare",
            "description": "Level 1: x=1",
            "state": {
              "x1": 1
            },
            "concepts": [
              "nested-scope"
            ]
          },
          {
            "line": 3,
            "action": "declare",
            "description": "Level 2: x=2",
            "state": {
              "x2": 2
            }
          },
          {
            "line": 4,
            "action": "declare",
            "description": "Level 3: x=3",
            "state": {
              "x3": 3
            }
          },
          {
            "line": 4,
            "action": "output",
            "description": "Output innermost x=3",
            "output": "3"
          },
          {
            "line": 5,
            "action": "output",
            "description": "Output level 2 x=2",
            "output": "2"
          },
          {
            "line": 7,
            "action": "output",
            "description": "Output level 1 x=1",
            "output": "1"
          }
        ],
        "finalOutput": "321",
        "keyInsight": "Nested scopes each have their own x; inner x shadows outer x at each level"
      }
    },
    {
      "id": "func-007",
      "categoryId": "functions-scope",
      "concept": "Variable lifetime",
      "code": "int main() {\n    int* p;\n    { int x = 5; p = &x; }\n    // x is destroyed, p is dangling\n    cout << \"done\";\n}",
      "output": "done",
      "tags": [
        "functions",
        "scope",
        "conditionals"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "declare",
            "description": "Declare pointer `p`",
            "concepts": [
              "pointer"
            ]
          },
          {
            "line": 3,
            "action": "declare",
            "description": "Enter block: declare `x` = 5",
            "state": {
              "x": 5
            },
            "concepts": [
              "block-scope"
            ]
          },
          {
            "line": 3,
            "action": "assign",
            "description": "Store address of x in p",
            "state": {
              "p": "&x"
            },
            "concepts": [
              "address-of"
            ]
          },
          {
            "line": 3,
            "action": "evaluate",
            "description": "Exit block: x is destroyed, p now dangles",
            "concepts": [
              "dangling-pointer",
              "variable-lifetime"
            ]
          },
          {
            "line": 5,
            "action": "output",
            "description": "Output \"done\"",
            "output": "done"
          }
        ],
        "finalOutput": "done",
        "keyInsight": "When a variable goes out of scope, pointers to it become dangling (undefined behavior if dereferenced)"
      }
    },
    {
      "id": "func-008",
      "categoryId": "functions-scope",
      "concept": "Function parameters basics",
      "code": "void f(int x) { cout << x; }\nint main() { f(42); }",
      "output": "42",
      "tags": [
        "functions",
        "scope"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "call",
            "description": "Call f(42)",
            "concepts": [
              "function-call"
            ]
          },
          {
            "line": 1,
            "action": "declare",
            "description": "Parameter x receives value 42",
            "state": {
              "x": 42
            },
            "concepts": [
              "function-parameter"
            ]
          },
          {
            "line": 1,
            "action": "output",
            "description": "Output 42",
            "output": "42"
          }
        ],
        "finalOutput": "42",
        "keyInsight": "Function parameters receive copies of the argument values"
      }
    },
    {
      "id": "func-009",
      "categoryId": "functions-scope",
      "concept": "Pass-by-value (copy)",
      "code": "void f(int x) { x = 99; }\nint main() {\n    int a = 5;\n    f(a);\n    cout << a;\n}",
      "output": "5",
      "tags": [
        "functions",
        "scope",
        "copy-semantics"
      ],
      "explanation": {
        "steps": [
          {
            "line": 3,
            "action": "declare",
            "description": "Declare `a` = 5",
            "state": {
              "a": 5
            },
            "concepts": [
              "local-variable"
            ]
          },
          {
            "line": 4,
            "action": "call",
            "description": "Call f(a): copy of a passed",
            "concepts": [
              "pass-by-value"
            ]
          },
          {
            "line": 1,
            "action": "declare",
            "description": "Parameter x = 5 (copy)",
            "state": {
              "x": 5
            }
          },
          {
            "line": 1,
            "action": "assign",
            "description": "x = 99 (only modifies copy)",
            "state": {
              "x": 99,
              "a": 5
            }
          },
          {
            "line": 5,
            "action": "output",
            "description": "Output a=5 (unchanged)",
            "output": "5"
          }
        ],
        "finalOutput": "5",
        "keyInsight": "Pass-by-value creates a copy; modifications don't affect the original"
      }
    },
    {
      "id": "func-010",
      "categoryId": "functions-scope",
      "concept": "Pass-by-reference `&`",
      "code": "void f(int& x) { x = 99; }\nint main() {\n    int a = 5;\n    f(a);\n    cout << a;\n}",
      "output": "99",
      "tags": [
        "functions",
        "scope",
        "references"
      ],
      "explanation": {
        "steps": [
          {
            "line": 3,
            "action": "declare",
            "description": "Declare `a` = 5",
            "state": {
              "a": 5
            },
            "concepts": [
              "local-variable"
            ]
          },
          {
            "line": 4,
            "action": "call",
            "description": "Call f(a): reference to a passed",
            "concepts": [
              "pass-by-reference"
            ]
          },
          {
            "line": 1,
            "action": "declare",
            "description": "Parameter x is reference to a",
            "state": {
              "x": "ref->a"
            }
          },
          {
            "line": 1,
            "action": "assign",
            "description": "x = 99 modifies a through reference",
            "state": {
              "a": 99
            }
          },
          {
            "line": 5,
            "action": "output",
            "description": "Output a=99",
            "output": "99"
          }
        ],
        "finalOutput": "99",
        "keyInsight": "Pass-by-reference (`int& x`) allows function to modify the original variable"
      }
    },
    {
      "id": "func-011",
      "categoryId": "functions-scope",
      "concept": "Modifying original variables through reference",
      "code": "void add10(int& n) { n += 10; }\nint main() {\n    int x = 5;\n    add10(x);\n    cout << x;\n}",
      "output": "15",
      "tags": [
        "functions",
        "scope",
        "conditionals",
        "references"
      ],
      "explanation": {
        "steps": [
          {
            "line": 3,
            "action": "declare",
            "description": "Declare `x` = 5",
            "state": {
              "x": 5
            },
            "concepts": [
              "local-variable"
            ]
          },
          {
            "line": 4,
            "action": "call",
            "description": "Call add10(x)",
            "concepts": [
              "pass-by-reference"
            ]
          },
          {
            "line": 1,
            "action": "declare",
            "description": "Parameter n is reference to x",
            "state": {
              "n": "ref->x"
            }
          },
          {
            "line": 1,
            "action": "assign",
            "description": "n += 10: x becomes 15",
            "state": {
              "x": 15
            }
          },
          {
            "line": 5,
            "action": "output",
            "description": "Output x=15",
            "output": "15"
          }
        ],
        "finalOutput": "15",
        "keyInsight": "Reference parameters modify the original variable directly"
      }
    },
    {
      "id": "func-012",
      "categoryId": "functions-scope",
      "concept": "Evaluation order of arguments (unspecified)",
      "code": "int a = 0;\nint f() { return ++a; }\nint g() { return ++a; }\nvoid show(int x, int y) { cout << x + y; }\nint main() { show(f(), g()); }",
      "output": "3",
      "tags": [
        "functions",
        "scope",
        "conditionals"
      ],
      "explanation": {
        "steps": [
          {
            "line": 1,
            "action": "declare",
            "description": "Global `a` = 0",
            "state": {
              "a": 0
            },
            "concepts": [
              "global-variable"
            ]
          },
          {
            "line": 5,
            "action": "call",
            "description": "Call show(f(), g()) - order unspecified",
            "concepts": [
              "evaluation-order"
            ]
          },
          {
            "line": 2,
            "action": "call",
            "description": "f() increments a, returns 1",
            "state": {
              "a": 1
            }
          },
          {
            "line": 3,
            "action": "call",
            "description": "g() increments a, returns 2",
            "state": {
              "a": 2
            }
          },
          {
            "line": 4,
            "action": "output",
            "description": "show outputs x+y = 1+2 = 3",
            "output": "3"
          }
        ],
        "finalOutput": "3",
        "keyInsight": "Argument evaluation order is unspecified, but total (1+2=3) is consistent"
      }
    },
    {
      "id": "func-013",
      "categoryId": "functions-scope",
      "concept": "Side effects in arguments",
      "code": "void f(int a, int b) { cout << a << b; }\nint main() {\n    int x = 0;\n    f(x++, x++);  // Order unspecified\n    cout << x;\n}",
      "output": "Output is unspecified (could be 012, 102, etc.), but x ends as 2",
      "tags": [
        "functions",
        "scope"
      ],
      "explanation": {
        "steps": [
          {
            "line": 3,
            "action": "declare",
            "description": "Declare `x` = 0",
            "state": {
              "x": 0
            },
            "concepts": [
              "local-variable"
            ]
          },
          {
            "line": 4,
            "action": "call",
            "description": "Call f(x++, x++) - evaluation order unspecified",
            "concepts": [
              "evaluation-order",
              "side-effects"
            ]
          },
          {
            "line": 4,
            "action": "evaluate",
            "description": "Both x++ execute (order unknown), x ends as 2",
            "state": {
              "x": 2
            }
          },
          {
            "line": 5,
            "action": "output",
            "description": "Output x=2",
            "output": "2"
          }
        ],
        "finalOutput": "Output is unspecified (could be 012, 102, etc.), but x ends as 2",
        "keyInsight": "Multiple side effects on same variable in one expression have unspecified order"
      }
    },
    {
      "id": "func-014",
      "categoryId": "functions-scope",
      "concept": "Reference declaration `&`",
      "code": "int main() {\n    int x = 5;\n    int& r = x;\n    cout << r;\n}",
      "output": "5",
      "tags": [
        "functions",
        "scope",
        "references"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "declare",
            "description": "Declare `x` = 5",
            "state": {
              "x": 5
            },
            "concepts": [
              "local-variable"
            ]
          },
          {
            "line": 3,
            "action": "declare",
            "description": "Declare reference `r` bound to x",
            "state": {
              "r": "ref->x"
            },
            "concepts": [
              "reference"
            ]
          },
          {
            "line": 4,
            "action": "output",
            "description": "Output r (same as x) = 5",
            "output": "5"
          }
        ],
        "finalOutput": "5",
        "keyInsight": "A reference is an alias for another variable; `r` and `x` refer to the same memory"
      }
    },
    {
      "id": "func-015",
      "categoryId": "functions-scope",
      "concept": "Reference initialization (required)",
      "code": "int main() {\n    int x = 10;\n    int& r = x;  // Must initialize\n    cout << r;\n}",
      "output": "10",
      "tags": [
        "functions",
        "scope",
        "references"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "declare",
            "description": "Declare `x` = 10",
            "state": {
              "x": 10
            },
            "concepts": [
              "local-variable"
            ]
          },
          {
            "line": 3,
            "action": "declare",
            "description": "Declare and initialize reference `r` to x",
            "state": {
              "r": "ref->x"
            },
            "concepts": [
              "reference-initialization"
            ]
          },
          {
            "line": 4,
            "action": "output",
            "description": "Output r=10",
            "output": "10"
          }
        ],
        "finalOutput": "10",
        "keyInsight": "References MUST be initialized when declared; uninitialized references are illegal"
      }
    },
    {
      "id": "func-016",
      "categoryId": "functions-scope",
      "concept": "Reference rebinding (not possible)",
      "code": "int main() {\n    int a = 1, b = 2;\n    int& r = a;\n    r = b;  // Assigns b's value to a, doesn't rebind\n    cout << a << r;\n}",
      "output": "22",
      "tags": [
        "functions",
        "scope",
        "references"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "declare",
            "description": "Declare a=1, b=2",
            "state": {
              "a": 1,
              "b": 2
            },
            "concepts": [
              "local-variable"
            ]
          },
          {
            "line": 3,
            "action": "declare",
            "description": "Declare reference `r` bound to a",
            "state": {
              "r": "ref->a"
            },
            "concepts": [
              "reference"
            ]
          },
          {
            "line": 4,
            "action": "assign",
            "description": "`r = b` assigns b's VALUE to a (not rebind!)",
            "state": {
              "a": 2,
              "b": 2
            },
            "concepts": [
              "reference-semantics"
            ]
          },
          {
            "line": 5,
            "action": "output",
            "description": "Output a=2, r=2 (same location)",
            "output": "22"
          }
        ],
        "finalOutput": "22",
        "keyInsight": "References cannot be rebound; `r = b` copies b's value to a, not rebind r to b"
      }
    },
    {
      "id": "func-017",
      "categoryId": "functions-scope",
      "concept": "Assignment through reference",
      "code": "int main() {\n    int x = 5;\n    int& r = x;\n    r = 10;\n    cout << x;\n}",
      "output": "10",
      "tags": [
        "functions",
        "scope",
        "references"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "declare",
            "description": "Declare `x` = 5",
            "state": {
              "x": 5
            },
            "concepts": [
              "local-variable"
            ]
          },
          {
            "line": 3,
            "action": "declare",
            "description": "Declare reference `r` to x",
            "state": {
              "r": "ref->x"
            },
            "concepts": [
              "reference"
            ]
          },
          {
            "line": 4,
            "action": "assign",
            "description": "Assign through reference: r=10 changes x",
            "state": {
              "x": 10
            },
            "concepts": [
              "reference-assignment"
            ]
          },
          {
            "line": 5,
            "action": "output",
            "description": "Output x=10",
            "output": "10"
          }
        ],
        "finalOutput": "10",
        "keyInsight": "Assigning to a reference modifies the referenced variable"
      }
    },
    {
      "id": "func-018",
      "categoryId": "functions-scope",
      "concept": "`const` reference parameter",
      "code": "void f(const int& x) { cout << x; }\nint main() { f(42); }",
      "output": "42",
      "tags": [
        "functions",
        "scope",
        "references",
        "const"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "call",
            "description": "Call f(42) with literal",
            "concepts": [
              "const-reference"
            ]
          },
          {
            "line": 1,
            "action": "declare",
            "description": "const int& x binds to temporary holding 42",
            "concepts": [
              "temporary-binding"
            ]
          },
          {
            "line": 1,
            "action": "output",
            "description": "Output 42",
            "output": "42"
          }
        ],
        "finalOutput": "42",
        "keyInsight": "Const references can bind to literals/temporaries (non-const references cannot)"
      }
    },
    {
      "id": "func-019",
      "categoryId": "functions-scope",
      "concept": "Binding references to literals",
      "code": "int main() {\n    const int& r = 5;  // OK with const\n    cout << r;\n}",
      "output": "5",
      "tags": [
        "functions",
        "scope",
        "references"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "declare",
            "description": "Declare const reference `r` bound to literal 5",
            "state": {
              "r": 5
            },
            "concepts": [
              "const-reference",
              "temporary-binding"
            ]
          },
          {
            "line": 3,
            "action": "output",
            "description": "Output r=5",
            "output": "5"
          }
        ],
        "finalOutput": "5",
        "keyInsight": "`const T&` can bind to literals because it promises not to modify"
      }
    },
    {
      "id": "func-020",
      "categoryId": "functions-scope",
      "concept": "Binding references to temporaries",
      "code": "int get() { return 10; }\nint main() {\n    const int& r = get();  // OK with const\n    cout << r;\n}",
      "output": "10",
      "tags": [
        "functions",
        "scope",
        "references"
      ],
      "explanation": {
        "steps": [
          {
            "line": 3,
            "action": "call",
            "description": "Call get() which returns 10",
            "concepts": [
              "return-value"
            ]
          },
          {
            "line": 3,
            "action": "declare",
            "description": "const int& r binds to returned temporary",
            "concepts": [
              "const-reference",
              "temporary-binding"
            ]
          },
          {
            "line": 4,
            "action": "output",
            "description": "Output r=10",
            "output": "10"
          }
        ],
        "finalOutput": "10",
        "keyInsight": "Const reference extends lifetime of temporary returned from function"
      }
    },
    {
      "id": "func-021",
      "categoryId": "functions-scope",
      "concept": "Read-only access with const reference",
      "code": "void f(const int& x) {\n    // x = 5;  // Error: can't modify\n    cout << x;\n}\nint main() { int a = 3; f(a); }",
      "output": "3",
      "tags": [
        "functions",
        "scope",
        "references",
        "const"
      ],
      "explanation": {
        "steps": [
          {
            "line": 5,
            "action": "declare",
            "description": "Declare `a` = 3",
            "state": {
              "a": 3
            },
            "concepts": [
              "local-variable"
            ]
          },
          {
            "line": 5,
            "action": "call",
            "description": "Call f(a) with const reference",
            "concepts": [
              "const-reference"
            ]
          },
          {
            "line": 3,
            "action": "output",
            "description": "Output x=3 (read-only access)",
            "output": "3"
          }
        ],
        "finalOutput": "3",
        "keyInsight": "Const reference provides read-only access; modifying x would be compile error"
      }
    },
    {
      "id": "func-022",
      "categoryId": "functions-scope",
      "concept": "Returning `&` reference",
      "code": "int& getRef(int& x) { return x; }\nint main() {\n    int a = 5;\n    getRef(a) = 10;\n    cout << a;\n}",
      "output": "10",
      "tags": [
        "functions",
        "scope",
        "references"
      ],
      "explanation": {
        "steps": [
          {
            "line": 3,
            "action": "declare",
            "description": "Declare `a` = 5",
            "state": {
              "a": 5
            },
            "concepts": [
              "local-variable"
            ]
          },
          {
            "line": 4,
            "action": "call",
            "description": "Call getRef(a) - returns reference to a",
            "concepts": [
              "return-reference"
            ]
          },
          {
            "line": 1,
            "action": "return",
            "description": "Return reference to x (which is a)",
            "concepts": [
              "lvalue-return"
            ]
          },
          {
            "line": 4,
            "action": "assign",
            "description": "Assign 10 to returned reference (modifies a)",
            "state": {
              "a": 10
            }
          },
          {
            "line": 5,
            "action": "output",
            "description": "Output a=10",
            "output": "10"
          }
        ],
        "finalOutput": "10",
        "keyInsight": "Returning a reference allows the function call to be an lvalue (assignable)"
      }
    },
    {
      "id": "func-023",
      "categoryId": "functions-scope",
      "concept": "Lvalue return",
      "code": "int arr[3] = {1, 2, 3};\nint& at(int i) { return arr[i]; }\nint main() {\n    at(1) = 99;\n    cout << arr[1];\n}",
      "output": "99",
      "tags": [
        "functions",
        "scope"
      ],
      "explanation": {
        "steps": [
          {
            "line": 1,
            "action": "declare",
            "description": "Global array arr = {1, 2, 3}",
            "state": {
              "arr": [
                1,
                2,
                3
              ]
            },
            "concepts": [
              "global-variable"
            ]
          },
          {
            "line": 4,
            "action": "call",
            "description": "Call at(1) - returns reference to arr[1]",
            "concepts": [
              "return-reference"
            ]
          },
          {
            "line": 2,
            "action": "return",
            "description": "Return reference to arr[1]",
            "concepts": [
              "lvalue-return"
            ]
          },
          {
            "line": 4,
            "action": "assign",
            "description": "Assign 99 through reference",
            "state": {
              "arr": [
                1,
                99,
                3
              ]
            }
          },
          {
            "line": 5,
            "action": "output",
            "description": "Output arr[1]=99",
            "output": "99"
          }
        ],
        "finalOutput": "99",
        "keyInsight": "Returning reference to array element allows array modification through function call"
      }
    },
    {
      "id": "func-024",
      "categoryId": "functions-scope",
      "concept": "Function call on left-hand side of assignment",
      "code": "int x = 0;\nint& get() { return x; }\nint main() {\n    get() = 42;\n    cout << x;\n}",
      "output": "42",
      "tags": [
        "functions",
        "scope"
      ],
      "explanation": {
        "steps": [
          {
            "line": 1,
            "action": "declare",
            "description": "Global `x` = 0",
            "state": {
              "x": 0
            },
            "concepts": [
              "global-variable"
            ]
          },
          {
            "line": 4,
            "action": "call",
            "description": "Call get() on left side of assignment",
            "concepts": [
              "return-reference"
            ]
          },
          {
            "line": 2,
            "action": "return",
            "description": "Return reference to global x",
            "concepts": [
              "lvalue-return"
            ]
          },
          {
            "line": 4,
            "action": "assign",
            "description": "Assign 42 through returned reference",
            "state": {
              "x": 42
            }
          },
          {
            "line": 5,
            "action": "output",
            "description": "Output x=42",
            "output": "42"
          }
        ],
        "finalOutput": "42",
        "keyInsight": "A function returning a reference can appear on the left side of an assignment"
      }
    },
    {
      "id": "func-025",
      "categoryId": "functions-scope",
      "concept": "`static` keyword",
      "code": "void f() {\n    static int x = 0;\n    cout << ++x;\n}\nint main() { f(); f(); f(); }",
      "output": "123",
      "tags": [
        "functions",
        "scope",
        "static"
      ],
      "explanation": {
        "steps": [
          {
            "line": 5,
            "action": "call",
            "description": "First call to f()",
            "concepts": [
              "function-call"
            ]
          },
          {
            "line": 2,
            "action": "initialize",
            "description": "Static x initialized to 0 (only once)",
            "state": {
              "x": 0
            },
            "concepts": [
              "static-local"
            ]
          },
          {
            "line": 3,
            "action": "evaluate",
            "description": "++x: x becomes 1",
            "state": {
              "x": 1
            }
          },
          {
            "line": 3,
            "action": "output",
            "description": "Output 1",
            "output": "1"
          },
          {
            "line": 5,
            "action": "call",
            "description": "Second call to f()"
          },
          {
            "line": 3,
            "action": "evaluate",
            "description": "++x: x becomes 2 (retained value)",
            "state": {
              "x": 2
            }
          },
          {
            "line": 3,
            "action": "output",
            "description": "Output 2",
            "output": "2"
          },
          {
            "line": 5,
            "action": "call",
            "description": "Third call to f()"
          },
          {
            "line": 3,
            "action": "evaluate",
            "description": "++x: x becomes 3",
            "state": {
              "x": 3
            }
          },
          {
            "line": 3,
            "action": "output",
            "description": "Output 3",
            "output": "3"
          }
        ],
        "finalOutput": "123",
        "keyInsight": "Static local variables retain their value between function calls"
      }
    },
    {
      "id": "func-026",
      "categoryId": "functions-scope",
      "concept": "Static local variable",
      "code": "int count() {\n    static int c = 0;\n    return ++c;\n}\nint main() { cout << count() << count(); }",
      "output": "12",
      "tags": [
        "functions",
        "scope",
        "static"
      ],
      "explanation": {
        "steps": [
          {
            "line": 5,
            "action": "call",
            "description": "First call to count()",
            "concepts": [
              "function-call"
            ]
          },
          {
            "line": 2,
            "action": "initialize",
            "description": "Static c initialized to 0",
            "state": {
              "c": 0
            },
            "concepts": [
              "static-local"
            ]
          },
          {
            "line": 3,
            "action": "return",
            "description": "Return ++c = 1",
            "state": {
              "c": 1
            }
          },
          {
            "line": 5,
            "action": "output",
            "description": "Output 1",
            "output": "1"
          },
          {
            "line": 5,
            "action": "call",
            "description": "Second call to count()"
          },
          {
            "line": 3,
            "action": "return",
            "description": "Return ++c = 2",
            "state": {
              "c": 2
            }
          },
          {
            "line": 5,
            "action": "output",
            "description": "Output 2",
            "output": "2"
          }
        ],
        "finalOutput": "12",
        "keyInsight": "Static variable c persists across calls, acting as a counter"
      }
    },
    {
      "id": "func-027",
      "categoryId": "functions-scope",
      "concept": "Static initialization (once only)",
      "code": "void f() {\n    static int x = 10;\n    x++;\n    cout << x;\n}\nint main() { f(); f(); }",
      "output": "1112",
      "tags": [
        "functions",
        "scope",
        "static"
      ],
      "explanation": {
        "steps": [
          {
            "line": 5,
            "action": "call",
            "description": "First call to f()",
            "concepts": [
              "function-call"
            ]
          },
          {
            "line": 2,
            "action": "initialize",
            "description": "Static x = 10 (initialized only once)",
            "state": {
              "x": 10
            },
            "concepts": [
              "static-initialization"
            ]
          },
          {
            "line": 3,
            "action": "evaluate",
            "description": "x++: x becomes 11",
            "state": {
              "x": 11
            }
          },
          {
            "line": 4,
            "action": "output",
            "description": "Output 11",
            "output": "11"
          },
          {
            "line": 5,
            "action": "call",
            "description": "Second call to f()"
          },
          {
            "line": 3,
            "action": "evaluate",
            "description": "x++: x becomes 12 (skip init)",
            "state": {
              "x": 12
            }
          },
          {
            "line": 4,
            "action": "output",
            "description": "Output 12",
            "output": "12"
          }
        ],
        "finalOutput": "1112",
        "keyInsight": "Static initialization happens only once; subsequent calls skip the initialization"
      }
    },
    {
      "id": "func-028",
      "categoryId": "functions-scope",
      "concept": "Persistence across function calls",
      "code": "int next() {\n    static int n = 0;\n    return n++;\n}\nint main() { cout << next() << next() << next(); }",
      "output": "012",
      "tags": [
        "functions",
        "scope"
      ],
      "explanation": {
        "steps": [
          {
            "line": 4,
            "action": "call",
            "description": "First call: next()",
            "concepts": [
              "function-call"
            ]
          },
          {
            "line": 2,
            "action": "initialize",
            "description": "Static n = 0",
            "state": {
              "n": 0
            },
            "concepts": [
              "static-local"
            ]
          },
          {
            "line": 3,
            "action": "return",
            "description": "Return n++ = 0, n becomes 1",
            "state": {
              "n": 1
            }
          },
          {
            "line": 4,
            "action": "output",
            "description": "Output 0",
            "output": "0"
          },
          {
            "line": 4,
            "action": "call",
            "description": "Second call"
          },
          {
            "line": 3,
            "action": "return",
            "description": "Return 1, n becomes 2",
            "state": {
              "n": 2
            }
          },
          {
            "line": 4,
            "action": "output",
            "description": "Output 1",
            "output": "1"
          },
          {
            "line": 4,
            "action": "call",
            "description": "Third call"
          },
          {
            "line": 3,
            "action": "return",
            "description": "Return 2, n becomes 3",
            "state": {
              "n": 3
            }
          },
          {
            "line": 4,
            "action": "output",
            "description": "Output 2",
            "output": "2"
          }
        ],
        "finalOutput": "012",
        "keyInsight": "Post-increment in return: returns old value, increments for next call"
      }
    },
    {
      "id": "func-029",
      "categoryId": "functions-scope",
      "concept": "Recursion basics",
      "code": "int fact(int n) {\n    if (n <= 1) return 1;\n    return n * fact(n - 1);\n}\nint main() { cout << fact(4); }",
      "output": "24",
      "tags": [
        "functions",
        "scope"
      ],
      "explanation": {
        "steps": [
          {
            "line": 5,
            "action": "call",
            "description": "Call fact(4)",
            "concepts": [
              "recursion"
            ]
          },
          {
            "line": 2,
            "action": "branch",
            "description": "4 > 1, recurse: 4 * fact(3)",
            "concepts": [
              "recursive-case"
            ]
          },
          {
            "line": 2,
            "action": "branch",
            "description": "3 > 1, recurse: 3 * fact(2)"
          },
          {
            "line": 2,
            "action": "branch",
            "description": "2 > 1, recurse: 2 * fact(1)"
          },
          {
            "line": 2,
            "action": "branch",
            "description": "1 <= 1, return 1",
            "concepts": [
              "base-case"
            ]
          },
          {
            "line": 3,
            "action": "return",
            "description": "Unwind: 2*1=2, 3*2=6, 4*6=24"
          },
          {
            "line": 5,
            "action": "output",
            "description": "Output 24",
            "output": "24"
          }
        ],
        "finalOutput": "24",
        "keyInsight": "Recursion: function calls itself with smaller input until reaching base case"
      }
    },
    {
      "id": "func-030",
      "categoryId": "functions-scope",
      "concept": "Reference parameter sharing in recursion",
      "code": "void dec(int& n) {\n    if (n <= 0) return;\n    cout << n;\n    n--;\n    dec(n);\n}\nint main() { int x = 3; dec(x); }",
      "output": "321",
      "tags": [
        "functions",
        "scope",
        "references"
      ],
      "explanation": {
        "steps": [
          {
            "line": 5,
            "action": "declare",
            "description": "Declare x=3",
            "state": {
              "x": 3
            },
            "concepts": [
              "local-variable"
            ]
          },
          {
            "line": 5,
            "action": "call",
            "description": "Call dec(x) with reference",
            "concepts": [
              "pass-by-reference",
              "recursion"
            ]
          },
          {
            "line": 2,
            "action": "branch",
            "description": "n=3 > 0, continue"
          },
          {
            "line": 3,
            "action": "output",
            "description": "Output 3",
            "output": "3"
          },
          {
            "line": 4,
            "action": "evaluate",
            "description": "n-- (x becomes 2)",
            "state": {
              "x": 2
            }
          },
          {
            "line": 5,
            "action": "call",
            "description": "Recurse dec(n) - same x"
          },
          {
            "line": 3,
            "action": "output",
            "description": "Output 2",
            "output": "2"
          },
          {
            "line": 4,
            "action": "evaluate",
            "description": "n-- (x becomes 1)",
            "state": {
              "x": 1
            }
          },
          {
            "line": 5,
            "action": "call",
            "description": "Recurse"
          },
          {
            "line": 3,
            "action": "output",
            "description": "Output 1",
            "output": "1"
          },
          {
            "line": 4,
            "action": "evaluate",
            "description": "n-- (x becomes 0)",
            "state": {
              "x": 0
            }
          },
          {
            "line": 2,
            "action": "branch",
            "description": "n=0, return"
          }
        ],
        "finalOutput": "321",
        "keyInsight": "Reference parameter shares same variable across all recursive calls"
      }
    },
    {
      "id": "func-031",
      "categoryId": "functions-scope",
      "concept": "Call stack",
      "code": "void f(int n) {\n    if (n == 0) return;\n    cout << n;\n    f(n - 1);\n    cout << n;\n}\nint main() { f(2); }",
      "output": "2112",
      "tags": [
        "functions",
        "scope"
      ],
      "explanation": {
        "steps": [
          {
            "line": 5,
            "action": "call",
            "description": "Call f(2)",
            "concepts": [
              "recursion",
              "call-stack"
            ]
          },
          {
            "line": 3,
            "action": "output",
            "description": "Output 2 (before recurse)",
            "output": "2"
          },
          {
            "line": 4,
            "action": "call",
            "description": "Call f(1)"
          },
          {
            "line": 3,
            "action": "output",
            "description": "Output 1 (before recurse)",
            "output": "1"
          },
          {
            "line": 4,
            "action": "call",
            "description": "Call f(0)"
          },
          {
            "line": 2,
            "action": "branch",
            "description": "n=0, return (base case)"
          },
          {
            "line": 5,
            "action": "output",
            "description": "Back in f(1): output 1",
            "output": "1"
          },
          {
            "line": 5,
            "action": "output",
            "description": "Back in f(2): output 2",
            "output": "2"
          }
        ],
        "finalOutput": "2112",
        "keyInsight": "Call stack: output before and after recursive call shows descent and unwind"
      }
    },
    {
      "id": "func-032",
      "categoryId": "functions-scope",
      "concept": "Unwinding behavior",
      "code": "void r(int n) {\n    if (n == 0) { cout << \"X\"; return; }\n    cout << n;\n    r(n - 1);\n    cout << n;\n}\nint main() { r(2); }",
      "output": "21X12",
      "tags": [
        "functions",
        "scope"
      ],
      "explanation": {
        "steps": [
          {
            "line": 5,
            "action": "call",
            "description": "Call r(2)",
            "concepts": [
              "recursion",
              "call-stack"
            ]
          },
          {
            "line": 3,
            "action": "output",
            "description": "Output 2 (descending)",
            "output": "2"
          },
          {
            "line": 4,
            "action": "call",
            "description": "Call r(1)"
          },
          {
            "line": 3,
            "action": "output",
            "description": "Output 1 (descending)",
            "output": "1"
          },
          {
            "line": 4,
            "action": "call",
            "description": "Call r(0)"
          },
          {
            "line": 2,
            "action": "branch",
            "description": "n=0, output X and return",
            "concepts": [
              "base-case"
            ]
          },
          {
            "line": 2,
            "action": "output",
            "description": "Output \"X\"",
            "output": "X"
          },
          {
            "line": 5,
            "action": "output",
            "description": "Unwinding r(1): output 1",
            "output": "1"
          },
          {
            "line": 5,
            "action": "output",
            "description": "Unwinding r(2): output 2",
            "output": "2"
          }
        ],
        "finalOutput": "21X12",
        "keyInsight": "Recursion shows symmetric pattern: 2,1 going down, X at base, 1,2 unwinding back"
      }
    },
    {
      "id": "ptr-001",
      "categoryId": "pointers",
      "concept": "Pointer declaration `*`",
      "code": "int main() {\n    int x = 5;\n    int* p = &x;\n    cout << \"pointer declared\";\n}",
      "output": "pointer declared",
      "tags": [
        "pointers",
        "memory"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "declare",
            "description": "Declare `x` = 5",
            "state": {
              "x": 5
            },
            "concepts": [
              "variable-declaration"
            ]
          },
          {
            "line": 3,
            "action": "declare",
            "description": "Declare pointer `p` and initialize with address of x",
            "state": {
              "p": "&x"
            },
            "concepts": [
              "pointer-declaration"
            ]
          },
          {
            "line": 4,
            "action": "output",
            "description": "Output \"pointer declared\"",
            "output": "pointer declared"
          }
        ],
        "finalOutput": "pointer declared",
        "keyInsight": "`int* p` declares p as a pointer to int; `*` indicates pointer type"
      }
    },
    {
      "id": "ptr-002",
      "categoryId": "pointers",
      "concept": "Address-of operator `&`",
      "code": "int main() {\n    int x = 5;\n    int* p = &x;\n    cout << (p == &x);\n}",
      "output": "1",
      "tags": [
        "pointers",
        "memory",
        "operators"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "declare",
            "description": "Declare `x` = 5",
            "state": {
              "x": 5
            },
            "concepts": [
              "variable-declaration"
            ]
          },
          {
            "line": 3,
            "action": "declare",
            "description": "Declare `p` = &x (address of x)",
            "state": {
              "p": "&x"
            },
            "concepts": [
              "address-of"
            ]
          },
          {
            "line": 4,
            "action": "evaluate",
            "description": "Compare p == &x: both are address of x",
            "concepts": [
              "pointer-comparison"
            ]
          },
          {
            "line": 4,
            "action": "output",
            "description": "Output 1 (true)",
            "output": "1"
          }
        ],
        "finalOutput": "1",
        "keyInsight": "`&x` returns the memory address of x; storing it in p makes p point to x"
      }
    },
    {
      "id": "ptr-003",
      "categoryId": "pointers",
      "concept": "Dereference operator `*`",
      "code": "int main() {\n    int x = 42;\n    int* p = &x;\n    cout << *p;\n}",
      "output": "42",
      "tags": [
        "pointers",
        "memory",
        "references",
        "operators"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "declare",
            "description": "Declare `x` = 42",
            "state": {
              "x": 42
            },
            "concepts": [
              "variable-declaration"
            ]
          },
          {
            "line": 3,
            "action": "declare",
            "description": "Declare `p` pointing to x",
            "state": {
              "p": "&x"
            },
            "concepts": [
              "pointer-declaration"
            ]
          },
          {
            "line": 4,
            "action": "dereference",
            "description": "`*p` dereferences p, getting value at that address",
            "concepts": [
              "dereference"
            ]
          },
          {
            "line": 4,
            "action": "output",
            "description": "Output *p = 42",
            "output": "42"
          }
        ],
        "finalOutput": "42",
        "keyInsight": "`*p` (dereference) accesses the value stored at the address p holds"
      }
    },
    {
      "id": "ptr-004",
      "categoryId": "pointers",
      "concept": "Modifying through pointer",
      "code": "int main() {\n    int x = 5;\n    int* p = &x;\n    *p = 10;\n    cout << x;\n}",
      "output": "10",
      "tags": [
        "pointers",
        "memory",
        "conditionals"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "declare",
            "description": "Declare `x` = 5",
            "state": {
              "x": 5
            },
            "concepts": [
              "variable-declaration"
            ]
          },
          {
            "line": 3,
            "action": "declare",
            "description": "Declare `p` pointing to x",
            "state": {
              "p": "&x"
            },
            "concepts": [
              "pointer-declaration"
            ]
          },
          {
            "line": 4,
            "action": "assign",
            "description": "`*p = 10`: modify value through pointer",
            "state": {
              "x": 10
            },
            "concepts": [
              "dereference",
              "pointer-modification"
            ]
          },
          {
            "line": 5,
            "action": "output",
            "description": "Output x = 10",
            "output": "10"
          }
        ],
        "finalOutput": "10",
        "keyInsight": "Assigning to `*p` modifies the variable that p points to"
      }
    },
    {
      "id": "ptr-005",
      "categoryId": "pointers",
      "concept": "Double pointer `**`",
      "code": "int main() {\n    int x = 5;\n    int* p = &x;\n    int** pp = &p;\n    cout << **pp;\n}",
      "output": "5",
      "tags": [
        "pointers",
        "memory"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "declare",
            "description": "Declare `x` = 5",
            "state": {
              "x": 5
            },
            "concepts": [
              "variable-declaration"
            ]
          },
          {
            "line": 3,
            "action": "declare",
            "description": "Declare `p` pointing to x",
            "state": {
              "p": "&x"
            },
            "concepts": [
              "pointer"
            ]
          },
          {
            "line": 4,
            "action": "declare",
            "description": "Declare `pp` pointing to p (pointer to pointer)",
            "state": {
              "pp": "&p"
            },
            "concepts": [
              "double-pointer"
            ]
          },
          {
            "line": 5,
            "action": "dereference",
            "description": "`**pp`: first * gives p, second * gives x",
            "concepts": [
              "double-dereference"
            ]
          },
          {
            "line": 5,
            "action": "output",
            "description": "Output **pp = 5",
            "output": "5"
          }
        ],
        "finalOutput": "5",
        "keyInsight": "Double pointer `int**` points to a pointer; `**pp` dereferences twice to get the value"
      }
    },
    {
      "id": "ptr-006",
      "categoryId": "pointers",
      "concept": "Multiple levels of indirection",
      "code": "int main() {\n    int x = 1;\n    int* p = &x;\n    int** pp = &p;\n    **pp = 9;\n    cout << x;\n}",
      "output": "9",
      "tags": [
        "pointers",
        "memory"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "declare",
            "description": "Declare `x` = 1",
            "state": {
              "x": 1
            },
            "concepts": [
              "variable-declaration"
            ]
          },
          {
            "line": 3,
            "action": "declare",
            "description": "Declare `p` pointing to x",
            "state": {
              "p": "&x"
            },
            "concepts": [
              "pointer"
            ]
          },
          {
            "line": 4,
            "action": "declare",
            "description": "Declare `pp` pointing to p",
            "state": {
              "pp": "&p"
            },
            "concepts": [
              "double-pointer"
            ]
          },
          {
            "line": 5,
            "action": "assign",
            "description": "`**pp = 9`: modify x through two indirections",
            "state": {
              "x": 9
            },
            "concepts": [
              "double-dereference"
            ]
          },
          {
            "line": 6,
            "action": "output",
            "description": "Output x = 9",
            "output": "9"
          }
        ],
        "finalOutput": "9",
        "keyInsight": "Assigning through `**pp` modifies the underlying variable through multiple indirections"
      }
    },
    {
      "id": "ptr-007",
      "categoryId": "pointers",
      "concept": "Dereferencing chain",
      "code": "int main() {\n    int a = 7;\n    int* p1 = &a;\n    int** p2 = &p1;\n    int*** p3 = &p2;\n    cout << ***p3;\n}",
      "output": "7",
      "tags": [
        "pointers",
        "memory"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "declare",
            "description": "Declare `a` = 7",
            "state": {
              "a": 7
            },
            "concepts": [
              "variable-declaration"
            ]
          },
          {
            "line": 3,
            "action": "declare",
            "description": "p1 points to a",
            "state": {
              "p1": "&a"
            },
            "concepts": [
              "pointer"
            ]
          },
          {
            "line": 4,
            "action": "declare",
            "description": "p2 points to p1",
            "state": {
              "p2": "&p1"
            },
            "concepts": [
              "double-pointer"
            ]
          },
          {
            "line": 5,
            "action": "declare",
            "description": "p3 points to p2 (triple pointer)",
            "state": {
              "p3": "&p2"
            },
            "concepts": [
              "triple-pointer"
            ]
          },
          {
            "line": 6,
            "action": "dereference",
            "description": "`***p3`: three dereferences to reach a",
            "concepts": [
              "multi-level-indirection"
            ]
          },
          {
            "line": 6,
            "action": "output",
            "description": "Output 7",
            "output": "7"
          }
        ],
        "finalOutput": "7",
        "keyInsight": "Each `*` follows one level of indirection: `***p3` traverses p3\u2192p2\u2192p1\u2192a"
      }
    },
    {
      "id": "ptr-008",
      "categoryId": "pointers",
      "concept": "Pointer reassignment",
      "code": "int main() {\n    int a = 1, b = 2;\n    int* p = &a;\n    p = &b;\n    cout << *p;\n}",
      "output": "2",
      "tags": [
        "pointers",
        "memory"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "declare",
            "description": "Declare a=1, b=2",
            "state": {
              "a": 1,
              "b": 2
            },
            "concepts": [
              "variable-declaration"
            ]
          },
          {
            "line": 3,
            "action": "declare",
            "description": "`p` points to a",
            "state": {
              "p": "&a"
            },
            "concepts": [
              "pointer"
            ]
          },
          {
            "line": 4,
            "action": "assign",
            "description": "Reassign `p` to point to b",
            "state": {
              "p": "&b"
            },
            "concepts": [
              "pointer-reassignment"
            ]
          },
          {
            "line": 5,
            "action": "output",
            "description": "Output *p = 2 (now points to b)",
            "output": "2"
          }
        ],
        "finalOutput": "2",
        "keyInsight": "Pointers can be reassigned to point to different variables"
      }
    },
    {
      "id": "ptr-009",
      "categoryId": "pointers",
      "concept": "Pointer vs pointed-to value",
      "code": "int main() {\n    int a = 5, b = 10;\n    int* p = &a;\n    *p = b;  // Changes a, not p\n    cout << a << *p;\n}",
      "output": "1010",
      "tags": [
        "pointers",
        "memory"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "declare",
            "description": "Declare a=5, b=10",
            "state": {
              "a": 5,
              "b": 10
            },
            "concepts": [
              "variable-declaration"
            ]
          },
          {
            "line": 3,
            "action": "declare",
            "description": "`p` points to a",
            "state": {
              "p": "&a"
            },
            "concepts": [
              "pointer"
            ]
          },
          {
            "line": 4,
            "action": "assign",
            "description": "`*p = b`: assign b's VALUE to a (not change p)",
            "state": {
              "a": 10
            },
            "concepts": [
              "dereference"
            ]
          },
          {
            "line": 5,
            "action": "output",
            "description": "Output a=10, *p=10 (same memory)",
            "output": "1010"
          }
        ],
        "finalOutput": "1010",
        "keyInsight": "`*p = b` changes the VALUE at p (which is a), NOT where p points"
      }
    },
    {
      "id": "ptr-010",
      "categoryId": "pointers",
      "concept": "Pointer arithmetic `ptr + n`",
      "code": "int main() {\n    int arr[] = {10, 20, 30};\n    int* p = arr;\n    cout << *(p + 1);\n}",
      "output": "20",
      "tags": [
        "pointers",
        "memory"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "declare",
            "description": "Declare array arr = {10, 20, 30}",
            "state": {
              "arr": [
                10,
                20,
                30
              ]
            },
            "concepts": [
              "array-declaration"
            ]
          },
          {
            "line": 3,
            "action": "declare",
            "description": "`p` points to arr (first element)",
            "state": {
              "p": "&arr[0]"
            },
            "concepts": [
              "array-decay"
            ]
          },
          {
            "line": 4,
            "action": "evaluate",
            "description": "`p + 1` points to second element",
            "concepts": [
              "pointer-arithmetic"
            ]
          },
          {
            "line": 4,
            "action": "dereference",
            "description": "`*(p + 1)` = arr[1] = 20",
            "concepts": [
              "dereference"
            ]
          },
          {
            "line": 4,
            "action": "output",
            "description": "Output 20",
            "output": "20"
          }
        ],
        "finalOutput": "20",
        "keyInsight": "Pointer arithmetic: `p + n` moves n elements forward (not n bytes)"
      }
    },
    {
      "id": "ptr-011",
      "categoryId": "pointers",
      "concept": "Array-pointer equivalence",
      "code": "int main() {\n    int arr[] = {1, 2, 3};\n    cout << (arr[1] == *(arr + 1));\n}",
      "output": "1",
      "tags": [
        "pointers",
        "memory",
        "arrays"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "declare",
            "description": "Declare arr = {1, 2, 3}",
            "state": {
              "arr": [
                1,
                2,
                3
              ]
            },
            "concepts": [
              "array-declaration"
            ]
          },
          {
            "line": 3,
            "action": "evaluate",
            "description": "Compare arr[1] with *(arr + 1)",
            "concepts": [
              "array-pointer-equivalence"
            ]
          },
          {
            "line": 3,
            "action": "evaluate",
            "description": "arr[1] = 2, *(arr+1) = 2: equal!",
            "concepts": [
              "subscript-operator"
            ]
          },
          {
            "line": 3,
            "action": "output",
            "description": "Output 1 (true)",
            "output": "1"
          }
        ],
        "finalOutput": "1",
        "keyInsight": "`arr[i]` is equivalent to `*(arr + i)` - subscript is syntactic sugar for pointer arithmetic"
      }
    },
    {
      "id": "ptr-012",
      "categoryId": "pointers",
      "concept": "`ptr[n]` bracket notation",
      "code": "int main() {\n    int arr[] = {5, 10, 15};\n    int* p = arr;\n    cout << p[2];\n}",
      "output": "15",
      "tags": [
        "pointers",
        "memory"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "declare",
            "description": "Declare arr = {5, 10, 15}",
            "state": {
              "arr": [
                5,
                10,
                15
              ]
            },
            "concepts": [
              "array-declaration"
            ]
          },
          {
            "line": 3,
            "action": "declare",
            "description": "`p` points to arr",
            "state": {
              "p": "&arr[0]"
            },
            "concepts": [
              "pointer"
            ]
          },
          {
            "line": 4,
            "action": "evaluate",
            "description": "`p[2]` is equivalent to `*(p + 2)`",
            "concepts": [
              "pointer-subscript"
            ]
          },
          {
            "line": 4,
            "action": "output",
            "description": "Output p[2] = 15",
            "output": "15"
          }
        ],
        "finalOutput": "15",
        "keyInsight": "Pointers support subscript notation: `p[n]` = `*(p + n)`"
      }
    },
    {
      "id": "ptr-013",
      "categoryId": "pointers",
      "concept": "`*p++` precedence",
      "code": "int main() {\n    int arr[] = {1, 2, 3};\n    int* p = arr;\n    cout << *p++;  // Dereference, then increment pointer\n    cout << *p;\n}",
      "output": "12",
      "tags": [
        "pointers",
        "memory"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "declare",
            "description": "Declare arr = {1, 2, 3}",
            "state": {
              "arr": [
                1,
                2,
                3
              ]
            },
            "concepts": [
              "array-declaration"
            ]
          },
          {
            "line": 3,
            "action": "declare",
            "description": "`p` points to arr[0]",
            "state": {
              "p": "&arr[0]"
            },
            "concepts": [
              "pointer"
            ]
          },
          {
            "line": 4,
            "action": "evaluate",
            "description": "`*p++`: dereference (get 1), then increment p",
            "state": {
              "p": "&arr[1]"
            },
            "concepts": [
              "post-increment",
              "operator-precedence"
            ]
          },
          {
            "line": 4,
            "action": "output",
            "description": "Output 1 (old *p)",
            "output": "1"
          },
          {
            "line": 5,
            "action": "output",
            "description": "Output *p = 2 (p now at arr[1])",
            "output": "2"
          }
        ],
        "finalOutput": "12",
        "keyInsight": "`*p++` returns value at current p, then moves p to next element (post-increment)"
      }
    },
    {
      "id": "ptr-014",
      "categoryId": "pointers",
      "concept": "`++*p` vs `*p++`",
      "code": "int main() {\n    int arr[] = {10, 20};\n    int* p = arr;\n    cout << ++*p;  // Increment value, not pointer\n    cout << *p;\n}",
      "output": "1111",
      "tags": [
        "pointers",
        "memory"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "declare",
            "description": "Declare arr = {10, 20}",
            "state": {
              "arr": [
                10,
                20
              ]
            },
            "concepts": [
              "array-declaration"
            ]
          },
          {
            "line": 3,
            "action": "declare",
            "description": "`p` points to arr[0]",
            "state": {
              "p": "&arr[0]"
            },
            "concepts": [
              "pointer"
            ]
          },
          {
            "line": 4,
            "action": "evaluate",
            "description": "`++*p`: increment VALUE at p (arr[0] becomes 11)",
            "state": {
              "arr": [
                11,
                20
              ]
            },
            "concepts": [
              "pre-increment",
              "dereference"
            ]
          },
          {
            "line": 4,
            "action": "output",
            "description": "Output 11 (incremented value)",
            "output": "11"
          },
          {
            "line": 5,
            "action": "output",
            "description": "Output *p = 11 (same location)",
            "output": "11"
          }
        ],
        "finalOutput": "1111",
        "keyInsight": "`++*p` increments the VALUE pointed to (not the pointer itself)"
      }
    },
    {
      "id": "ptr-015",
      "categoryId": "pointers",
      "concept": "Post-increment on pointer",
      "code": "int main() {\n    int arr[] = {1, 2, 3};\n    int* p = arr;\n    p++;\n    cout << *p;\n}",
      "output": "2",
      "tags": [
        "pointers",
        "memory"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "declare",
            "description": "Declare arr = {1, 2, 3}",
            "state": {
              "arr": [
                1,
                2,
                3
              ]
            },
            "concepts": [
              "array-declaration"
            ]
          },
          {
            "line": 3,
            "action": "declare",
            "description": "`p` points to arr[0]",
            "state": {
              "p": "&arr[0]"
            },
            "concepts": [
              "pointer"
            ]
          },
          {
            "line": 4,
            "action": "evaluate",
            "description": "`p++`: move p to next element",
            "state": {
              "p": "&arr[1]"
            },
            "concepts": [
              "pointer-increment"
            ]
          },
          {
            "line": 5,
            "action": "output",
            "description": "Output *p = 2",
            "output": "2"
          }
        ],
        "finalOutput": "2",
        "keyInsight": "Incrementing a pointer moves it to the next element in memory"
      }
    },
    {
      "id": "ptr-016",
      "categoryId": "pointers",
      "concept": "Pre-increment on value",
      "code": "int main() {\n    int x = 5;\n    int* p = &x;\n    ++*p;\n    cout << x;\n}",
      "output": "6",
      "tags": [
        "pointers",
        "memory"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "declare",
            "description": "Declare `x` = 5",
            "state": {
              "x": 5
            },
            "concepts": [
              "variable-declaration"
            ]
          },
          {
            "line": 3,
            "action": "declare",
            "description": "`p` points to x",
            "state": {
              "p": "&x"
            },
            "concepts": [
              "pointer"
            ]
          },
          {
            "line": 4,
            "action": "evaluate",
            "description": "`++*p`: increment value at p (x becomes 6)",
            "state": {
              "x": 6
            },
            "concepts": [
              "pre-increment",
              "dereference"
            ]
          },
          {
            "line": 5,
            "action": "output",
            "description": "Output x = 6",
            "output": "6"
          }
        ],
        "finalOutput": "6",
        "keyInsight": "`++*p` increments the pointed-to value; p still points to same location"
      }
    },
    {
      "id": "ptr-017",
      "categoryId": "pointers",
      "concept": "Pointer passed by value",
      "code": "void f(int* p) {\n    int local = 99;\n    p = &local;  // Only changes local copy of pointer\n}\nint main() {\n    int x = 5;\n    int* ptr = &x;\n    f(ptr);\n    cout << *ptr;\n}",
      "output": "5",
      "tags": [
        "pointers",
        "memory"
      ],
      "explanation": {
        "steps": [
          {
            "line": 4,
            "action": "declare",
            "description": "Declare `x` = 5",
            "state": {
              "x": 5
            },
            "concepts": [
              "variable-declaration"
            ]
          },
          {
            "line": 5,
            "action": "declare",
            "description": "`ptr` points to x",
            "state": {
              "ptr": "&x"
            },
            "concepts": [
              "pointer"
            ]
          },
          {
            "line": 6,
            "action": "call",
            "description": "Call f(ptr): pass COPY of pointer",
            "concepts": [
              "pass-by-value"
            ]
          },
          {
            "line": 2,
            "action": "assign",
            "description": "Local copy p changed, original ptr unchanged",
            "state": {
              "p": "&local"
            },
            "concepts": [
              "local-variable"
            ]
          },
          {
            "line": 7,
            "action": "output",
            "description": "Output *ptr = 5 (ptr unchanged)",
            "output": "5"
          }
        ],
        "finalOutput": "5",
        "keyInsight": "Pointers are passed by value; reassigning p inside f() doesn't affect ptr in main"
      }
    },
    {
      "id": "ptr-018",
      "categoryId": "pointers",
      "concept": "Local pointer copy",
      "code": "void f(int* p) {\n    p = nullptr;  // Doesn't affect original\n}\nint main() {\n    int x = 10;\n    int* ptr = &x;\n    f(ptr);\n    cout << *ptr;\n}",
      "output": "10",
      "tags": [
        "pointers",
        "memory",
        "copy-semantics"
      ],
      "explanation": {
        "steps": [
          {
            "line": 4,
            "action": "declare",
            "description": "Declare `x` = 10",
            "state": {
              "x": 10
            },
            "concepts": [
              "variable-declaration"
            ]
          },
          {
            "line": 5,
            "action": "declare",
            "description": "`ptr` points to x",
            "state": {
              "ptr": "&x"
            },
            "concepts": [
              "pointer"
            ]
          },
          {
            "line": 6,
            "action": "call",
            "description": "Call f(ptr): p is copy of ptr",
            "concepts": [
              "pass-by-value"
            ]
          },
          {
            "line": 2,
            "action": "assign",
            "description": "Set local copy p = nullptr",
            "state": {
              "p": "nullptr"
            },
            "concepts": [
              "local-variable"
            ]
          },
          {
            "line": 7,
            "action": "output",
            "description": "Output *ptr = 10 (ptr still points to x)",
            "output": "10"
          }
        ],
        "finalOutput": "10",
        "keyInsight": "Setting `p = nullptr` inside function only affects local copy, not original ptr"
      }
    },
    {
      "id": "ptr-019",
      "categoryId": "pointers",
      "concept": "Pointer reassignment in function scope",
      "code": "void change(int* p) {\n    *p = 100;  // This DOES change original\n}\nint main() {\n    int x = 1;\n    change(&x);\n    cout << x;\n}",
      "output": "100",
      "tags": [
        "pointers",
        "memory"
      ],
      "explanation": {
        "steps": [
          {
            "line": 4,
            "action": "declare",
            "description": "Declare `x` = 1",
            "state": {
              "x": 1
            },
            "concepts": [
              "variable-declaration"
            ]
          },
          {
            "line": 5,
            "action": "call",
            "description": "Call change(&x)",
            "concepts": [
              "pass-pointer"
            ]
          },
          {
            "line": 2,
            "action": "assign",
            "description": "`*p = 100`: modify value through pointer",
            "state": {
              "x": 100
            },
            "concepts": [
              "dereference"
            ]
          },
          {
            "line": 6,
            "action": "output",
            "description": "Output x = 100",
            "output": "100"
          }
        ],
        "finalOutput": "100",
        "keyInsight": "Dereferencing and assigning (`*p = value`) DOES modify the original variable"
      }
    },
    {
      "id": "ptr-020",
      "categoryId": "pointers",
      "concept": "Passing address `&x`",
      "code": "void set(int* p) { *p = 42; }\nint main() {\n    int n = 0;\n    set(&n);\n    cout << n;\n}",
      "output": "42",
      "tags": [
        "pointers",
        "memory"
      ],
      "explanation": {
        "steps": [
          {
            "line": 3,
            "action": "declare",
            "description": "Declare `n` = 0",
            "state": {
              "n": 0
            },
            "concepts": [
              "variable-declaration"
            ]
          },
          {
            "line": 4,
            "action": "call",
            "description": "Call set(&n)",
            "concepts": [
              "pass-pointer"
            ]
          },
          {
            "line": 1,
            "action": "assign",
            "description": "`*p = 42`: modify n through pointer",
            "state": {
              "n": 42
            },
            "concepts": [
              "dereference"
            ]
          },
          {
            "line": 5,
            "action": "output",
            "description": "Output n = 42",
            "output": "42"
          }
        ],
        "finalOutput": "42",
        "keyInsight": "Passing `&x` allows function to modify x through the pointer"
      }
    },
    {
      "id": "ptr-021",
      "categoryId": "pointers",
      "concept": "Dereferencing to swap values",
      "code": "void swap(int* a, int* b) {\n    int t = *a; *a = *b; *b = t;\n}\nint main() {\n    int x = 1, y = 2;\n    swap(&x, &y);\n    cout << x << y;\n}",
      "output": "21",
      "tags": [
        "pointers",
        "memory"
      ],
      "explanation": {
        "steps": [
          {
            "line": 4,
            "action": "declare",
            "description": "Declare x=1, y=2",
            "state": {
              "x": 1,
              "y": 2
            },
            "concepts": [
              "variable-declaration"
            ]
          },
          {
            "line": 5,
            "action": "call",
            "description": "Call swap(&x, &y)",
            "concepts": [
              "pass-pointer"
            ]
          },
          {
            "line": 2,
            "action": "declare",
            "description": "t = *a = 1",
            "state": {
              "t": 1
            }
          },
          {
            "line": 2,
            "action": "assign",
            "description": "*a = *b: x = 2",
            "state": {
              "x": 2
            }
          },
          {
            "line": 2,
            "action": "assign",
            "description": "*b = t: y = 1",
            "state": {
              "y": 1
            }
          },
          {
            "line": 6,
            "action": "output",
            "description": "Output x=2, y=1",
            "output": "21"
          }
        ],
        "finalOutput": "21",
        "keyInsight": "Classic swap using pointers: dereference to access and exchange values"
      }
    },
    {
      "id": "ptr-022",
      "categoryId": "pointers",
      "concept": "Modifying original through pointer",
      "code": "void triple(int* p) { *p *= 3; }\nint main() {\n    int x = 4;\n    triple(&x);\n    cout << x;\n}",
      "output": "12",
      "tags": [
        "pointers",
        "memory",
        "conditionals"
      ],
      "explanation": {
        "steps": [
          {
            "line": 3,
            "action": "declare",
            "description": "Declare `x` = 4",
            "state": {
              "x": 4
            },
            "concepts": [
              "variable-declaration"
            ]
          },
          {
            "line": 4,
            "action": "call",
            "description": "Call triple(&x)",
            "concepts": [
              "pass-pointer"
            ]
          },
          {
            "line": 1,
            "action": "assign",
            "description": "`*p *= 3`: x = 4 * 3 = 12",
            "state": {
              "x": 12
            },
            "concepts": [
              "dereference",
              "compound-assignment"
            ]
          },
          {
            "line": 5,
            "action": "output",
            "description": "Output x = 12",
            "output": "12"
          }
        ],
        "finalOutput": "12",
        "keyInsight": "Modifying through pointer with compound assignment: `*p *= 3` multiplies original by 3"
      }
    },
    {
      "id": "ptr-023",
      "categoryId": "pointers",
      "concept": "Array decay to pointer",
      "code": "void f(int* p) { cout << *p; }\nint main() {\n    int arr[] = {7, 8, 9};\n    f(arr);  // Array decays to pointer\n}",
      "output": "7",
      "tags": [
        "pointers",
        "memory",
        "arrays"
      ],
      "explanation": {
        "steps": [
          {
            "line": 3,
            "action": "declare",
            "description": "Declare arr = {7, 8, 9}",
            "state": {
              "arr": [
                7,
                8,
                9
              ]
            },
            "concepts": [
              "array-declaration"
            ]
          },
          {
            "line": 4,
            "action": "call",
            "description": "Call f(arr): array decays to pointer",
            "concepts": [
              "array-decay"
            ]
          },
          {
            "line": 1,
            "action": "dereference",
            "description": "*p = arr[0] = 7",
            "concepts": [
              "dereference"
            ]
          },
          {
            "line": 1,
            "action": "output",
            "description": "Output 7",
            "output": "7"
          }
        ],
        "finalOutput": "7",
        "keyInsight": "When passed to functions, arrays 'decay' to pointers to their first element"
      }
    },
    {
      "id": "ptr-024",
      "categoryId": "pointers",
      "concept": "`*arr` vs `arr[0]`",
      "code": "int main() {\n    int arr[] = {5, 6, 7};\n    cout << (*arr == arr[0]);\n}",
      "output": "1",
      "tags": [
        "pointers",
        "memory"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "declare",
            "description": "Declare arr = {5, 6, 7}",
            "state": {
              "arr": [
                5,
                6,
                7
              ]
            },
            "concepts": [
              "array-declaration"
            ]
          },
          {
            "line": 3,
            "action": "evaluate",
            "description": "Compare *arr with arr[0]",
            "concepts": [
              "array-decay",
              "dereference"
            ]
          },
          {
            "line": 3,
            "action": "evaluate",
            "description": "*arr = 5, arr[0] = 5: equal!",
            "concepts": [
              "equivalence"
            ]
          },
          {
            "line": 3,
            "action": "output",
            "description": "Output 1 (true)",
            "output": "1"
          }
        ],
        "finalOutput": "1",
        "keyInsight": "`*arr` and `arr[0]` are identical - both access the first element"
      }
    },
    {
      "id": "ptr-025",
      "categoryId": "pointers",
      "concept": "Commutative property `a[b]` = `*(a+b)` = `b[a]`",
      "code": "int main() {\n    int arr[] = {10, 20, 30};\n    cout << 1[arr];  // Same as arr[1]\n}",
      "output": "20",
      "tags": [
        "pointers",
        "memory"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "declare",
            "description": "Declare arr = {10, 20, 30}",
            "state": {
              "arr": [
                10,
                20,
                30
              ]
            },
            "concepts": [
              "array-declaration"
            ]
          },
          {
            "line": 3,
            "action": "evaluate",
            "description": "`1[arr]` = `*(1 + arr)` = `*(arr + 1)` = `arr[1]`",
            "concepts": [
              "subscript-commutativity"
            ]
          },
          {
            "line": 3,
            "action": "output",
            "description": "Output 20",
            "output": "20"
          }
        ],
        "finalOutput": "20",
        "keyInsight": "Subscript is commutative: `a[b]` = `*(a+b)` = `*(b+a)` = `b[a]`"
      }
    },
    {
      "id": "ptr-026",
      "categoryId": "pointers",
      "concept": "`nullptr`",
      "code": "int main() {\n    int* p = nullptr;\n    cout << (p == nullptr);\n}",
      "output": "1",
      "tags": [
        "pointers",
        "memory"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "declare",
            "description": "Declare pointer `p` = nullptr",
            "state": {
              "p": "nullptr"
            },
            "concepts": [
              "nullptr"
            ]
          },
          {
            "line": 3,
            "action": "evaluate",
            "description": "Compare p == nullptr",
            "concepts": [
              "null-comparison"
            ]
          },
          {
            "line": 3,
            "action": "output",
            "description": "Output 1 (true)",
            "output": "1"
          }
        ],
        "finalOutput": "1",
        "keyInsight": "`nullptr` is the preferred null pointer constant in modern C++"
      }
    },
    {
      "id": "ptr-027",
      "categoryId": "pointers",
      "concept": "`0` as null pointer",
      "code": "int main() {\n    int* p = 0;\n    cout << (p == nullptr);\n}",
      "output": "1",
      "tags": [
        "pointers",
        "memory"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "declare",
            "description": "Declare pointer `p` = 0",
            "state": {
              "p": "null"
            },
            "concepts": [
              "null-pointer"
            ]
          },
          {
            "line": 3,
            "action": "evaluate",
            "description": "Compare p == nullptr: 0 equals nullptr",
            "concepts": [
              "null-comparison"
            ]
          },
          {
            "line": 3,
            "action": "output",
            "description": "Output 1 (true)",
            "output": "1"
          }
        ],
        "finalOutput": "1",
        "keyInsight": "Integer 0 can be used as null pointer (but nullptr is preferred)"
      }
    },
    {
      "id": "ptr-028",
      "categoryId": "pointers",
      "concept": "Pointer in boolean context",
      "code": "int main() {\n    int x = 5;\n    int* p1 = &x;\n    int* p2 = nullptr;\n    cout << (p1 ? 1 : 0) << (p2 ? 1 : 0);\n}",
      "output": "10",
      "tags": [
        "pointers",
        "memory"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "declare",
            "description": "Declare `x` = 5",
            "state": {
              "x": 5
            },
            "concepts": [
              "variable-declaration"
            ]
          },
          {
            "line": 3,
            "action": "declare",
            "description": "`p1` points to x (non-null)",
            "state": {
              "p1": "&x"
            },
            "concepts": [
              "pointer"
            ]
          },
          {
            "line": 4,
            "action": "declare",
            "description": "`p2` = nullptr (null)",
            "state": {
              "p2": "nullptr"
            },
            "concepts": [
              "nullptr"
            ]
          },
          {
            "line": 5,
            "action": "evaluate",
            "description": "`p1 ? 1 : 0`: p1 is truthy (non-null)",
            "concepts": [
              "pointer-boolean"
            ]
          },
          {
            "line": 5,
            "action": "output",
            "description": "Output 1",
            "output": "1"
          },
          {
            "line": 5,
            "action": "evaluate",
            "description": "`p2 ? 1 : 0`: p2 is falsy (null)",
            "concepts": [
              "pointer-boolean"
            ]
          },
          {
            "line": 5,
            "action": "output",
            "description": "Output 0",
            "output": "0"
          }
        ],
        "finalOutput": "10",
        "keyInsight": "In boolean context: non-null pointers are truthy, null pointers are falsy"
      }
    },
    {
      "id": "ptr-029",
      "categoryId": "pointers",
      "concept": "Null check pattern",
      "code": "void f(int* p) {\n    if (p) cout << *p;\n    else cout << \"null\";\n}\nint main() {\n    f(nullptr);\n}",
      "output": "null",
      "tags": [
        "pointers",
        "memory"
      ],
      "explanation": {
        "steps": [
          {
            "line": 5,
            "action": "call",
            "description": "Call f(nullptr)",
            "concepts": [
              "null-pointer"
            ]
          },
          {
            "line": 2,
            "action": "branch",
            "description": "Check `if (p)`: nullptr is falsy",
            "concepts": [
              "null-check"
            ]
          },
          {
            "line": 3,
            "action": "branch",
            "description": "Condition false, go to else"
          },
          {
            "line": 4,
            "action": "output",
            "description": "Output \"null\"",
            "output": "null"
          }
        ],
        "finalOutput": "null",
        "keyInsight": "Common pattern: `if (p)` checks for non-null before dereferencing"
      }
    },
    {
      "id": "ptr-030",
      "categoryId": "pointers",
      "concept": "Null pointer comparison",
      "code": "int main() {\n    int* p = nullptr;\n    if (!p) cout << \"null\";\n}",
      "output": "null",
      "tags": [
        "pointers",
        "memory"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "declare",
            "description": "Declare `p` = nullptr",
            "state": {
              "p": "nullptr"
            },
            "concepts": [
              "nullptr"
            ]
          },
          {
            "line": 3,
            "action": "branch",
            "description": "Check `!p`: !nullptr = true",
            "concepts": [
              "null-check",
              "logical-not"
            ]
          },
          {
            "line": 3,
            "action": "output",
            "description": "Output \"null\"",
            "output": "null"
          }
        ],
        "finalOutput": "null",
        "keyInsight": "`!p` is true when p is null; equivalent to `p == nullptr`"
      }
    },
    {
      "id": "arr-001",
      "categoryId": "arrays-iteration",
      "concept": "Array partial initialization",
      "code": "int main() {\n    int arr[5] = {1, 2};\n    cout << arr[0] << arr[1] << arr[2];\n}",
      "output": "120",
      "tags": [
        "arrays",
        "loops"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "declare",
            "description": "Declare array `arr` of 5 ints, initialize first two elements to 1 and 2",
            "state": {
              "arr": [
                1,
                2,
                0,
                0,
                0
              ]
            },
            "concepts": [
              "array-initialization",
              "partial-initialization"
            ]
          },
          {
            "line": 2,
            "action": "initialize",
            "description": "Remaining elements (indices 2-4) are zero-initialized",
            "concepts": [
              "zero-initialization"
            ]
          },
          {
            "line": 3,
            "action": "evaluate",
            "description": "Access `arr[0]` = 1",
            "concepts": [
              "array-access"
            ]
          },
          {
            "line": 3,
            "action": "output",
            "description": "Output 1",
            "output": "1"
          },
          {
            "line": 3,
            "action": "evaluate",
            "description": "Access `arr[1]` = 2",
            "concepts": [
              "array-access"
            ]
          },
          {
            "line": 3,
            "action": "output",
            "description": "Output 2",
            "output": "2"
          },
          {
            "line": 3,
            "action": "evaluate",
            "description": "Access `arr[2]` = 0 (zero-initialized)",
            "concepts": [
              "zero-initialization"
            ]
          },
          {
            "line": 3,
            "action": "output",
            "description": "Output 0",
            "output": "0"
          }
        ],
        "finalOutput": "120",
        "keyInsight": "When an array is partially initialized, remaining elements are automatically zero-initialized"
      }
    },
    {
      "id": "arr-002",
      "categoryId": "arrays-iteration",
      "concept": "Zero-initialization of remaining elements",
      "code": "int main() {\n    int arr[4] = {7};\n    cout << arr[0] << arr[1] << arr[2] << arr[3];\n}",
      "output": "7000",
      "tags": [
        "arrays",
        "loops"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "declare",
            "description": "Declare array `arr` of 4 ints, initialize first element to 7",
            "state": {
              "arr": [
                7,
                0,
                0,
                0
              ]
            },
            "concepts": [
              "array-initialization"
            ]
          },
          {
            "line": 2,
            "action": "initialize",
            "description": "Remaining elements (indices 1-3) are zero-initialized",
            "concepts": [
              "zero-initialization"
            ]
          },
          {
            "line": 3,
            "action": "output",
            "description": "Output arr[0]=7, arr[1]=0, arr[2]=0, arr[3]=0",
            "output": "7000"
          }
        ],
        "finalOutput": "7000",
        "keyInsight": "Providing even one initializer triggers zero-initialization for all remaining elements"
      }
    },
    {
      "id": "arr-003",
      "categoryId": "arrays-iteration",
      "concept": "Array size",
      "code": "int main() {\n    int arr[5] = {1, 2, 3, 4, 5};\n    cout << sizeof(arr) / sizeof(arr[0]);\n}",
      "output": "5",
      "tags": [
        "arrays",
        "loops"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "declare",
            "description": "Declare array `arr` of 5 ints",
            "state": {
              "arr": [
                1,
                2,
                3,
                4,
                5
              ]
            },
            "concepts": [
              "array-initialization"
            ]
          },
          {
            "line": 3,
            "action": "evaluate",
            "description": "Evaluate `sizeof(arr)` = 20 bytes (5 ints \u00d7 4 bytes each)",
            "concepts": [
              "sizeof-operator"
            ]
          },
          {
            "line": 3,
            "action": "evaluate",
            "description": "Evaluate `sizeof(arr[0])` = 4 bytes (size of one int)",
            "concepts": [
              "sizeof-operator"
            ]
          },
          {
            "line": 3,
            "action": "evaluate",
            "description": "Divide: 20 / 4 = 5",
            "concepts": [
              "array-size-idiom"
            ]
          },
          {
            "line": 3,
            "action": "output",
            "description": "Output 5",
            "output": "5"
          }
        ],
        "finalOutput": "5",
        "keyInsight": "The idiom `sizeof(arr)/sizeof(arr[0])` computes array length at compile time"
      }
    },
    {
      "id": "arr-004",
      "categoryId": "arrays-iteration",
      "concept": "Range-based for syntax",
      "code": "int main() {\n    int arr[] = {1, 2, 3};\n    for (int x : arr) cout << x;\n}",
      "output": "123",
      "tags": [
        "arrays",
        "loops",
        "for-loop"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "declare",
            "description": "Declare array `arr` with elements {1, 2, 3}",
            "state": {
              "arr": [
                1,
                2,
                3
              ]
            },
            "concepts": [
              "array-initialization"
            ]
          },
          {
            "line": 3,
            "action": "loop-start",
            "description": "Begin range-based for loop, copy first element to `x`",
            "state": {
              "x": 1
            },
            "concepts": [
              "range-for"
            ]
          },
          {
            "line": 3,
            "action": "output",
            "description": "Output 1",
            "output": "1"
          },
          {
            "line": 3,
            "action": "loop-start",
            "description": "Copy second element to `x`",
            "state": {
              "x": 2
            }
          },
          {
            "line": 3,
            "action": "output",
            "description": "Output 2",
            "output": "2"
          },
          {
            "line": 3,
            "action": "loop-start",
            "description": "Copy third element to `x`",
            "state": {
              "x": 3
            }
          },
          {
            "line": 3,
            "action": "output",
            "description": "Output 3",
            "output": "3"
          }
        ],
        "finalOutput": "123",
        "keyInsight": "Range-based for `for(T x : arr)` iterates through each element, copying it to x"
      }
    },
    {
      "id": "arr-005",
      "categoryId": "arrays-iteration",
      "concept": "`for (T x : container)` - loop variable copy",
      "code": "int main() {\n    int arr[] = {1, 2, 3};\n    for (int x : arr) x = 9;  // Modifies copy\n    for (int x : arr) cout << x;\n}",
      "output": "123",
      "tags": [
        "arrays",
        "loops",
        "for-loop",
        "copy-semantics"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "declare",
            "description": "Declare array `arr` with elements {1, 2, 3}",
            "state": {
              "arr": [
                1,
                2,
                3
              ]
            },
            "concepts": [
              "array-initialization"
            ]
          },
          {
            "line": 3,
            "action": "loop-start",
            "description": "First iteration: copy arr[0] to local variable `x`",
            "state": {
              "x": 1
            },
            "concepts": [
              "range-for",
              "pass-by-value"
            ]
          },
          {
            "line": 3,
            "action": "assign",
            "description": "Assign 9 to `x` (local copy only, arr unchanged)",
            "state": {
              "x": 9,
              "arr": [
                1,
                2,
                3
              ]
            },
            "concepts": [
              "pass-by-value"
            ]
          },
          {
            "line": 3,
            "action": "loop-start",
            "description": "Second iteration: copy arr[1] to `x`",
            "state": {
              "x": 2
            }
          },
          {
            "line": 3,
            "action": "assign",
            "description": "Assign 9 to `x` (local copy only)",
            "state": {
              "x": 9
            }
          },
          {
            "line": 3,
            "action": "loop-start",
            "description": "Third iteration: copy arr[2] to `x`",
            "state": {
              "x": 3
            }
          },
          {
            "line": 3,
            "action": "assign",
            "description": "Assign 9 to `x` (local copy only)",
            "state": {
              "x": 9
            }
          },
          {
            "line": 4,
            "action": "loop-start",
            "description": "Second loop: output each element of unchanged array"
          },
          {
            "line": 4,
            "action": "output",
            "description": "Output 1, 2, 3",
            "output": "123"
          }
        ],
        "finalOutput": "123",
        "keyInsight": "When loop variable is by value (`int x`), modifications affect only the copy, not the original array"
      }
    },
    {
      "id": "arr-006",
      "categoryId": "arrays-iteration",
      "concept": "Original unchanged with copy",
      "code": "#include <vector>\nint main() {\n    vector<int> v = {5, 6};\n    for (int n : v) n = 0;\n    cout << v[0] << v[1];\n}",
      "output": "56",
      "tags": [
        "arrays",
        "loops",
        "copy-semantics"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "declare",
            "description": "Declare vector `v` with elements {5, 6}",
            "state": {
              "v": [
                5,
                6
              ]
            },
            "concepts": [
              "vector-initialization"
            ]
          },
          {
            "line": 3,
            "action": "loop-start",
            "description": "For each element, copy to `n` and set to 0",
            "concepts": [
              "range-for",
              "pass-by-value"
            ]
          },
          {
            "line": 3,
            "action": "assign",
            "description": "n=0 only modifies local copy, vector unchanged",
            "state": {
              "v": [
                5,
                6
              ]
            },
            "concepts": [
              "pass-by-value"
            ]
          },
          {
            "line": 4,
            "action": "output",
            "description": "Output v[0]=5 and v[1]=6",
            "output": "56"
          }
        ],
        "finalOutput": "56",
        "keyInsight": "Pass-by-value in range-for creates copies; original container remains unchanged"
      }
    },
    {
      "id": "arr-007",
      "categoryId": "arrays-iteration",
      "concept": "`for (T& x : container)` - reference",
      "code": "int main() {\n    int arr[] = {1, 2, 3};\n    for (int& x : arr) x *= 2;\n    for (int x : arr) cout << x;\n}",
      "output": "246",
      "tags": [
        "arrays",
        "loops",
        "for-loop",
        "references"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "declare",
            "description": "Declare array `arr` with elements {1, 2, 3}",
            "state": {
              "arr": [
                1,
                2,
                3
              ]
            },
            "concepts": [
              "array-initialization"
            ]
          },
          {
            "line": 3,
            "action": "loop-start",
            "description": "First iteration: `x` is a reference to arr[0]",
            "state": {
              "x": "ref->arr[0]"
            },
            "concepts": [
              "range-for-reference"
            ]
          },
          {
            "line": 3,
            "action": "assign",
            "description": "Multiply arr[0] by 2 through reference",
            "state": {
              "arr": [
                2,
                2,
                3
              ]
            },
            "concepts": [
              "reference-modification"
            ]
          },
          {
            "line": 3,
            "action": "loop-start",
            "description": "Second iteration: `x` refers to arr[1]"
          },
          {
            "line": 3,
            "action": "assign",
            "description": "Multiply arr[1] by 2",
            "state": {
              "arr": [
                2,
                4,
                3
              ]
            }
          },
          {
            "line": 3,
            "action": "loop-start",
            "description": "Third iteration: `x` refers to arr[2]"
          },
          {
            "line": 3,
            "action": "assign",
            "description": "Multiply arr[2] by 2",
            "state": {
              "arr": [
                2,
                4,
                6
              ]
            }
          },
          {
            "line": 4,
            "action": "output",
            "description": "Output modified array: 2, 4, 6",
            "output": "246"
          }
        ],
        "finalOutput": "246",
        "keyInsight": "Using `int& x` makes x a reference to each element, allowing modification of the original array"
      }
    },
    {
      "id": "arr-008",
      "categoryId": "arrays-iteration",
      "concept": "Modifying original with reference",
      "code": "#include <vector>\nint main() {\n    vector<int> v = {1, 2};\n    for (int& n : v) n = 9;\n    cout << v[0] << v[1];\n}",
      "output": "99",
      "tags": [
        "arrays",
        "loops",
        "conditionals",
        "references"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "declare",
            "description": "Declare vector `v` with elements {1, 2}",
            "state": {
              "v": [
                1,
                2
              ]
            },
            "concepts": [
              "vector-initialization"
            ]
          },
          {
            "line": 3,
            "action": "loop-start",
            "description": "`n` is a reference to v[0]",
            "concepts": [
              "range-for-reference"
            ]
          },
          {
            "line": 3,
            "action": "assign",
            "description": "Set v[0] = 9 through reference",
            "state": {
              "v": [
                9,
                2
              ]
            }
          },
          {
            "line": 3,
            "action": "loop-start",
            "description": "`n` is a reference to v[1]"
          },
          {
            "line": 3,
            "action": "assign",
            "description": "Set v[1] = 9 through reference",
            "state": {
              "v": [
                9,
                9
              ]
            }
          },
          {
            "line": 4,
            "action": "output",
            "description": "Output v[0]=9 and v[1]=9",
            "output": "99"
          }
        ],
        "finalOutput": "99",
        "keyInsight": "Reference loop variable (`int& n`) allows direct modification of container elements"
      }
    },
    {
      "id": "arr-009",
      "categoryId": "arrays-iteration",
      "concept": "`const T&` for read-only",
      "code": "#include <vector>\nint main() {\n    vector<int> v = {3, 4, 5};\n    for (const int& n : v) cout << n;\n}",
      "output": "345",
      "tags": [
        "arrays",
        "loops",
        "for-loop",
        "const"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "declare",
            "description": "Declare vector `v` with elements {3, 4, 5}",
            "state": {
              "v": [
                3,
                4,
                5
              ]
            },
            "concepts": [
              "vector-initialization"
            ]
          },
          {
            "line": 3,
            "action": "loop-start",
            "description": "`n` is a const reference to v[0]",
            "concepts": [
              "const-reference",
              "range-for"
            ]
          },
          {
            "line": 3,
            "action": "output",
            "description": "Output 3",
            "output": "3"
          },
          {
            "line": 3,
            "action": "loop-start",
            "description": "`n` is a const reference to v[1]"
          },
          {
            "line": 3,
            "action": "output",
            "description": "Output 4",
            "output": "4"
          },
          {
            "line": 3,
            "action": "loop-start",
            "description": "`n` is a const reference to v[2]"
          },
          {
            "line": 3,
            "action": "output",
            "description": "Output 5",
            "output": "5"
          }
        ],
        "finalOutput": "345",
        "keyInsight": "`const T&` provides read-only access by reference, preventing accidental modification"
      }
    },
    {
      "id": "arr-010",
      "categoryId": "arrays-iteration",
      "concept": "Efficient iteration (no copying)",
      "code": "#include <vector>\n#include <string>\nint main() {\n    vector<string> v = {\"a\", \"b\"};\n    for (const string& s : v) cout << s;\n}",
      "output": "ab",
      "tags": [
        "arrays",
        "loops",
        "copy-semantics"
      ],
      "explanation": {
        "steps": [
          {
            "line": 3,
            "action": "declare",
            "description": "Declare vector of strings with {\"a\", \"b\"}",
            "state": {
              "v": [
                "a",
                "b"
              ]
            },
            "concepts": [
              "vector-initialization"
            ]
          },
          {
            "line": 4,
            "action": "loop-start",
            "description": "`s` is a const reference to v[0] (no copy made)",
            "concepts": [
              "const-reference",
              "efficiency"
            ]
          },
          {
            "line": 4,
            "action": "output",
            "description": "Output \"a\"",
            "output": "a"
          },
          {
            "line": 4,
            "action": "loop-start",
            "description": "`s` is a const reference to v[1] (no copy made)"
          },
          {
            "line": 4,
            "action": "output",
            "description": "Output \"b\"",
            "output": "b"
          }
        ],
        "finalOutput": "ab",
        "keyInsight": "Using `const T&` avoids expensive copies of large objects while ensuring read-only access"
      }
    },
    {
      "id": "arr-011",
      "categoryId": "arrays-iteration",
      "concept": "Nested `for` loops",
      "code": "int main() {\n    for (int i = 0; i < 2; i++)\n        for (int j = 0; j < 2; j++)\n            cout << i << j << \" \";\n}",
      "output": "00 01 10 11",
      "tags": [
        "arrays",
        "loops",
        "for-loop"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "loop-start",
            "description": "Outer loop: i=0",
            "state": {
              "i": 0
            },
            "concepts": [
              "nested-loops"
            ]
          },
          {
            "line": 3,
            "action": "loop-start",
            "description": "Inner loop: j=0",
            "state": {
              "j": 0
            }
          },
          {
            "line": 4,
            "action": "output",
            "description": "Output \"00 \"",
            "output": "00 "
          },
          {
            "line": 3,
            "action": "loop-start",
            "description": "Inner loop: j=1",
            "state": {
              "j": 1
            }
          },
          {
            "line": 4,
            "action": "output",
            "description": "Output \"01 \"",
            "output": "01 "
          },
          {
            "line": 2,
            "action": "loop-start",
            "description": "Outer loop: i=1",
            "state": {
              "i": 1
            }
          },
          {
            "line": 3,
            "action": "loop-start",
            "description": "Inner loop: j=0",
            "state": {
              "j": 0
            }
          },
          {
            "line": 4,
            "action": "output",
            "description": "Output \"10 \"",
            "output": "10 "
          },
          {
            "line": 3,
            "action": "loop-start",
            "description": "Inner loop: j=1",
            "state": {
              "j": 1
            }
          },
          {
            "line": 4,
            "action": "output",
            "description": "Output \"11 \"",
            "output": "11 "
          }
        ],
        "finalOutput": "00 01 10 11 ",
        "keyInsight": "Inner loop completes all iterations for each single iteration of outer loop"
      }
    },
    {
      "id": "arr-012",
      "categoryId": "arrays-iteration",
      "concept": "`break` exits innermost loop only",
      "code": "int main() {\n    for (int i = 0; i < 2; i++) {\n        for (int j = 0; j < 3; j++) {\n            if (j == 1) break;\n            cout << j;\n        }\n    }\n}",
      "output": "00",
      "tags": [
        "arrays",
        "loops"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "loop-start",
            "description": "Outer loop: i=0",
            "state": {
              "i": 0
            },
            "concepts": [
              "nested-loops"
            ]
          },
          {
            "line": 3,
            "action": "loop-start",
            "description": "Inner loop: j=0",
            "state": {
              "j": 0
            }
          },
          {
            "line": 4,
            "action": "branch",
            "description": "Check j==1: false, continue",
            "concepts": [
              "conditionals"
            ]
          },
          {
            "line": 5,
            "action": "output",
            "description": "Output 0",
            "output": "0"
          },
          {
            "line": 3,
            "action": "loop-start",
            "description": "Inner loop: j=1",
            "state": {
              "j": 1
            }
          },
          {
            "line": 4,
            "action": "branch",
            "description": "Check j==1: true, break inner loop",
            "concepts": [
              "break"
            ]
          },
          {
            "line": 2,
            "action": "loop-start",
            "description": "Outer loop: i=1",
            "state": {
              "i": 1
            }
          },
          {
            "line": 3,
            "action": "loop-start",
            "description": "Inner loop: j=0",
            "state": {
              "j": 0
            }
          },
          {
            "line": 4,
            "action": "branch",
            "description": "Check j==1: false, continue"
          },
          {
            "line": 5,
            "action": "output",
            "description": "Output 0",
            "output": "0"
          },
          {
            "line": 3,
            "action": "loop-start",
            "description": "Inner loop: j=1",
            "state": {
              "j": 1
            }
          },
          {
            "line": 4,
            "action": "branch",
            "description": "Check j==1: true, break inner loop"
          }
        ],
        "finalOutput": "00",
        "keyInsight": "`break` only exits the innermost loop; outer loop continues executing"
      }
    },
    {
      "id": "arr-013",
      "categoryId": "arrays-iteration",
      "concept": "`continue` (skip iteration)",
      "code": "int main() {\n    for (int i = 0; i < 5; i++) {\n        if (i == 2) continue;\n        cout << i;\n    }\n}",
      "output": "0134",
      "tags": [
        "arrays",
        "loops"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "loop-start",
            "description": "i=0",
            "state": {
              "i": 0
            },
            "concepts": [
              "for-loop"
            ]
          },
          {
            "line": 3,
            "action": "branch",
            "description": "Check i==2: false",
            "concepts": [
              "conditionals"
            ]
          },
          {
            "line": 4,
            "action": "output",
            "description": "Output 0",
            "output": "0"
          },
          {
            "line": 2,
            "action": "loop-start",
            "description": "i=1",
            "state": {
              "i": 1
            }
          },
          {
            "line": 3,
            "action": "branch",
            "description": "Check i==2: false"
          },
          {
            "line": 4,
            "action": "output",
            "description": "Output 1",
            "output": "1"
          },
          {
            "line": 2,
            "action": "loop-start",
            "description": "i=2",
            "state": {
              "i": 2
            }
          },
          {
            "line": 3,
            "action": "branch",
            "description": "Check i==2: true, execute continue",
            "concepts": [
              "continue"
            ]
          },
          {
            "line": 2,
            "action": "loop-start",
            "description": "i=3 (skipped output for i=2)",
            "state": {
              "i": 3
            }
          },
          {
            "line": 3,
            "action": "branch",
            "description": "Check i==2: false"
          },
          {
            "line": 4,
            "action": "output",
            "description": "Output 3",
            "output": "3"
          },
          {
            "line": 2,
            "action": "loop-start",
            "description": "i=4",
            "state": {
              "i": 4
            }
          },
          {
            "line": 3,
            "action": "branch",
            "description": "Check i==2: false"
          },
          {
            "line": 4,
            "action": "output",
            "description": "Output 4",
            "output": "4"
          }
        ],
        "finalOutput": "0134",
        "keyInsight": "`continue` skips the rest of current iteration and proceeds to next iteration"
      }
    },
    {
      "id": "arr-014",
      "categoryId": "arrays-iteration",
      "concept": "`break` (exit loop)",
      "code": "int main() {\n    for (int i = 0; i < 5; i++) {\n        if (i == 3) break;\n        cout << i;\n    }\n}",
      "output": "012",
      "tags": [
        "arrays",
        "loops"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "loop-start",
            "description": "i=0",
            "state": {
              "i": 0
            },
            "concepts": [
              "for-loop"
            ]
          },
          {
            "line": 3,
            "action": "branch",
            "description": "Check i==3: false",
            "concepts": [
              "conditionals"
            ]
          },
          {
            "line": 4,
            "action": "output",
            "description": "Output 0",
            "output": "0"
          },
          {
            "line": 2,
            "action": "loop-start",
            "description": "i=1",
            "state": {
              "i": 1
            }
          },
          {
            "line": 3,
            "action": "branch",
            "description": "Check i==3: false"
          },
          {
            "line": 4,
            "action": "output",
            "description": "Output 1",
            "output": "1"
          },
          {
            "line": 2,
            "action": "loop-start",
            "description": "i=2",
            "state": {
              "i": 2
            }
          },
          {
            "line": 3,
            "action": "branch",
            "description": "Check i==3: false"
          },
          {
            "line": 4,
            "action": "output",
            "description": "Output 2",
            "output": "2"
          },
          {
            "line": 2,
            "action": "loop-start",
            "description": "i=3",
            "state": {
              "i": 3
            }
          },
          {
            "line": 3,
            "action": "branch",
            "description": "Check i==3: true, execute break",
            "concepts": [
              "break"
            ]
          },
          {
            "line": null,
            "action": "loop-end",
            "description": "Loop terminates immediately"
          }
        ],
        "finalOutput": "012",
        "keyInsight": "`break` immediately exits the entire loop, skipping remaining iterations"
      }
    },
    {
      "id": "arr-015",
      "categoryId": "arrays-iteration",
      "concept": "Loop control flow",
      "code": "int main() {\n    for (int i = 0; i < 4; i++) {\n        if (i == 1) continue;\n        if (i == 3) break;\n        cout << i;\n    }\n    cout << \"X\";\n}",
      "output": "02X",
      "tags": [
        "arrays",
        "loops"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "loop-start",
            "description": "i=0",
            "state": {
              "i": 0
            },
            "concepts": [
              "for-loop"
            ]
          },
          {
            "line": 3,
            "action": "branch",
            "description": "Check i==1: false"
          },
          {
            "line": 4,
            "action": "branch",
            "description": "Check i==3: false"
          },
          {
            "line": 5,
            "action": "output",
            "description": "Output 0",
            "output": "0"
          },
          {
            "line": 2,
            "action": "loop-start",
            "description": "i=1",
            "state": {
              "i": 1
            }
          },
          {
            "line": 3,
            "action": "branch",
            "description": "Check i==1: true, continue",
            "concepts": [
              "continue"
            ]
          },
          {
            "line": 2,
            "action": "loop-start",
            "description": "i=2",
            "state": {
              "i": 2
            }
          },
          {
            "line": 3,
            "action": "branch",
            "description": "Check i==1: false"
          },
          {
            "line": 4,
            "action": "branch",
            "description": "Check i==3: false"
          },
          {
            "line": 5,
            "action": "output",
            "description": "Output 2",
            "output": "2"
          },
          {
            "line": 2,
            "action": "loop-start",
            "description": "i=3",
            "state": {
              "i": 3
            }
          },
          {
            "line": 3,
            "action": "branch",
            "description": "Check i==1: false"
          },
          {
            "line": 4,
            "action": "branch",
            "description": "Check i==3: true, break",
            "concepts": [
              "break"
            ]
          },
          {
            "line": 6,
            "action": "output",
            "description": "Output \"X\"",
            "output": "X"
          }
        ],
        "finalOutput": "02X",
        "keyInsight": "`continue` skips to next iteration; `break` exits loop entirely; code after loop still executes"
      }
    },
    {
      "id": "arr-016",
      "categoryId": "arrays-iteration",
      "concept": "`vector::size()`",
      "code": "#include <vector>\nint main() {\n    vector<int> v = {1, 2, 3, 4, 5};\n    cout << v.size();\n}",
      "output": "5",
      "tags": [
        "arrays",
        "loops",
        "stl"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "declare",
            "description": "Declare vector `v` with 5 elements",
            "state": {
              "v": [
                1,
                2,
                3,
                4,
                5
              ]
            },
            "concepts": [
              "vector-initialization"
            ]
          },
          {
            "line": 3,
            "action": "call",
            "description": "Call v.size() which returns 5",
            "concepts": [
              "vector-size"
            ]
          },
          {
            "line": 3,
            "action": "output",
            "description": "Output 5",
            "output": "5"
          }
        ],
        "finalOutput": "5",
        "keyInsight": "`vector::size()` returns the number of elements in the vector"
      }
    },
    {
      "id": "arr-017",
      "categoryId": "arrays-iteration",
      "concept": "Size re-evaluated each iteration",
      "code": "#include <vector>\nint main() {\n    vector<int> v = {1, 2};\n    for (size_t i = 0; i < v.size(); i++) {\n        if (i == 0) v.push_back(3);\n        cout << v[i];\n    }\n}",
      "output": "123",
      "tags": [
        "arrays",
        "loops"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "declare",
            "description": "Declare vector `v` with {1, 2}",
            "state": {
              "v": [
                1,
                2
              ]
            },
            "concepts": [
              "vector-initialization"
            ]
          },
          {
            "line": 3,
            "action": "loop-check",
            "description": "Check i=0 < v.size()=2: true",
            "state": {
              "i": 0
            },
            "concepts": [
              "for-loop"
            ]
          },
          {
            "line": 4,
            "action": "branch",
            "description": "Check i==0: true"
          },
          {
            "line": 4,
            "action": "call",
            "description": "push_back(3) adds element to vector",
            "state": {
              "v": [
                1,
                2,
                3
              ]
            },
            "concepts": [
              "vector-push-back"
            ]
          },
          {
            "line": 5,
            "action": "output",
            "description": "Output v[0]=1",
            "output": "1"
          },
          {
            "line": 3,
            "action": "loop-check",
            "description": "Check i=1 < v.size()=3: true (size re-evaluated!)",
            "state": {
              "i": 1
            }
          },
          {
            "line": 4,
            "action": "branch",
            "description": "Check i==0: false"
          },
          {
            "line": 5,
            "action": "output",
            "description": "Output v[1]=2",
            "output": "2"
          },
          {
            "line": 3,
            "action": "loop-check",
            "description": "Check i=2 < v.size()=3: true",
            "state": {
              "i": 2
            }
          },
          {
            "line": 4,
            "action": "branch",
            "description": "Check i==0: false"
          },
          {
            "line": 5,
            "action": "output",
            "description": "Output v[2]=3",
            "output": "3"
          },
          {
            "line": 3,
            "action": "loop-check",
            "description": "Check i=3 < v.size()=3: false, exit loop",
            "state": {
              "i": 3
            }
          }
        ],
        "finalOutput": "123",
        "keyInsight": "Loop condition `v.size()` is re-evaluated each iteration, so adding elements extends the loop"
      }
    },
    {
      "id": "arr-018",
      "categoryId": "arrays-iteration",
      "concept": "Modifying container during iteration",
      "code": "#include <vector>\nint main() {\n    vector<int> v = {1};\n    for (size_t i = 0; i < v.size() && i < 3; i++) {\n        v.push_back(v[i] + 1);\n    }\n    cout << v.size();\n}",
      "output": "4",
      "tags": [
        "arrays",
        "loops",
        "conditionals"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "declare",
            "description": "Declare vector `v` with {1}",
            "state": {
              "v": [
                1
              ]
            },
            "concepts": [
              "vector-initialization"
            ]
          },
          {
            "line": 3,
            "action": "loop-check",
            "description": "i=0: 0 < 1 && 0 < 3: true",
            "state": {
              "i": 0
            }
          },
          {
            "line": 4,
            "action": "call",
            "description": "push_back(v[0]+1=2)",
            "state": {
              "v": [
                1,
                2
              ]
            },
            "concepts": [
              "vector-push-back"
            ]
          },
          {
            "line": 3,
            "action": "loop-check",
            "description": "i=1: 1 < 2 && 1 < 3: true",
            "state": {
              "i": 1
            }
          },
          {
            "line": 4,
            "action": "call",
            "description": "push_back(v[1]+1=3)",
            "state": {
              "v": [
                1,
                2,
                3
              ]
            }
          },
          {
            "line": 3,
            "action": "loop-check",
            "description": "i=2: 2 < 3 && 2 < 3: true",
            "state": {
              "i": 2
            }
          },
          {
            "line": 4,
            "action": "call",
            "description": "push_back(v[2]+1=4)",
            "state": {
              "v": [
                1,
                2,
                3,
                4
              ]
            }
          },
          {
            "line": 3,
            "action": "loop-check",
            "description": "i=3: 3 < 4 but 3 < 3 is false, exit",
            "state": {
              "i": 3
            }
          },
          {
            "line": 5,
            "action": "output",
            "description": "Output v.size()=4",
            "output": "4"
          }
        ],
        "finalOutput": "4",
        "keyInsight": "The `i < 3` guard prevents infinite loop when modifying container during iteration"
      }
    },
    {
      "id": "arr-019",
      "categoryId": "arrays-iteration",
      "concept": "`vector(n)` constructor",
      "code": "#include <vector>\nint main() {\n    vector<int> v(3);\n    cout << v.size() << v[0] << v[1] << v[2];\n}",
      "output": "3000",
      "tags": [
        "arrays",
        "loops",
        "const",
        "constructors",
        "stl"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "declare",
            "description": "Create vector of 3 default-initialized ints (all 0)",
            "state": {
              "v": [
                0,
                0,
                0
              ]
            },
            "concepts": [
              "vector-constructor",
              "default-initialization"
            ]
          },
          {
            "line": 3,
            "action": "call",
            "description": "v.size() returns 3",
            "concepts": [
              "vector-size"
            ]
          },
          {
            "line": 3,
            "action": "output",
            "description": "Output size=3, v[0]=0, v[1]=0, v[2]=0",
            "output": "3000"
          }
        ],
        "finalOutput": "3000",
        "keyInsight": "`vector<int> v(n)` creates n elements, all value-initialized to 0"
      }
    },
    {
      "id": "arr-020",
      "categoryId": "arrays-iteration",
      "concept": "`vector{...}` initializer list",
      "code": "#include <vector>\nint main() {\n    vector<int> v{3};\n    cout << v.size() << v[0];\n}",
      "output": "13",
      "tags": [
        "arrays",
        "loops",
        "stl"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "declare",
            "description": "Create vector with initializer list containing one element: 3",
            "state": {
              "v": [
                3
              ]
            },
            "concepts": [
              "initializer-list"
            ]
          },
          {
            "line": 3,
            "action": "output",
            "description": "Output size=1, v[0]=3",
            "output": "13"
          }
        ],
        "finalOutput": "13",
        "keyInsight": "`vector{3}` uses initializer list, creating a vector with one element of value 3"
      }
    },
    {
      "id": "arr-021",
      "categoryId": "arrays-iteration",
      "concept": "`()` vs `{}` syntax difference",
      "code": "#include <vector>\nint main() {\n    vector<int> a(5);    // 5 zeros\n    vector<int> b{5};    // one element: 5\n    cout << a.size() << b.size();\n}",
      "output": "51",
      "tags": [
        "arrays",
        "loops",
        "conditionals"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "declare",
            "description": "vector<int> a(5): creates 5 zeros",
            "state": {
              "a": [
                0,
                0,
                0,
                0,
                0
              ]
            },
            "concepts": [
              "vector-constructor"
            ]
          },
          {
            "line": 3,
            "action": "declare",
            "description": "vector<int> b{5}: creates 1 element with value 5",
            "state": {
              "b": [
                5
              ]
            },
            "concepts": [
              "initializer-list"
            ]
          },
          {
            "line": 4,
            "action": "output",
            "description": "Output a.size()=5, b.size()=1",
            "output": "51"
          }
        ],
        "finalOutput": "51",
        "keyInsight": "`()` calls size constructor (n zeros); `{}` uses initializer list (elements with those values)"
      }
    },
    {
      "id": "arr-022",
      "categoryId": "arrays-iteration",
      "concept": "Array as function parameter",
      "code": "void f(int arr[]) { cout << arr[0]; }\nint main() {\n    int a[] = {7, 8, 9};\n    f(a);\n}",
      "output": "7",
      "tags": [
        "arrays",
        "loops"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "declare",
            "description": "Declare array `a` with {7, 8, 9}",
            "state": {
              "a": [
                7,
                8,
                9
              ]
            },
            "concepts": [
              "array-initialization"
            ]
          },
          {
            "line": 3,
            "action": "call",
            "description": "Call f(a): array decays to pointer to first element",
            "concepts": [
              "array-decay"
            ]
          },
          {
            "line": 1,
            "action": "evaluate",
            "description": "In f(): arr points to a[0]",
            "state": {
              "arr": "->a[0]"
            }
          },
          {
            "line": 1,
            "action": "output",
            "description": "Output arr[0]=7",
            "output": "7"
          }
        ],
        "finalOutput": "7",
        "keyInsight": "Arrays passed to functions decay to pointers; `int arr[]` is equivalent to `int* arr`"
      }
    },
    {
      "id": "arr-023",
      "categoryId": "arrays-iteration",
      "concept": "Array decay",
      "code": "void f(int* p) { cout << *p; }\nint main() {\n    int arr[] = {5, 6};\n    f(arr);  // Decays to pointer\n}",
      "output": "5",
      "tags": [
        "arrays",
        "loops"
      ],
      "explanation": {
        "steps": [
          {
            "line": 3,
            "action": "declare",
            "description": "Declare array `arr` with {5, 6}",
            "state": {
              "arr": [
                5,
                6
              ]
            },
            "concepts": [
              "array-initialization"
            ]
          },
          {
            "line": 4,
            "action": "call",
            "description": "Call f(arr): array decays to int*",
            "concepts": [
              "array-decay"
            ]
          },
          {
            "line": 1,
            "action": "dereference",
            "description": "In f(): *p dereferences pointer to get arr[0]=5",
            "concepts": [
              "dereference"
            ]
          },
          {
            "line": 1,
            "action": "output",
            "description": "Output 5",
            "output": "5"
          }
        ],
        "finalOutput": "5",
        "keyInsight": "When passed to functions, arrays decay to pointers; the array name becomes a pointer to element 0"
      }
    },
    {
      "id": "arr-024",
      "categoryId": "arrays-iteration",
      "concept": "`sizeof` on array vs pointer",
      "code": "void f(int arr[]) {\n    cout << sizeof(arr);  // Size of pointer\n}\nint main() {\n    int a[10];\n    cout << sizeof(a) << \" \";  // Size of array\n    f(a);\n}",
      "output": "40 8",
      "tags": [
        "arrays",
        "loops",
        "pointers"
      ],
      "explanation": {
        "steps": [
          {
            "line": 4,
            "action": "declare",
            "description": "Declare array `a` of 10 ints",
            "concepts": [
              "array-declaration"
            ]
          },
          {
            "line": 5,
            "action": "evaluate",
            "description": "sizeof(a) = 40 bytes (10 ints \u00d7 4 bytes)",
            "concepts": [
              "sizeof-operator"
            ]
          },
          {
            "line": 5,
            "action": "output",
            "description": "Output \"40 \"",
            "output": "40 "
          },
          {
            "line": 6,
            "action": "call",
            "description": "Call f(a): array decays to pointer",
            "concepts": [
              "array-decay"
            ]
          },
          {
            "line": 2,
            "action": "evaluate",
            "description": "In f(): sizeof(arr) = 8 bytes (pointer size on 64-bit)",
            "concepts": [
              "sizeof-operator",
              "pointer-size"
            ]
          },
          {
            "line": 2,
            "action": "output",
            "description": "Output 8",
            "output": "8"
          }
        ],
        "finalOutput": "40 8",
        "keyInsight": "`sizeof` on array gives total byte size; on decayed pointer gives only pointer size (8 bytes on 64-bit)"
      }
    },
    {
      "id": "arr-025",
      "categoryId": "arrays-iteration",
      "concept": "`std::array<T,N>`",
      "code": "#include <array>\nint main() {\n    array<int, 3> a = {1, 2, 3};\n    cout << a[0] << a.size();\n}",
      "output": "13",
      "tags": [
        "arrays",
        "loops"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "declare",
            "description": "Declare std::array of 3 ints with {1, 2, 3}",
            "state": {
              "a": [
                1,
                2,
                3
              ]
            },
            "concepts": [
              "std-array"
            ]
          },
          {
            "line": 3,
            "action": "evaluate",
            "description": "Access a[0]=1",
            "concepts": [
              "array-access"
            ]
          },
          {
            "line": 3,
            "action": "call",
            "description": "Call a.size()=3",
            "concepts": [
              "std-array-size"
            ]
          },
          {
            "line": 3,
            "action": "output",
            "description": "Output 1 and 3",
            "output": "13"
          }
        ],
        "finalOutput": "13",
        "keyInsight": "`std::array` is a fixed-size container that knows its size and doesn't decay to pointer"
      }
    },
    {
      "id": "arr-026",
      "categoryId": "arrays-iteration",
      "concept": "`std::array` pass by value (copies)",
      "code": "#include <array>\nvoid f(array<int, 2> a) { a[0] = 99; }\nint main() {\n    array<int, 2> arr = {1, 2};\n    f(arr);\n    cout << arr[0];\n}",
      "output": "1",
      "tags": [
        "arrays",
        "loops"
      ],
      "explanation": {
        "steps": [
          {
            "line": 3,
            "action": "declare",
            "description": "Declare std::array `arr` with {1, 2}",
            "state": {
              "arr": [
                1,
                2
              ]
            },
            "concepts": [
              "std-array"
            ]
          },
          {
            "line": 4,
            "action": "call",
            "description": "Call f(arr): entire array is COPIED",
            "concepts": [
              "pass-by-value",
              "std-array"
            ]
          },
          {
            "line": 2,
            "action": "copy",
            "description": "Parameter `a` is a copy of arr",
            "state": {
              "a": [
                1,
                2
              ],
              "arr": [
                1,
                2
              ]
            }
          },
          {
            "line": 2,
            "action": "assign",
            "description": "Set a[0]=99 (only affects copy)",
            "state": {
              "a": [
                99,
                2
              ],
              "arr": [
                1,
                2
              ]
            }
          },
          {
            "line": 5,
            "action": "output",
            "description": "Output arr[0]=1 (unchanged)",
            "output": "1"
          }
        ],
        "finalOutput": "1",
        "keyInsight": "Unlike C arrays, `std::array` passed by value creates a full copy; original is unmodified"
      }
    },
    {
      "id": "cls-001",
      "categoryId": "classes-constructors",
      "concept": "Default constructor",
      "code": "class A {\npublic:\n    A() { cout << \"D\"; }\n};\nint main() { A a; }",
      "output": "D",
      "tags": [
        "classes",
        "oop",
        "const",
        "constructors"
      ],
      "explanation": {
        "steps": [
          {
            "line": 5,
            "action": "declare",
            "description": "Declare object `a` of type A",
            "concepts": [
              "object-declaration"
            ]
          },
          {
            "line": 3,
            "action": "construct",
            "description": "Call default constructor A()",
            "concepts": [
              "default-constructor"
            ]
          },
          {
            "line": 3,
            "action": "output",
            "description": "Constructor outputs \"D\"",
            "output": "D"
          }
        ],
        "finalOutput": "D",
        "keyInsight": "Default constructor is called automatically when an object is created without arguments"
      }
    },
    {
      "id": "cls-002",
      "categoryId": "classes-constructors",
      "concept": "Parameterized constructor",
      "code": "class A {\npublic:\n    A(int x) { cout << x; }\n};\nint main() { A a(5); }",
      "output": "5",
      "tags": [
        "classes",
        "oop",
        "const",
        "constructors"
      ],
      "explanation": {
        "steps": [
          {
            "line": 5,
            "action": "declare",
            "description": "Declare object `a` with argument 5",
            "concepts": [
              "object-declaration"
            ]
          },
          {
            "line": 3,
            "action": "construct",
            "description": "Call parameterized constructor A(5)",
            "concepts": [
              "parameterized-constructor"
            ]
          },
          {
            "line": 3,
            "action": "output",
            "description": "Constructor outputs x=5",
            "output": "5"
          }
        ],
        "finalOutput": "5",
        "keyInsight": "Parameterized constructor receives arguments and can use them during initialization"
      }
    },
    {
      "id": "cls-003",
      "categoryId": "classes-constructors",
      "concept": "Implicit conversion `Type x = value`",
      "code": "class A {\npublic:\n    A(int x) { cout << x; }\n};\nint main() { A a = 7; }",
      "output": "7",
      "tags": [
        "classes",
        "oop"
      ],
      "explanation": {
        "steps": [
          {
            "line": 5,
            "action": "declare",
            "description": "Declare `A a = 7` - copy initialization syntax",
            "concepts": [
              "copy-initialization"
            ]
          },
          {
            "line": 3,
            "action": "construct",
            "description": "Implicit conversion: A(7) is called",
            "concepts": [
              "implicit-conversion"
            ]
          },
          {
            "line": 3,
            "action": "output",
            "description": "Constructor outputs 7",
            "output": "7"
          }
        ],
        "finalOutput": "7",
        "keyInsight": "`A a = value` triggers implicit conversion, calling constructor A(value)"
      }
    },
    {
      "id": "cls-004",
      "categoryId": "classes-constructors",
      "concept": "Copy constructor",
      "code": "class A {\npublic:\n    A() { cout << \"D\"; }\n    A(const A&) { cout << \"C\"; }\n};\nint main() { A a; A b = a; }",
      "output": "DC",
      "tags": [
        "classes",
        "oop",
        "const",
        "constructors",
        "copy-semantics"
      ],
      "explanation": {
        "steps": [
          {
            "line": 6,
            "action": "declare",
            "description": "Declare object `a`",
            "concepts": [
              "object-declaration"
            ]
          },
          {
            "line": 3,
            "action": "construct",
            "description": "Call default constructor for a",
            "concepts": [
              "default-constructor"
            ]
          },
          {
            "line": 3,
            "action": "output",
            "description": "Output \"D\"",
            "output": "D"
          },
          {
            "line": 6,
            "action": "declare",
            "description": "Declare `A b = a` - copy initialization",
            "concepts": [
              "copy-initialization"
            ]
          },
          {
            "line": 4,
            "action": "construct",
            "description": "Call copy constructor A(const A&)",
            "concepts": [
              "copy-constructor"
            ]
          },
          {
            "line": 4,
            "action": "output",
            "description": "Output \"C\"",
            "output": "C"
          }
        ],
        "finalOutput": "DC",
        "keyInsight": "Copy constructor is called when initializing a new object from an existing one"
      }
    },
    {
      "id": "cls-005",
      "categoryId": "classes-constructors",
      "concept": "Default parameter values in constructor",
      "code": "class A {\npublic:\n    A(int x = 10) { cout << x; }\n};\nint main() { A a; A b(5); }",
      "output": "105",
      "tags": [
        "classes",
        "oop",
        "const",
        "constructors"
      ],
      "explanation": {
        "steps": [
          {
            "line": 5,
            "action": "declare",
            "description": "Declare `A a` with no arguments",
            "concepts": [
              "object-declaration"
            ]
          },
          {
            "line": 3,
            "action": "construct",
            "description": "Call A() using default parameter x=10",
            "concepts": [
              "default-parameters"
            ]
          },
          {
            "line": 3,
            "action": "output",
            "description": "Output 10",
            "output": "10"
          },
          {
            "line": 5,
            "action": "declare",
            "description": "Declare `A b(5)` with argument",
            "concepts": [
              "object-declaration"
            ]
          },
          {
            "line": 3,
            "action": "construct",
            "description": "Call A(5), x=5",
            "concepts": [
              "parameterized-constructor"
            ]
          },
          {
            "line": 3,
            "action": "output",
            "description": "Output 5",
            "output": "5"
          }
        ],
        "finalOutput": "105",
        "keyInsight": "Default parameter values allow one constructor to serve as both default and parameterized"
      }
    },
    {
      "id": "cls-006",
      "categoryId": "classes-constructors",
      "concept": "Single constructor as default + parameterized",
      "code": "class Point {\npublic:\n    Point(int x = 0, int y = 0) { cout << x << y; }\n};\nint main() { Point p1; Point p2(3); Point p3(1, 2); }",
      "output": "003012",
      "tags": [
        "classes",
        "oop",
        "const",
        "constructors"
      ],
      "explanation": {
        "steps": [
          {
            "line": 5,
            "action": "construct",
            "description": "Point p1: x=0, y=0 (both defaults)",
            "concepts": [
              "default-parameters"
            ]
          },
          {
            "line": 4,
            "action": "output",
            "description": "Output \"00\"",
            "output": "00"
          },
          {
            "line": 5,
            "action": "construct",
            "description": "Point p2(3): x=3, y=0 (y uses default)",
            "concepts": [
              "default-parameters"
            ]
          },
          {
            "line": 4,
            "action": "output",
            "description": "Output \"30\"",
            "output": "30"
          },
          {
            "line": 5,
            "action": "construct",
            "description": "Point p3(1,2): x=1, y=2 (no defaults)",
            "concepts": [
              "parameterized-constructor"
            ]
          },
          {
            "line": 4,
            "action": "output",
            "description": "Output \"12\"",
            "output": "12"
          }
        ],
        "finalOutput": "003012",
        "keyInsight": "Multiple default parameters allow flexible constructor calls with varying argument counts"
      }
    },
    {
      "id": "cls-007",
      "categoryId": "classes-constructors",
      "concept": "Member initializer list `: member(value)`",
      "code": "class A {\n    int x;\npublic:\n    A(int v) : x(v) { cout << x; }\n};\nint main() { A a(9); }",
      "output": "9",
      "tags": [
        "classes",
        "oop"
      ],
      "explanation": {
        "steps": [
          {
            "line": 6,
            "action": "declare",
            "description": "Declare `A a(9)`",
            "concepts": [
              "object-declaration"
            ]
          },
          {
            "line": 5,
            "action": "initialize",
            "description": "Member initializer list: initialize x=9 before body runs",
            "concepts": [
              "member-initializer-list"
            ]
          },
          {
            "line": 5,
            "action": "construct",
            "description": "Execute constructor body",
            "concepts": [
              "constructor"
            ]
          },
          {
            "line": 5,
            "action": "output",
            "description": "Output x=9",
            "output": "9"
          }
        ],
        "finalOutput": "9",
        "keyInsight": "Member initializer list initializes members BEFORE constructor body executes"
      }
    },
    {
      "id": "cls-008",
      "categoryId": "classes-constructors",
      "concept": "Initialization order = declaration order",
      "code": "class A {\n    int a;\n    int b;\npublic:\n    A() : b(1), a(2) { cout << a << b; }  // a initialized first!\n};\nint main() { A x; }",
      "output": "21",
      "tags": [
        "classes",
        "oop"
      ],
      "explanation": {
        "steps": [
          {
            "line": 7,
            "action": "declare",
            "description": "Declare `A x`",
            "concepts": [
              "object-declaration"
            ]
          },
          {
            "line": 5,
            "action": "initialize",
            "description": "Initialize `a` first (declared on line 3)",
            "state": {
              "a": 2
            },
            "concepts": [
              "initialization-order"
            ]
          },
          {
            "line": 5,
            "action": "initialize",
            "description": "Initialize `b` second (declared on line 4)",
            "state": {
              "b": 1
            },
            "concepts": [
              "initialization-order"
            ]
          },
          {
            "line": 5,
            "action": "output",
            "description": "Output a=2, b=1",
            "output": "21"
          }
        ],
        "finalOutput": "21",
        "keyInsight": "Members initialize in DECLARATION order, not initializer list order"
      }
    },
    {
      "id": "cls-009",
      "categoryId": "classes-constructors",
      "concept": "Undefined behavior from wrong order",
      "code": "class A {\n    int a;\n    int b;\npublic:\n    A() : b(5), a(b) { cout << a << b; }  // a uses uninitialized b!\n};\nint main() { A x; }",
      "output": "Undefined (likely garbage for a, then 5)",
      "tags": [
        "classes",
        "oop"
      ],
      "explanation": {
        "steps": [
          {
            "line": 7,
            "action": "declare",
            "description": "Declare `A x`",
            "concepts": [
              "object-declaration"
            ]
          },
          {
            "line": 5,
            "action": "initialize",
            "description": "Initialize `a` first using uninitialized `b` (UB!)",
            "state": {
              "a": "garbage"
            },
            "concepts": [
              "initialization-order",
              "undefined-behavior"
            ]
          },
          {
            "line": 5,
            "action": "initialize",
            "description": "Initialize `b` = 5",
            "state": {
              "b": 5
            },
            "concepts": [
              "member-initializer-list"
            ]
          },
          {
            "line": 5,
            "action": "output",
            "description": "Output garbage value for a, then 5",
            "output": "?5"
          }
        ],
        "finalOutput": "Undefined (likely garbage for a, then 5)",
        "keyInsight": "Using a member to initialize another that's declared earlier causes undefined behavior"
      }
    },
    {
      "id": "cls-010",
      "categoryId": "classes-constructors",
      "concept": "Constructor/destructor call order",
      "code": "class A {\npublic:\n    A() { cout << \"+\"; }\n    ~A() { cout << \"-\"; }\n};\nint main() { A a; cout << \"|\"; }",
      "output": "+|-",
      "tags": [
        "classes",
        "oop",
        "const",
        "constructors",
        "destructors"
      ],
      "explanation": {
        "steps": [
          {
            "line": 6,
            "action": "declare",
            "description": "Declare `A a`",
            "concepts": [
              "object-declaration"
            ]
          },
          {
            "line": 3,
            "action": "construct",
            "description": "Call constructor",
            "concepts": [
              "constructor"
            ]
          },
          {
            "line": 3,
            "action": "output",
            "description": "Output \"+\"",
            "output": "+"
          },
          {
            "line": 6,
            "action": "output",
            "description": "Execute cout << \"|\"",
            "output": "|"
          },
          {
            "line": null,
            "action": "destruct",
            "description": "End of main: destroy a",
            "concepts": [
              "destructor"
            ]
          },
          {
            "line": 4,
            "action": "output",
            "description": "Destructor outputs \"-\"",
            "output": "-"
          }
        ],
        "finalOutput": "+|-",
        "keyInsight": "Constructor runs at object creation; destructor runs automatically when object goes out of scope"
      }
    },
    {
      "id": "cls-011",
      "categoryId": "classes-constructors",
      "concept": "LIFO destruction",
      "code": "class A {\n    int id;\npublic:\n    A(int i) : id(i) { cout << \"+\" << id; }\n    ~A() { cout << \"-\" << id; }\n};\nint main() { A a(1); A b(2); }",
      "output": "+1+2-2-1",
      "tags": [
        "classes",
        "oop",
        "conditionals"
      ],
      "explanation": {
        "steps": [
          {
            "line": 7,
            "action": "construct",
            "description": "Create `a` with id=1",
            "concepts": [
              "constructor"
            ]
          },
          {
            "line": 5,
            "action": "output",
            "description": "Output \"+1\"",
            "output": "+1"
          },
          {
            "line": 7,
            "action": "construct",
            "description": "Create `b` with id=2",
            "concepts": [
              "constructor"
            ]
          },
          {
            "line": 5,
            "action": "output",
            "description": "Output \"+2\"",
            "output": "+2"
          },
          {
            "line": null,
            "action": "destruct",
            "description": "End of main: destroy b first (LIFO)",
            "concepts": [
              "destructor",
              "lifo-destruction"
            ]
          },
          {
            "line": 6,
            "action": "output",
            "description": "Output \"-2\"",
            "output": "-2"
          },
          {
            "line": null,
            "action": "destruct",
            "description": "Then destroy a",
            "concepts": [
              "destructor"
            ]
          },
          {
            "line": 6,
            "action": "output",
            "description": "Output \"-1\"",
            "output": "-1"
          }
        ],
        "finalOutput": "+1+2-2-1",
        "keyInsight": "Objects are destroyed in reverse order of construction (LIFO - Last In, First Out)"
      }
    },
    {
      "id": "cls-012",
      "categoryId": "classes-constructors",
      "concept": "Member object construction order",
      "code": "class M { public: M() { cout << \"M\"; } };\nclass A {\n    M m;\npublic:\n    A() { cout << \"A\"; }\n};\nint main() { A a; }",
      "output": "MA",
      "tags": [
        "classes",
        "oop",
        "const"
      ],
      "explanation": {
        "steps": [
          {
            "line": 6,
            "action": "declare",
            "description": "Declare `A a`",
            "concepts": [
              "object-declaration"
            ]
          },
          {
            "line": 1,
            "action": "construct",
            "description": "First: construct member `m` of type M",
            "concepts": [
              "member-construction"
            ]
          },
          {
            "line": 1,
            "action": "output",
            "description": "Output \"M\"",
            "output": "M"
          },
          {
            "line": 5,
            "action": "construct",
            "description": "Then: execute A's constructor body",
            "concepts": [
              "constructor"
            ]
          },
          {
            "line": 5,
            "action": "output",
            "description": "Output \"A\"",
            "output": "A"
          }
        ],
        "finalOutput": "MA",
        "keyInsight": "Member objects are constructed BEFORE the containing class's constructor body runs"
      }
    },
    {
      "id": "cls-013",
      "categoryId": "classes-constructors",
      "concept": "Declaration order matters",
      "code": "class X { public: X() { cout << \"X\"; } };\nclass Y { public: Y() { cout << \"Y\"; } };\nclass A {\n    X x;\n    Y y;\npublic:\n    A() { cout << \"A\"; }\n};\nint main() { A a; }",
      "output": "XYA",
      "tags": [
        "classes",
        "oop"
      ],
      "explanation": {
        "steps": [
          {
            "line": 8,
            "action": "declare",
            "description": "Declare `A a`",
            "concepts": [
              "object-declaration"
            ]
          },
          {
            "line": 5,
            "action": "construct",
            "description": "First: construct member `x` (declared first)",
            "concepts": [
              "member-construction"
            ]
          },
          {
            "line": 1,
            "action": "output",
            "description": "Output \"X\"",
            "output": "X"
          },
          {
            "line": 6,
            "action": "construct",
            "description": "Second: construct member `y` (declared second)",
            "concepts": [
              "member-construction"
            ]
          },
          {
            "line": 2,
            "action": "output",
            "description": "Output \"Y\"",
            "output": "Y"
          },
          {
            "line": 7,
            "action": "construct",
            "description": "Finally: execute A's constructor body",
            "concepts": [
              "constructor"
            ]
          },
          {
            "line": 7,
            "action": "output",
            "description": "Output \"A\"",
            "output": "A"
          }
        ],
        "finalOutput": "XYA",
        "keyInsight": "Member objects construct in declaration order, then the class constructor body runs"
      }
    },
    {
      "id": "cls-014",
      "categoryId": "classes-constructors",
      "concept": "Composition (has-a relationship)",
      "code": "class Engine { public: Engine() { cout << \"E\"; } };\nclass Car {\n    Engine e;\npublic:\n    Car() { cout << \"C\"; }\n};\nint main() { Car c; }",
      "output": "EC",
      "tags": [
        "classes",
        "oop"
      ],
      "explanation": {
        "steps": [
          {
            "line": 4,
            "action": "declare",
            "description": "Declare `Car c`",
            "concepts": [
              "object-declaration"
            ]
          },
          {
            "line": 3,
            "action": "construct",
            "description": "First: construct member `e` of type Engine",
            "concepts": [
              "composition",
              "member-construction"
            ]
          },
          {
            "line": 1,
            "action": "output",
            "description": "Output \"E\"",
            "output": "E"
          },
          {
            "line": 4,
            "action": "construct",
            "description": "Then: execute Car's constructor body",
            "concepts": [
              "constructor"
            ]
          },
          {
            "line": 4,
            "action": "output",
            "description": "Output \"C\"",
            "output": "C"
          }
        ],
        "finalOutput": "EC",
        "keyInsight": "Composition (has-a): contained object constructs before containing object's constructor runs"
      }
    },
    {
      "id": "cls-015",
      "categoryId": "classes-constructors",
      "concept": "`const` object",
      "code": "class A {\npublic:\n    int x = 5;\n    int get() const { return x; }\n};\nint main() {\n    const A a;\n    cout << a.get();\n}",
      "output": "5",
      "tags": [
        "classes",
        "oop",
        "const"
      ],
      "explanation": {
        "steps": [
          {
            "line": 7,
            "action": "declare",
            "description": "Declare `const A a`",
            "concepts": [
              "const-object"
            ]
          },
          {
            "line": 8,
            "action": "call",
            "description": "Call a.get() - allowed because get() is const",
            "concepts": [
              "const-member-function"
            ]
          },
          {
            "line": 5,
            "action": "return",
            "description": "Return x=5",
            "concepts": [
              "return"
            ]
          },
          {
            "line": 8,
            "action": "output",
            "description": "Output 5",
            "output": "5"
          }
        ],
        "finalOutput": "5",
        "keyInsight": "Const objects can only call const member functions"
      }
    },
    {
      "id": "cls-016",
      "categoryId": "classes-constructors",
      "concept": "`const` member function",
      "code": "class A {\n    int x = 10;\npublic:\n    int get() const { return x; }\n};\nint main() { A a; cout << a.get(); }",
      "output": "10",
      "tags": [
        "classes",
        "oop",
        "const"
      ],
      "explanation": {
        "steps": [
          {
            "line": 6,
            "action": "declare",
            "description": "Declare `A a`",
            "concepts": [
              "object-declaration"
            ]
          },
          {
            "line": 6,
            "action": "call",
            "description": "Call a.get()",
            "concepts": [
              "member-function-call"
            ]
          },
          {
            "line": 5,
            "action": "return",
            "description": "const function returns x=10",
            "concepts": [
              "const-member-function"
            ]
          },
          {
            "line": 6,
            "action": "output",
            "description": "Output 10",
            "output": "10"
          }
        ],
        "finalOutput": "10",
        "keyInsight": "Const member functions promise not to modify the object's state"
      }
    },
    {
      "id": "cls-017",
      "categoryId": "classes-constructors",
      "concept": "Calling restrictions on const objects",
      "code": "class A {\npublic:\n    void modify() { cout << \"M\"; }\n    void read() const { cout << \"R\"; }\n};\nint main() {\n    const A a;\n    a.read();\n    // a.modify();  // Would not compile!\n}",
      "output": "R",
      "tags": [
        "classes",
        "oop",
        "const"
      ],
      "explanation": {
        "steps": [
          {
            "line": 7,
            "action": "declare",
            "description": "Declare `const A a`",
            "concepts": [
              "const-object"
            ]
          },
          {
            "line": 8,
            "action": "call",
            "description": "Call a.read() - const function, allowed",
            "concepts": [
              "const-member-function"
            ]
          },
          {
            "line": 5,
            "action": "output",
            "description": "Output \"R\"",
            "output": "R"
          }
        ],
        "finalOutput": "R",
        "keyInsight": "Const objects can only call const member functions; non-const functions would be compile error"
      }
    },
    {
      "id": "cls-018",
      "categoryId": "classes-constructors",
      "concept": "`explicit` constructor",
      "code": "class A {\npublic:\n    explicit A(int x) { cout << x; }\n};\nint main() {\n    A a(5);\n    // A b = 10;  // Error: explicit blocks this\n}",
      "output": "5",
      "tags": [
        "classes",
        "oop",
        "const",
        "constructors"
      ],
      "explanation": {
        "steps": [
          {
            "line": 5,
            "action": "declare",
            "description": "Declare `A a(5)` - direct initialization",
            "concepts": [
              "direct-initialization"
            ]
          },
          {
            "line": 3,
            "action": "construct",
            "description": "Call explicit constructor A(5)",
            "concepts": [
              "explicit-constructor"
            ]
          },
          {
            "line": 3,
            "action": "output",
            "description": "Output 5",
            "output": "5"
          }
        ],
        "finalOutput": "5",
        "keyInsight": "`explicit` prevents implicit conversion; only direct initialization A(x) is allowed"
      }
    },
    {
      "id": "cls-019",
      "categoryId": "classes-constructors",
      "concept": "Preventing implicit conversion",
      "code": "class A {\npublic:\n    explicit A(int x) { cout << x; }\n};\nvoid f(A a) {}\nint main() {\n    f(A(3));\n    // f(3);  // Error: no implicit conversion\n}",
      "output": "3",
      "tags": [
        "classes",
        "oop"
      ],
      "explanation": {
        "steps": [
          {
            "line": 6,
            "action": "call",
            "description": "Call f(A(3)) - explicit construction",
            "concepts": [
              "explicit-constructor"
            ]
          },
          {
            "line": 3,
            "action": "construct",
            "description": "Construct A(3)",
            "concepts": [
              "constructor"
            ]
          },
          {
            "line": 3,
            "action": "output",
            "description": "Output 3",
            "output": "3"
          },
          {
            "line": 5,
            "action": "call",
            "description": "f() receives A object",
            "concepts": [
              "function-call"
            ]
          }
        ],
        "finalOutput": "3",
        "keyInsight": "`explicit` requires explicit A(x) construction; f(3) would fail without explicit cast"
      }
    },
    {
      "id": "cls-020",
      "categoryId": "classes-constructors",
      "concept": "Direct initialization only",
      "code": "class A {\npublic:\n    explicit A(int x) { cout << \"OK\"; }\n};\nint main() {\n    A a(1);      // Direct: OK\n    A b{2};      // Direct: OK\n    // A c = 3;  // Copy init: Error\n}",
      "output": "OKOK",
      "tags": [
        "classes",
        "oop"
      ],
      "explanation": {
        "steps": [
          {
            "line": 5,
            "action": "construct",
            "description": "A a(1): direct init with ()",
            "concepts": [
              "direct-initialization"
            ]
          },
          {
            "line": 3,
            "action": "output",
            "description": "Output \"OK\"",
            "output": "OK"
          },
          {
            "line": 6,
            "action": "construct",
            "description": "A b{2}: direct init with {}",
            "concepts": [
              "direct-initialization",
              "brace-initialization"
            ]
          },
          {
            "line": 3,
            "action": "output",
            "description": "Output \"OK\"",
            "output": "OK"
          }
        ],
        "finalOutput": "OKOK",
        "keyInsight": "Explicit constructors allow A(x) and A{x} but not A a = x (copy initialization)"
      }
    },
    {
      "id": "cls-021",
      "categoryId": "classes-constructors",
      "concept": "`static` member variable",
      "code": "class A {\npublic:\n    static int count;\n    A() { count++; }\n};\nint A::count = 0;\nint main() {\n    A a, b, c;\n    cout << A::count;\n}",
      "output": "3",
      "tags": [
        "classes",
        "oop",
        "static"
      ],
      "explanation": {
        "steps": [
          {
            "line": 5,
            "action": "initialize",
            "description": "Static member A::count initialized to 0 once",
            "state": {
              "A::count": 0
            },
            "concepts": [
              "static-member"
            ]
          },
          {
            "line": 6,
            "action": "construct",
            "description": "Create a: count++",
            "state": {
              "A::count": 1
            },
            "concepts": [
              "constructor"
            ]
          },
          {
            "line": 6,
            "action": "construct",
            "description": "Create b: count++",
            "state": {
              "A::count": 2
            }
          },
          {
            "line": 6,
            "action": "construct",
            "description": "Create c: count++",
            "state": {
              "A::count": 3
            }
          },
          {
            "line": 7,
            "action": "output",
            "description": "Output A::count=3",
            "output": "3"
          }
        ],
        "finalOutput": "3",
        "keyInsight": "Static members are shared across all instances; there's only one copy for the entire class"
      }
    },
    {
      "id": "cls-022",
      "categoryId": "classes-constructors",
      "concept": "`this` pointer",
      "code": "class A {\n    int x = 5;\npublic:\n    void show() { cout << this->x; }\n};\nint main() { A a; a.show(); }",
      "output": "5",
      "tags": [
        "classes",
        "oop",
        "pointers"
      ],
      "explanation": {
        "steps": [
          {
            "line": 6,
            "action": "declare",
            "description": "Declare `A a`",
            "concepts": [
              "object-declaration"
            ]
          },
          {
            "line": 6,
            "action": "call",
            "description": "Call a.show()",
            "concepts": [
              "member-function-call"
            ]
          },
          {
            "line": 5,
            "action": "evaluate",
            "description": "`this` points to object a",
            "concepts": [
              "this-pointer"
            ]
          },
          {
            "line": 5,
            "action": "output",
            "description": "Output this->x = 5",
            "output": "5"
          }
        ],
        "finalOutput": "5",
        "keyInsight": "`this` is a pointer to the current object; `this->member` accesses that object's members"
      }
    },
    {
      "id": "cls-023",
      "categoryId": "classes-constructors",
      "concept": "`this->member`",
      "code": "class A {\n    int val;\npublic:\n    A(int val) { this->val = val; }\n    void show() { cout << val; }\n};\nint main() { A a(7); a.show(); }",
      "output": "7",
      "tags": [
        "classes",
        "oop"
      ],
      "explanation": {
        "steps": [
          {
            "line": 6,
            "action": "construct",
            "description": "Create A a(7): parameter val=7",
            "concepts": [
              "constructor"
            ]
          },
          {
            "line": 5,
            "action": "assign",
            "description": "`this->val = val`: disambiguate member from parameter",
            "state": {
              "val": 7
            },
            "concepts": [
              "this-pointer"
            ]
          },
          {
            "line": 7,
            "action": "call",
            "description": "Call a.show()"
          },
          {
            "line": 6,
            "action": "output",
            "description": "Output val=7",
            "output": "7"
          }
        ],
        "finalOutput": "7",
        "keyInsight": "`this->member` distinguishes class member from same-named parameter"
      }
    },
    {
      "id": "cls-024",
      "categoryId": "classes-constructors",
      "concept": "`*this` for chaining",
      "code": "class A {\n    int x = 0;\npublic:\n    A& add(int n) { x += n; return *this; }\n    void show() { cout << x; }\n};\nint main() { A a; a.add(1).add(2).add(3).show(); }",
      "output": "6",
      "tags": [
        "classes",
        "oop",
        "for-loop"
      ],
      "explanation": {
        "steps": [
          {
            "line": 7,
            "action": "declare",
            "description": "Create `A a` with x=0",
            "state": {
              "x": 0
            },
            "concepts": [
              "object-declaration"
            ]
          },
          {
            "line": 7,
            "action": "call",
            "description": "Call a.add(1)",
            "concepts": [
              "method-chaining"
            ]
          },
          {
            "line": 5,
            "action": "evaluate",
            "description": "x += 1, return *this",
            "state": {
              "x": 1
            }
          },
          {
            "line": 7,
            "action": "call",
            "description": "Chain: .add(2)",
            "concepts": [
              "method-chaining"
            ]
          },
          {
            "line": 5,
            "action": "evaluate",
            "description": "x += 2, return *this",
            "state": {
              "x": 3
            }
          },
          {
            "line": 7,
            "action": "call",
            "description": "Chain: .add(3)",
            "concepts": [
              "method-chaining"
            ]
          },
          {
            "line": 5,
            "action": "evaluate",
            "description": "x += 3, return *this",
            "state": {
              "x": 6
            }
          },
          {
            "line": 7,
            "action": "call",
            "description": "Chain: .show()"
          },
          {
            "line": 6,
            "action": "output",
            "description": "Output x=6",
            "output": "6"
          }
        ],
        "finalOutput": "6",
        "keyInsight": "Returning `*this` enables method chaining by returning reference to current object"
      }
    },
    {
      "id": "cls-025",
      "categoryId": "classes-constructors",
      "concept": "Method chaining pattern",
      "code": "class Builder {\n    int val = 0;\npublic:\n    Builder& set(int v) { val = v; return *this; }\n    Builder& inc() { val++; return *this; }\n    void print() { cout << val; }\n};\nint main() { Builder().set(5).inc().inc().print(); }",
      "output": "7",
      "tags": [
        "classes",
        "oop"
      ],
      "explanation": {
        "steps": [
          {
            "line": 7,
            "action": "construct",
            "description": "Create temporary Builder with val=0",
            "state": {
              "val": 0
            },
            "concepts": [
              "temporary-object"
            ]
          },
          {
            "line": 7,
            "action": "call",
            "description": "Chain: .set(5)",
            "concepts": [
              "method-chaining"
            ]
          },
          {
            "line": 5,
            "action": "assign",
            "description": "val = 5, return *this",
            "state": {
              "val": 5
            }
          },
          {
            "line": 7,
            "action": "call",
            "description": "Chain: .inc()"
          },
          {
            "line": 6,
            "action": "evaluate",
            "description": "val++, return *this",
            "state": {
              "val": 6
            }
          },
          {
            "line": 7,
            "action": "call",
            "description": "Chain: .inc()"
          },
          {
            "line": 6,
            "action": "evaluate",
            "description": "val++, return *this",
            "state": {
              "val": 7
            }
          },
          {
            "line": 7,
            "action": "call",
            "description": "Chain: .print()"
          },
          {
            "line": 7,
            "action": "output",
            "description": "Output val=7",
            "output": "7"
          }
        ],
        "finalOutput": "7",
        "keyInsight": "Builder pattern uses method chaining to configure objects fluently"
      }
    },
    {
      "id": "cls-026",
      "categoryId": "classes-constructors",
      "concept": "Assignment operator",
      "code": "class A {\npublic:\n    A() { cout << \"D\"; }\n    A& operator=(const A&) { cout << \"=\"; return *this; }\n};\nint main() { A a, b; a = b; }",
      "output": "DD=",
      "tags": [
        "classes",
        "oop",
        "operators"
      ],
      "explanation": {
        "steps": [
          {
            "line": 6,
            "action": "construct",
            "description": "Create `a` with default constructor",
            "concepts": [
              "default-constructor"
            ]
          },
          {
            "line": 3,
            "action": "output",
            "description": "Output \"D\"",
            "output": "D"
          },
          {
            "line": 6,
            "action": "construct",
            "description": "Create `b` with default constructor",
            "concepts": [
              "default-constructor"
            ]
          },
          {
            "line": 3,
            "action": "output",
            "description": "Output \"D\"",
            "output": "D"
          },
          {
            "line": 6,
            "action": "assign",
            "description": "Execute `a = b` - assignment operator",
            "concepts": [
              "assignment-operator"
            ]
          },
          {
            "line": 4,
            "action": "output",
            "description": "Output \"=\"",
            "output": "="
          }
        ],
        "finalOutput": "DD=",
        "keyInsight": "Assignment operator is called when assigning to an already-constructed object"
      }
    },
    {
      "id": "cls-027",
      "categoryId": "classes-constructors",
      "concept": "Initialization vs assignment distinction",
      "code": "class A {\npublic:\n    A() { cout << \"D\"; }\n    A(const A&) { cout << \"C\"; }\n    A& operator=(const A&) { cout << \"=\"; return *this; }\n};\nint main() {\n    A a;       // Default\n    A b = a;   // Copy constructor (init)\n    A c;       // Default\n    c = a;     // Assignment operator\n}",
      "output": "DCD=",
      "tags": [
        "classes",
        "oop"
      ],
      "explanation": {
        "steps": [
          {
            "line": 7,
            "action": "construct",
            "description": "Create `a` with default constructor",
            "concepts": [
              "default-constructor"
            ]
          },
          {
            "line": 3,
            "action": "output",
            "description": "Output \"D\"",
            "output": "D"
          },
          {
            "line": 8,
            "action": "construct",
            "description": "`A b = a` calls COPY constructor (initialization)",
            "concepts": [
              "copy-constructor"
            ]
          },
          {
            "line": 4,
            "action": "output",
            "description": "Output \"C\"",
            "output": "C"
          },
          {
            "line": 9,
            "action": "construct",
            "description": "Create `c` with default constructor",
            "concepts": [
              "default-constructor"
            ]
          },
          {
            "line": 3,
            "action": "output",
            "description": "Output \"D\"",
            "output": "D"
          },
          {
            "line": 10,
            "action": "assign",
            "description": "`c = a` calls ASSIGNMENT operator",
            "concepts": [
              "assignment-operator"
            ]
          },
          {
            "line": 5,
            "action": "output",
            "description": "Output \"=\"",
            "output": "="
          }
        ],
        "finalOutput": "DCD=",
        "keyInsight": "`Type x = y` calls copy constructor (init); `x = y` on existing object calls assignment operator"
      }
    },
    {
      "id": "op-001",
      "categoryId": "operator-overloading",
      "concept": "`operator++()` pre-increment",
      "code": "class Num {\n    int v;\npublic:\n    Num(int x) : v(x) {}\n    Num& operator++() { ++v; return *this; }\n    int get() { return v; }\n};\nint main() {\n    Num n(5);\n    cout << (++n).get();\n}",
      "output": "6",
      "tags": [
        "operators",
        "oop"
      ],
      "explanation": {
        "steps": [
          {
            "line": 7,
            "action": "construct",
            "description": "Create Num n with v=5",
            "state": {
              "n.v": 5
            },
            "concepts": [
              "constructor"
            ]
          },
          {
            "line": 8,
            "action": "call",
            "description": "Call ++n (pre-increment operator)",
            "concepts": [
              "operator-overload",
              "pre-increment"
            ]
          },
          {
            "line": 5,
            "action": "evaluate",
            "description": "++v: v becomes 6",
            "state": {
              "n.v": 6
            }
          },
          {
            "line": 5,
            "action": "return",
            "description": "Return *this (reference to n)",
            "concepts": [
              "return-reference"
            ]
          },
          {
            "line": 8,
            "action": "call",
            "description": "Call get() on returned reference"
          },
          {
            "line": 8,
            "action": "output",
            "description": "Output 6",
            "output": "6"
          }
        ],
        "finalOutput": "6",
        "keyInsight": "Pre-increment `operator++()` returns reference to modified object"
      }
    },
    {
      "id": "op-002",
      "categoryId": "operator-overloading",
      "concept": "`operator++(int)` post-increment",
      "code": "class Num {\n    int v;\npublic:\n    Num(int x) : v(x) {}\n    Num operator++(int) { Num t = *this; v++; return t; }\n    int get() { return v; }\n};\nint main() {\n    Num n(5);\n    cout << (n++).get() << n.get();\n}",
      "output": "56",
      "tags": [
        "operators",
        "oop"
      ],
      "explanation": {
        "steps": [
          {
            "line": 7,
            "action": "construct",
            "description": "Create Num n with v=5",
            "state": {
              "n.v": 5
            },
            "concepts": [
              "constructor"
            ]
          },
          {
            "line": 8,
            "action": "call",
            "description": "Call n++ (post-increment)",
            "concepts": [
              "operator-overload",
              "post-increment"
            ]
          },
          {
            "line": 5,
            "action": "copy",
            "description": "Save copy: Num t = *this (t.v=5)",
            "state": {
              "t.v": 5
            }
          },
          {
            "line": 5,
            "action": "evaluate",
            "description": "v++: n.v becomes 6",
            "state": {
              "n.v": 6
            }
          },
          {
            "line": 5,
            "action": "return",
            "description": "Return t (copy with old value)",
            "concepts": [
              "return-by-value"
            ]
          },
          {
            "line": 8,
            "action": "call",
            "description": "Call get() on returned copy"
          },
          {
            "line": 8,
            "action": "output",
            "description": "Output 5 (old value)",
            "output": "5"
          },
          {
            "line": 8,
            "action": "call",
            "description": "Call n.get()"
          },
          {
            "line": 8,
            "action": "output",
            "description": "Output 6 (new value)",
            "output": "6"
          }
        ],
        "finalOutput": "56",
        "keyInsight": "Post-increment `operator++(int)` returns copy of OLD value, then increments"
      }
    },
    {
      "id": "op-003",
      "categoryId": "operator-overloading",
      "concept": "Return type difference (reference vs copy)",
      "code": "class Num {\n    int v;\npublic:\n    Num(int x) : v(x) {}\n    Num& operator++() { ++v; cout << \"R\"; return *this; }\n    Num operator++(int) { cout << \"C\"; Num t = *this; v++; return t; }\n};\nint main() { Num n(0); ++n; n++; }",
      "output": "RC",
      "tags": [
        "operators",
        "oop",
        "conditionals",
        "references",
        "copy-semantics"
      ],
      "explanation": {
        "steps": [
          {
            "line": 7,
            "action": "construct",
            "description": "Create Num n with v=0",
            "state": {
              "n.v": 0
            },
            "concepts": [
              "constructor"
            ]
          },
          {
            "line": 7,
            "action": "call",
            "description": "Call ++n (pre-increment)",
            "concepts": [
              "pre-increment"
            ]
          },
          {
            "line": 5,
            "action": "output",
            "description": "Output \"R\" (returns Reference)",
            "output": "R"
          },
          {
            "line": 7,
            "action": "call",
            "description": "Call n++ (post-increment)",
            "concepts": [
              "post-increment"
            ]
          },
          {
            "line": 6,
            "action": "output",
            "description": "Output \"C\" (returns Copy)",
            "output": "C"
          }
        ],
        "finalOutput": "RC",
        "keyInsight": "Pre-increment returns reference (R), post-increment returns copy (C)"
      }
    },
    {
      "id": "op-004",
      "categoryId": "operator-overloading",
      "concept": "Returning reference vs copy",
      "code": "class A {\n    int x = 0;\npublic:\n    A& inc() { x++; return *this; }\n    int get() { return x; }\n};\nint main() {\n    A a;\n    a.inc().inc().inc();\n    cout << a.get();\n}",
      "output": "3",
      "tags": [
        "operators",
        "oop",
        "references",
        "copy-semantics"
      ],
      "explanation": {
        "steps": [
          {
            "line": 6,
            "action": "construct",
            "description": "Create A a with x=0",
            "state": {
              "a.x": 0
            },
            "concepts": [
              "constructor"
            ]
          },
          {
            "line": 7,
            "action": "call",
            "description": "Call a.inc() - returns reference to a",
            "concepts": [
              "method-chaining"
            ]
          },
          {
            "line": 4,
            "action": "evaluate",
            "description": "x++: a.x becomes 1",
            "state": {
              "a.x": 1
            }
          },
          {
            "line": 7,
            "action": "call",
            "description": "Chain: .inc() on same object"
          },
          {
            "line": 4,
            "action": "evaluate",
            "description": "x++: a.x becomes 2",
            "state": {
              "a.x": 2
            }
          },
          {
            "line": 7,
            "action": "call",
            "description": "Chain: .inc() on same object"
          },
          {
            "line": 4,
            "action": "evaluate",
            "description": "x++: a.x becomes 3",
            "state": {
              "a.x": 3
            }
          },
          {
            "line": 8,
            "action": "output",
            "description": "Output a.get()=3",
            "output": "3"
          }
        ],
        "finalOutput": "3",
        "keyInsight": "Returning `*this` (reference) enables method chaining on the same object"
      }
    },
    {
      "id": "op-005",
      "categoryId": "operator-overloading",
      "concept": "Member `operator+`",
      "code": "class Num {\n    int v;\npublic:\n    Num(int x) : v(x) {}\n    Num operator+(const Num& r) { return Num(v + r.v); }\n    int get() { return v; }\n};\nint main() { cout << (Num(3) + Num(4)).get(); }",
      "output": "7",
      "tags": [
        "operators",
        "oop"
      ],
      "explanation": {
        "steps": [
          {
            "line": 7,
            "action": "construct",
            "description": "Create Num(3) and Num(4)",
            "concepts": [
              "constructor"
            ]
          },
          {
            "line": 7,
            "action": "call",
            "description": "Call operator+: Num(3) + Num(4)",
            "concepts": [
              "operator-overload"
            ]
          },
          {
            "line": 5,
            "action": "evaluate",
            "description": "v + r.v = 3 + 4 = 7",
            "concepts": [
              "binary-operator"
            ]
          },
          {
            "line": 5,
            "action": "return",
            "description": "Return Num(7)",
            "concepts": [
              "return-by-value"
            ]
          },
          {
            "line": 7,
            "action": "output",
            "description": "Output get()=7",
            "output": "7"
          }
        ],
        "finalOutput": "7",
        "keyInsight": "Member `operator+` takes right operand as parameter; left operand is `this`"
      }
    },
    {
      "id": "op-006",
      "categoryId": "operator-overloading",
      "concept": "Left operand must be object",
      "code": "class Num {\n    int v;\npublic:\n    Num(int x) : v(x) {}\n    Num operator+(int r) { return Num(v + r); }\n    int get() { return v; }\n};\nint main() {\n    Num a(5);\n    cout << (a + 3).get();\n    // cout << (3 + a).get();  // Error: int has no operator+(Num)\n}",
      "output": "8",
      "tags": [
        "operators",
        "oop"
      ],
      "explanation": {
        "steps": [
          {
            "line": 6,
            "action": "construct",
            "description": "Create Num a(5)",
            "state": {
              "a.v": 5
            },
            "concepts": [
              "constructor"
            ]
          },
          {
            "line": 7,
            "action": "call",
            "description": "Call a + 3: a.operator+(3)",
            "concepts": [
              "operator-overload"
            ]
          },
          {
            "line": 4,
            "action": "evaluate",
            "description": "v + r = 5 + 3 = 8"
          },
          {
            "line": 7,
            "action": "output",
            "description": "Output 8",
            "output": "8"
          }
        ],
        "finalOutput": "8",
        "keyInsight": "Member operator requires object on LEFT side; `3 + a` would fail"
      }
    },
    {
      "id": "op-007",
      "categoryId": "operator-overloading",
      "concept": "`a + b` vs `2 + a` difference",
      "code": "class Num {\npublic:\n    int v;\n    Num(int x) : v(x) {}\n    Num operator+(const Num& r) const { return Num(v + r.v); }\n};\nint main() {\n    Num a(5);\n    cout << (a + Num(3)).v;  // OK\n    // 3 + a would fail without non-member operator\n}",
      "output": "8",
      "tags": [
        "operators",
        "oop",
        "conditionals"
      ],
      "explanation": {
        "steps": [
          {
            "line": 6,
            "action": "construct",
            "description": "Create Num a(5)",
            "state": {
              "a.v": 5
            },
            "concepts": [
              "constructor"
            ]
          },
          {
            "line": 7,
            "action": "call",
            "description": "a + Num(3): left operand is object",
            "concepts": [
              "operator-overload"
            ]
          },
          {
            "line": 5,
            "action": "evaluate",
            "description": "v + r.v = 5 + 3 = 8"
          },
          {
            "line": 7,
            "action": "output",
            "description": "Output 8",
            "output": "8"
          }
        ],
        "finalOutput": "8",
        "keyInsight": "For symmetric operators, non-member functions allow `int + Obj` operations"
      }
    },
    {
      "id": "op-008",
      "categoryId": "operator-overloading",
      "concept": "Implementing `operator+` using `operator+=`",
      "code": "class Num {\n    int v;\npublic:\n    Num(int x) : v(x) {}\n    Num& operator+=(const Num& r) { v += r.v; return *this; }\n    Num operator+(const Num& r) const { Num t = *this; t += r; return t; }\n    int get() { return v; }\n};\nint main() { cout << (Num(2) + Num(3)).get(); }",
      "output": "5",
      "tags": [
        "operators",
        "oop"
      ],
      "explanation": {
        "steps": [
          {
            "line": 8,
            "action": "construct",
            "description": "Create Num(2) and Num(3)",
            "concepts": [
              "constructor"
            ]
          },
          {
            "line": 8,
            "action": "call",
            "description": "Call operator+",
            "concepts": [
              "operator-overload"
            ]
          },
          {
            "line": 6,
            "action": "copy",
            "description": "Create copy t = Num(2)",
            "state": {
              "t.v": 2
            }
          },
          {
            "line": 6,
            "action": "call",
            "description": "Call t += Num(3)",
            "concepts": [
              "compound-assignment"
            ]
          },
          {
            "line": 5,
            "action": "evaluate",
            "description": "t.v += 3: t.v becomes 5",
            "state": {
              "t.v": 5
            }
          },
          {
            "line": 6,
            "action": "return",
            "description": "Return t"
          },
          {
            "line": 8,
            "action": "output",
            "description": "Output 5",
            "output": "5"
          }
        ],
        "finalOutput": "5",
        "keyInsight": "Implement `operator+` using `operator+=` to avoid code duplication"
      }
    },
    {
      "id": "op-009",
      "categoryId": "operator-overloading",
      "concept": "Compound assignment",
      "code": "class Num {\n    int v;\npublic:\n    Num(int x) : v(x) {}\n    Num& operator+=(int x) { v += x; return *this; }\n    int get() { return v; }\n};\nint main() { Num n(5); n += 3; cout << n.get(); }",
      "output": "8",
      "tags": [
        "operators",
        "oop"
      ],
      "explanation": {
        "steps": [
          {
            "line": 7,
            "action": "construct",
            "description": "Create Num n(5)",
            "state": {
              "n.v": 5
            },
            "concepts": [
              "constructor"
            ]
          },
          {
            "line": 7,
            "action": "call",
            "description": "Call n += 3",
            "concepts": [
              "compound-assignment"
            ]
          },
          {
            "line": 5,
            "action": "evaluate",
            "description": "v += 3: v becomes 8",
            "state": {
              "n.v": 8
            }
          },
          {
            "line": 5,
            "action": "return",
            "description": "Return *this"
          },
          {
            "line": 7,
            "action": "output",
            "description": "Output 8",
            "output": "8"
          }
        ],
        "finalOutput": "8",
        "keyInsight": "Compound assignment `+=` modifies in-place and returns reference for chaining"
      }
    },
    {
      "id": "op-010",
      "categoryId": "operator-overloading",
      "concept": "Avoiding code duplication",
      "code": "class Num {\n    int v;\npublic:\n    Num(int x) : v(x) {}\n    Num& operator*=(int x) { v *= x; return *this; }\n    Num operator*(int x) const { Num t = *this; t *= x; return t; }\n    int get() { return v; }\n};\nint main() { cout << (Num(4) * 3).get(); }",
      "output": "12",
      "tags": [
        "operators",
        "oop"
      ],
      "explanation": {
        "steps": [
          {
            "line": 8,
            "action": "construct",
            "description": "Create Num(4)",
            "state": {
              "v": 4
            },
            "concepts": [
              "constructor"
            ]
          },
          {
            "line": 8,
            "action": "call",
            "description": "Call operator*(3)",
            "concepts": [
              "operator-overload"
            ]
          },
          {
            "line": 6,
            "action": "copy",
            "description": "Create copy t = Num(4)"
          },
          {
            "line": 6,
            "action": "call",
            "description": "Call t *= 3"
          },
          {
            "line": 5,
            "action": "evaluate",
            "description": "t.v *= 3: t.v becomes 12",
            "state": {
              "t.v": 12
            }
          },
          {
            "line": 8,
            "action": "output",
            "description": "Output 12",
            "output": "12"
          }
        ],
        "finalOutput": "12",
        "keyInsight": "Define `*=` first, then implement `*` by copying and using `*=`"
      }
    },
    {
      "id": "op-011",
      "categoryId": "operator-overloading",
      "concept": "`operator=` overload",
      "code": "class A {\n    int x;\npublic:\n    A(int v) : x(v) {}\n    A& operator=(const A& r) { x = r.x; cout << \"=\"; return *this; }\n};\nint main() { A a(1), b(2); a = b; }",
      "output": "=",
      "tags": [
        "operators",
        "oop"
      ],
      "explanation": {
        "steps": [
          {
            "line": 6,
            "action": "construct",
            "description": "Create A a(1), b(2)",
            "concepts": [
              "constructor"
            ]
          },
          {
            "line": 6,
            "action": "call",
            "description": "Call a = b (assignment operator)",
            "concepts": [
              "assignment-operator"
            ]
          },
          {
            "line": 5,
            "action": "assign",
            "description": "x = r.x: a.x = 2",
            "state": {
              "a.x": 2
            }
          },
          {
            "line": 5,
            "action": "output",
            "description": "Output \"=\"",
            "output": "="
          }
        ],
        "finalOutput": "=",
        "keyInsight": "Assignment operator is called when assigning to existing object"
      }
    },
    {
      "id": "op-012",
      "categoryId": "operator-overloading",
      "concept": "Right-associativity of assignment",
      "code": "class A {\n    int x;\npublic:\n    A(int v) : x(v) {}\n    A& operator=(const A& r) { x = r.x; cout << x; return *this; }\n};\nint main() { A a(1), b(2), c(3); a = b = c; }",
      "output": "33",
      "tags": [
        "operators",
        "oop"
      ],
      "explanation": {
        "steps": [
          {
            "line": 6,
            "action": "construct",
            "description": "Create a(1), b(2), c(3)",
            "concepts": [
              "constructor"
            ]
          },
          {
            "line": 6,
            "action": "call",
            "description": "Evaluate `a = b = c` right-to-left",
            "concepts": [
              "right-associativity"
            ]
          },
          {
            "line": 6,
            "action": "call",
            "description": "First: b = c (b.x becomes 3)",
            "state": {
              "b.x": 3
            }
          },
          {
            "line": 5,
            "action": "output",
            "description": "Output 3",
            "output": "3"
          },
          {
            "line": 6,
            "action": "call",
            "description": "Then: a = b (a.x becomes 3)",
            "state": {
              "a.x": 3
            }
          },
          {
            "line": 5,
            "action": "output",
            "description": "Output 3",
            "output": "3"
          }
        ],
        "finalOutput": "33",
        "keyInsight": "Assignment is right-associative: `a = b = c` evaluates as `a = (b = c)`"
      }
    },
    {
      "id": "op-013",
      "categoryId": "operator-overloading",
      "concept": "Returning `*this` for chaining",
      "code": "class A {\npublic:\n    int v;\n    A(int x) : v(x) {}\n    A& operator=(int x) { v = x; return *this; }\n};\nint main() {\n    A a(0), b(0), c(0);\n    a = b = c = 5;\n    cout << a.v << b.v << c.v;\n}",
      "output": "555",
      "tags": [
        "operators",
        "oop",
        "for-loop"
      ],
      "explanation": {
        "steps": [
          {
            "line": 6,
            "action": "construct",
            "description": "Create a(0), b(0), c(0)",
            "concepts": [
              "constructor"
            ]
          },
          {
            "line": 7,
            "action": "call",
            "description": "Chain: a = b = c = 5",
            "concepts": [
              "assignment-chaining"
            ]
          },
          {
            "line": 7,
            "action": "call",
            "description": "c = 5: c.v = 5, returns c",
            "state": {
              "c.v": 5
            }
          },
          {
            "line": 7,
            "action": "call",
            "description": "b = c: b.v = 5, returns b",
            "state": {
              "b.v": 5
            }
          },
          {
            "line": 7,
            "action": "call",
            "description": "a = b: a.v = 5, returns a",
            "state": {
              "a.v": 5
            }
          },
          {
            "line": 8,
            "action": "output",
            "description": "Output a.v=5, b.v=5, c.v=5",
            "output": "555"
          }
        ],
        "finalOutput": "555",
        "keyInsight": "Returning `*this` enables assignment chaining: `a = b = c = value`"
      }
    },
    {
      "id": "op-014",
      "categoryId": "operator-overloading",
      "concept": "`operator<`",
      "code": "class Num {\n    int v;\npublic:\n    Num(int x) : v(x) {}\n    bool operator<(const Num& r) const { return v < r.v; }\n};\nint main() { cout << (Num(3) < Num(5)); }",
      "output": "1",
      "tags": [
        "operators",
        "oop"
      ],
      "explanation": {
        "steps": [
          {
            "line": 6,
            "action": "construct",
            "description": "Create Num(3) and Num(5)",
            "concepts": [
              "constructor"
            ]
          },
          {
            "line": 6,
            "action": "call",
            "description": "Call operator<",
            "concepts": [
              "comparison-operator"
            ]
          },
          {
            "line": 5,
            "action": "evaluate",
            "description": "v < r.v: 3 < 5 = true"
          },
          {
            "line": 6,
            "action": "output",
            "description": "Output 1 (true)",
            "output": "1"
          }
        ],
        "finalOutput": "1",
        "keyInsight": "Comparison operators return bool; used for sorting and ordering"
      }
    },
    {
      "id": "op-015",
      "categoryId": "operator-overloading",
      "concept": "`operator==`",
      "code": "class Num {\n    int v;\npublic:\n    Num(int x) : v(x) {}\n    bool operator==(const Num& r) const { return v == r.v; }\n};\nint main() { cout << (Num(5) == Num(5)) << (Num(5) == Num(3)); }",
      "output": "10",
      "tags": [
        "operators",
        "oop"
      ],
      "explanation": {
        "steps": [
          {
            "line": 6,
            "action": "call",
            "description": "Num(5) == Num(5)",
            "concepts": [
              "equality-operator"
            ]
          },
          {
            "line": 5,
            "action": "evaluate",
            "description": "5 == 5: true"
          },
          {
            "line": 6,
            "action": "output",
            "description": "Output 1",
            "output": "1"
          },
          {
            "line": 6,
            "action": "call",
            "description": "Num(5) == Num(3)"
          },
          {
            "line": 5,
            "action": "evaluate",
            "description": "5 == 3: false"
          },
          {
            "line": 6,
            "action": "output",
            "description": "Output 0",
            "output": "0"
          }
        ],
        "finalOutput": "10",
        "keyInsight": "Equality operator returns bool: true (1) for equal, false (0) for not equal"
      }
    },
    {
      "id": "op-016",
      "categoryId": "operator-overloading",
      "concept": "Bool return type",
      "code": "class A {\npublic:\n    bool operator>(const A&) const { return true; }\n};\nint main() {\n    A a, b;\n    bool result = a > b;\n    cout << result;\n}",
      "output": "1",
      "tags": [
        "operators",
        "oop"
      ],
      "explanation": {
        "steps": [
          {
            "line": 4,
            "action": "construct",
            "description": "Create A a, b",
            "concepts": [
              "constructor"
            ]
          },
          {
            "line": 5,
            "action": "call",
            "description": "Call a > b",
            "concepts": [
              "comparison-operator"
            ]
          },
          {
            "line": 3,
            "action": "return",
            "description": "Always returns true"
          },
          {
            "line": 6,
            "action": "output",
            "description": "Output 1",
            "output": "1"
          }
        ],
        "finalOutput": "1",
        "keyInsight": "Comparison operators return bool; can be stored in bool variables"
      }
    },
    {
      "id": "op-017",
      "categoryId": "operator-overloading",
      "concept": "Bool prints as 1/0",
      "code": "int main() {\n    cout << true << false << (5 > 3) << (2 > 7);\n}",
      "output": "1010",
      "tags": [
        "operators",
        "oop"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "output",
            "description": "Output true (1)",
            "output": "1"
          },
          {
            "line": 2,
            "action": "output",
            "description": "Output false (0)",
            "output": "0"
          },
          {
            "line": 2,
            "action": "evaluate",
            "description": "5 > 3 = true"
          },
          {
            "line": 2,
            "action": "output",
            "description": "Output 1",
            "output": "1"
          },
          {
            "line": 2,
            "action": "evaluate",
            "description": "2 > 7 = false"
          },
          {
            "line": 2,
            "action": "output",
            "description": "Output 0",
            "output": "0"
          }
        ],
        "finalOutput": "1010",
        "keyInsight": "Boolean values print as integers: true = 1, false = 0"
      }
    },
    {
      "id": "op-018",
      "categoryId": "operator-overloading",
      "concept": "`friend` function",
      "code": "class A {\n    int x = 42;\n    friend void show(const A& a);\n};\nvoid show(const A& a) { cout << a.x; }\nint main() { A a; show(a); }",
      "output": "42",
      "tags": [
        "operators",
        "oop"
      ],
      "explanation": {
        "steps": [
          {
            "line": 5,
            "action": "construct",
            "description": "Create A a with x=42",
            "state": {
              "a.x": 42
            },
            "concepts": [
              "constructor"
            ]
          },
          {
            "line": 5,
            "action": "call",
            "description": "Call show(a)",
            "concepts": [
              "friend-function"
            ]
          },
          {
            "line": 4,
            "action": "evaluate",
            "description": "Friend function accesses private a.x",
            "concepts": [
              "friend-access"
            ]
          },
          {
            "line": 4,
            "action": "output",
            "description": "Output 42",
            "output": "42"
          }
        ],
        "finalOutput": "42",
        "keyInsight": "Friend functions can access private members; used for operators like `<<`"
      }
    },
    {
      "id": "op-019",
      "categoryId": "operator-overloading",
      "concept": "`operator<<` overload",
      "code": "class Num {\npublic:\n    int v;\n    Num(int x) : v(x) {}\n    friend ostream& operator<<(ostream& os, const Num& n);\n};\nostream& operator<<(ostream& os, const Num& n) { os << n.v; return os; }\nint main() { cout << Num(7); }",
      "output": "7",
      "tags": [
        "operators",
        "oop"
      ],
      "explanation": {
        "steps": [
          {
            "line": 7,
            "action": "construct",
            "description": "Create Num(7)",
            "state": {
              "v": 7
            },
            "concepts": [
              "constructor"
            ]
          },
          {
            "line": 7,
            "action": "call",
            "description": "cout << Num(7)",
            "concepts": [
              "stream-operator"
            ]
          },
          {
            "line": 6,
            "action": "evaluate",
            "description": "os << n.v: output 7",
            "output": "7"
          },
          {
            "line": 6,
            "action": "return",
            "description": "Return os for chaining"
          }
        ],
        "finalOutput": "7",
        "keyInsight": "`operator<<` must be non-member (or friend) since left operand is ostream"
      }
    },
    {
      "id": "op-020",
      "categoryId": "operator-overloading",
      "concept": "Non-member for ostream",
      "code": "class Point {\npublic:\n    int x, y;\n    Point(int a, int b) : x(a), y(b) {}\n};\nostream& operator<<(ostream& os, const Point& p) {\n    return os << \"(\" << p.x << \",\" << p.y << \")\";\n}\nint main() { cout << Point(3, 4); }",
      "output": "(3,4)",
      "tags": [
        "operators",
        "oop",
        "for-loop"
      ],
      "explanation": {
        "steps": [
          {
            "line": 7,
            "action": "construct",
            "description": "Create Point(3, 4)",
            "state": {
              "x": 3,
              "y": 4
            },
            "concepts": [
              "constructor"
            ]
          },
          {
            "line": 7,
            "action": "call",
            "description": "cout << Point(3,4)",
            "concepts": [
              "stream-operator"
            ]
          },
          {
            "line": 5,
            "action": "output",
            "description": "Output formatted: (3,4)",
            "output": "(3,4)"
          }
        ],
        "finalOutput": "(3,4)",
        "keyInsight": "Non-member `operator<<` allows custom formatting for user-defined types"
      }
    },
    {
      "id": "op-021",
      "categoryId": "operator-overloading",
      "concept": "Returning `ostream&` for chaining",
      "code": "class N { public: int v; N(int x) : v(x) {} };\nostream& operator<<(ostream& os, const N& n) { return os << n.v; }\nint main() { cout << N(1) << N(2) << N(3); }",
      "output": "123",
      "tags": [
        "operators",
        "oop",
        "for-loop"
      ],
      "explanation": {
        "steps": [
          {
            "line": 3,
            "action": "call",
            "description": "cout << N(1)",
            "concepts": [
              "stream-operator"
            ]
          },
          {
            "line": 2,
            "action": "output",
            "description": "Output 1, return os",
            "output": "1"
          },
          {
            "line": 3,
            "action": "call",
            "description": "Chain: << N(2)",
            "concepts": [
              "chaining"
            ]
          },
          {
            "line": 2,
            "action": "output",
            "description": "Output 2, return os",
            "output": "2"
          },
          {
            "line": 3,
            "action": "call",
            "description": "Chain: << N(3)"
          },
          {
            "line": 2,
            "action": "output",
            "description": "Output 3",
            "output": "3"
          }
        ],
        "finalOutput": "123",
        "keyInsight": "Returning `ostream&` enables chaining: `cout << a << b << c`"
      }
    },
    {
      "id": "op-022",
      "categoryId": "operator-overloading",
      "concept": "`operator[]` overload",
      "code": "class Arr {\n    int data[3] = {10, 20, 30};\npublic:\n    int& operator[](int i) { return data[i]; }\n};\nint main() { Arr a; cout << a[1]; }",
      "output": "20",
      "tags": [
        "operators",
        "oop"
      ],
      "explanation": {
        "steps": [
          {
            "line": 5,
            "action": "construct",
            "description": "Create Arr a with data={10,20,30}",
            "concepts": [
              "constructor"
            ]
          },
          {
            "line": 5,
            "action": "call",
            "description": "Access a[1]",
            "concepts": [
              "subscript-operator"
            ]
          },
          {
            "line": 4,
            "action": "return",
            "description": "Return reference to data[1]"
          },
          {
            "line": 5,
            "action": "output",
            "description": "Output 20",
            "output": "20"
          }
        ],
        "finalOutput": "20",
        "keyInsight": "`operator[]` provides array-like access to custom containers"
      }
    },
    {
      "id": "op-023",
      "categoryId": "operator-overloading",
      "concept": "Const and non-const versions",
      "code": "class Arr {\n    int d[2] = {1, 2};\npublic:\n    int& operator[](int i) { cout << \"N\"; return d[i]; }\n    const int& operator[](int i) const { cout << \"C\"; return d[i]; }\n};\nint main() {\n    Arr a;\n    const Arr b;\n    a[0]; b[0];\n}",
      "output": "NC",
      "tags": [
        "operators",
        "oop",
        "const"
      ],
      "explanation": {
        "steps": [
          {
            "line": 7,
            "action": "construct",
            "description": "Create non-const Arr a",
            "concepts": [
              "constructor"
            ]
          },
          {
            "line": 8,
            "action": "construct",
            "description": "Create const Arr b",
            "concepts": [
              "const-object"
            ]
          },
          {
            "line": 9,
            "action": "call",
            "description": "a[0]: calls non-const version",
            "concepts": [
              "subscript-operator"
            ]
          },
          {
            "line": 5,
            "action": "output",
            "description": "Output \"N\"",
            "output": "N"
          },
          {
            "line": 9,
            "action": "call",
            "description": "b[0]: calls const version",
            "concepts": [
              "const-subscript"
            ]
          },
          {
            "line": 6,
            "action": "output",
            "description": "Output \"C\"",
            "output": "C"
          }
        ],
        "finalOutput": "NC",
        "keyInsight": "Provide both const and non-const `operator[]` for read/write access"
      }
    },
    {
      "id": "op-024",
      "categoryId": "operator-overloading",
      "concept": "Returning reference for assignment",
      "code": "class Arr {\n    int d[3] = {0, 0, 0};\npublic:\n    int& operator[](int i) { return d[i]; }\n};\nint main() {\n    Arr a;\n    a[1] = 99;\n    cout << a[1];\n}",
      "output": "99",
      "tags": [
        "operators",
        "oop",
        "for-loop",
        "references"
      ],
      "explanation": {
        "steps": [
          {
            "line": 5,
            "action": "construct",
            "description": "Create Arr a with d={0,0,0}",
            "concepts": [
              "constructor"
            ]
          },
          {
            "line": 6,
            "action": "call",
            "description": "a[1] = 99: get reference",
            "concepts": [
              "subscript-operator"
            ]
          },
          {
            "line": 4,
            "action": "return",
            "description": "Return reference to d[1]"
          },
          {
            "line": 6,
            "action": "assign",
            "description": "Assign 99 through reference",
            "state": {
              "d[1]": 99
            }
          },
          {
            "line": 7,
            "action": "output",
            "description": "Output a[1]=99",
            "output": "99"
          }
        ],
        "finalOutput": "99",
        "keyInsight": "Returning reference allows `obj[i] = value` assignment"
      }
    },
    {
      "id": "op-025",
      "categoryId": "operator-overloading",
      "concept": "Unary `operator-`",
      "code": "class Num {\n    int v;\npublic:\n    Num(int x) : v(x) {}\n    Num operator-() const { return Num(-v); }\n    int get() { return v; }\n};\nint main() { cout << (-Num(5)).get(); }",
      "output": "-5",
      "tags": [
        "operators",
        "oop"
      ],
      "explanation": {
        "steps": [
          {
            "line": 7,
            "action": "construct",
            "description": "Create Num(5)",
            "state": {
              "v": 5
            },
            "concepts": [
              "constructor"
            ]
          },
          {
            "line": 7,
            "action": "call",
            "description": "Call -Num(5) (unary minus)",
            "concepts": [
              "unary-operator"
            ]
          },
          {
            "line": 5,
            "action": "return",
            "description": "Return Num(-5)",
            "concepts": [
              "return-by-value"
            ]
          },
          {
            "line": 7,
            "action": "output",
            "description": "Output -5",
            "output": "-5"
          }
        ],
        "finalOutput": "-5",
        "keyInsight": "Unary `operator-` returns a new object with negated value"
      }
    },
    {
      "id": "op-026",
      "categoryId": "operator-overloading",
      "concept": "Returns new object (original unchanged)",
      "code": "class Num {\npublic:\n    int v;\n    Num(int x) : v(x) {}\n    Num operator-() const { return Num(-v); }\n};\nint main() {\n    Num a(5);\n    Num b = -a;\n    cout << a.v << b.v;\n}",
      "output": "5-5",
      "tags": [
        "operators",
        "oop",
        "dynamic-memory"
      ],
      "explanation": {
        "steps": [
          {
            "line": 6,
            "action": "construct",
            "description": "Create Num a(5)",
            "state": {
              "a.v": 5
            },
            "concepts": [
              "constructor"
            ]
          },
          {
            "line": 7,
            "action": "call",
            "description": "Num b = -a",
            "concepts": [
              "unary-operator"
            ]
          },
          {
            "line": 5,
            "action": "return",
            "description": "Return new Num(-5), a unchanged",
            "state": {
              "b.v": -5
            }
          },
          {
            "line": 8,
            "action": "output",
            "description": "Output a.v=5, b.v=-5",
            "output": "5-5"
          }
        ],
        "finalOutput": "5-5",
        "keyInsight": "Unary operators return NEW object; original is not modified"
      }
    },
    {
      "id": "op-027",
      "categoryId": "operator-overloading",
      "concept": "`const` member for operators",
      "code": "class Num {\n    int v;\npublic:\n    Num(int x) : v(x) {}\n    Num operator+(const Num& r) const { return Num(v + r.v); }\n    int get() const { return v; }\n};\nint main() {\n    const Num a(3), b(4);\n    cout << (a + b).get();\n}",
      "output": "7",
      "tags": [
        "operators",
        "oop",
        "for-loop",
        "const"
      ],
      "explanation": {
        "steps": [
          {
            "line": 7,
            "action": "construct",
            "description": "Create const Num a(3), b(4)",
            "concepts": [
              "const-object"
            ]
          },
          {
            "line": 8,
            "action": "call",
            "description": "Call a + b (const operator)",
            "concepts": [
              "const-operator"
            ]
          },
          {
            "line": 5,
            "action": "evaluate",
            "description": "v + r.v = 3 + 4 = 7"
          },
          {
            "line": 8,
            "action": "output",
            "description": "Output 7",
            "output": "7"
          }
        ],
        "finalOutput": "7",
        "keyInsight": "Const operators can be called on const objects; essential for immutable usage"
      }
    },
    {
      "id": "op-028",
      "categoryId": "operator-overloading",
      "concept": "`operator()` overload",
      "code": "class Adder {\n    int base;\npublic:\n    Adder(int b) : base(b) {}\n    int operator()(int x) { return base + x; }\n};\nint main() {\n    Adder add5(5);\n    cout << add5(3);\n}",
      "output": "8",
      "tags": [
        "operators",
        "oop"
      ],
      "explanation": {
        "steps": [
          {
            "line": 6,
            "action": "construct",
            "description": "Create Adder add5 with base=5",
            "state": {
              "base": 5
            },
            "concepts": [
              "constructor"
            ]
          },
          {
            "line": 7,
            "action": "call",
            "description": "Call add5(3) - uses operator()",
            "concepts": [
              "function-call-operator"
            ]
          },
          {
            "line": 5,
            "action": "evaluate",
            "description": "base + x = 5 + 3 = 8"
          },
          {
            "line": 7,
            "action": "output",
            "description": "Output 8",
            "output": "8"
          }
        ],
        "finalOutput": "8",
        "keyInsight": "`operator()` makes objects callable like functions (functor pattern)"
      }
    },
    {
      "id": "op-029",
      "categoryId": "operator-overloading",
      "concept": "Functor pattern",
      "code": "class Multiplier {\n    int factor;\npublic:\n    Multiplier(int f) : factor(f) {}\n    int operator()(int x) const { return x * factor; }\n};\nint main() {\n    Multiplier triple(3);\n    cout << triple(4);\n}",
      "output": "12",
      "tags": [
        "operators",
        "oop"
      ],
      "explanation": {
        "steps": [
          {
            "line": 6,
            "action": "construct",
            "description": "Create Multiplier triple with factor=3",
            "state": {
              "factor": 3
            },
            "concepts": [
              "constructor"
            ]
          },
          {
            "line": 7,
            "action": "call",
            "description": "Call triple(4)",
            "concepts": [
              "functor"
            ]
          },
          {
            "line": 5,
            "action": "evaluate",
            "description": "x * factor = 4 * 3 = 12"
          },
          {
            "line": 7,
            "action": "output",
            "description": "Output 12",
            "output": "12"
          }
        ],
        "finalOutput": "12",
        "keyInsight": "Functors are objects that behave like functions; can maintain state"
      }
    },
    {
      "id": "op-030",
      "categoryId": "operator-overloading",
      "concept": "Object as callable",
      "code": "class Counter {\n    int count = 0;\npublic:\n    int operator()() { return ++count; }\n};\nint main() {\n    Counter c;\n    cout << c() << c() << c();\n}",
      "output": "123",
      "tags": [
        "operators",
        "oop"
      ],
      "explanation": {
        "steps": [
          {
            "line": 5,
            "action": "construct",
            "description": "Create Counter c with count=0",
            "state": {
              "count": 0
            },
            "concepts": [
              "constructor"
            ]
          },
          {
            "line": 6,
            "action": "call",
            "description": "Call c() first time",
            "concepts": [
              "functor"
            ]
          },
          {
            "line": 4,
            "action": "evaluate",
            "description": "Return ++count = 1",
            "state": {
              "count": 1
            }
          },
          {
            "line": 6,
            "action": "output",
            "description": "Output 1",
            "output": "1"
          },
          {
            "line": 6,
            "action": "call",
            "description": "Call c() second time"
          },
          {
            "line": 4,
            "action": "evaluate",
            "description": "Return ++count = 2",
            "state": {
              "count": 2
            }
          },
          {
            "line": 6,
            "action": "output",
            "description": "Output 2",
            "output": "2"
          },
          {
            "line": 6,
            "action": "call",
            "description": "Call c() third time"
          },
          {
            "line": 4,
            "action": "evaluate",
            "description": "Return ++count = 3",
            "state": {
              "count": 3
            }
          },
          {
            "line": 6,
            "action": "output",
            "description": "Output 3",
            "output": "3"
          }
        ],
        "finalOutput": "123",
        "keyInsight": "Functors can maintain state between calls; useful for counters, accumulators"
      }
    },
    {
      "id": "inh-001",
      "categoryId": "inheritance-polymorphism",
      "concept": "Inheritance concept",
      "code": "class Base { public: void f() { cout << \"B\"; } };\nclass Derived : public Base {};\nint main() { Derived d; d.f(); }",
      "output": "B",
      "tags": [
        "inheritance",
        "polymorphism",
        "oop"
      ],
      "explanation": {
        "steps": [
          {
            "line": 3,
            "action": "construct",
            "description": "Create Derived d (inherits from Base)",
            "concepts": [
              "inheritance"
            ]
          },
          {
            "line": 3,
            "action": "call",
            "description": "Call d.f() - inherited from Base",
            "concepts": [
              "inherited-member"
            ]
          },
          {
            "line": 1,
            "action": "output",
            "description": "Output \"B\"",
            "output": "B"
          }
        ],
        "finalOutput": "B",
        "keyInsight": "Derived class inherits all public members from Base class"
      }
    },
    {
      "id": "inh-002",
      "categoryId": "inheritance-polymorphism",
      "concept": "Base constructor called first",
      "code": "class Base { public: Base() { cout << \"B\"; } };\nclass Derived : public Base { public: Derived() { cout << \"D\"; } };\nint main() { Derived d; }",
      "output": "BD",
      "tags": [
        "inheritance",
        "polymorphism",
        "oop",
        "const",
        "constructors"
      ],
      "explanation": {
        "steps": [
          {
            "line": 3,
            "action": "construct",
            "description": "Create Derived d",
            "concepts": [
              "inheritance"
            ]
          },
          {
            "line": 1,
            "action": "construct",
            "description": "Base constructor runs FIRST",
            "concepts": [
              "base-constructor"
            ]
          },
          {
            "line": 1,
            "action": "output",
            "description": "Output \"B\"",
            "output": "B"
          },
          {
            "line": 2,
            "action": "construct",
            "description": "Derived constructor runs SECOND",
            "concepts": [
              "derived-constructor"
            ]
          },
          {
            "line": 2,
            "action": "output",
            "description": "Output \"D\"",
            "output": "D"
          }
        ],
        "finalOutput": "BD",
        "keyInsight": "Base class constructor is called before derived class constructor"
      }
    },
    {
      "id": "inh-003",
      "categoryId": "inheritance-polymorphism",
      "concept": "Derived constructor second",
      "code": "class A { public: A() { cout << \"1\"; } };\nclass B : public A { public: B() { cout << \"2\"; } };\nclass C : public B { public: C() { cout << \"3\"; } };\nint main() { C c; }",
      "output": "123",
      "tags": [
        "inheritance",
        "polymorphism",
        "oop",
        "const",
        "constructors"
      ],
      "explanation": {
        "steps": [
          {
            "line": 4,
            "action": "construct",
            "description": "Create C (inherits from B which inherits from A)",
            "concepts": [
              "multi-level-inheritance"
            ]
          },
          {
            "line": 1,
            "action": "construct",
            "description": "A constructor (topmost base)",
            "concepts": [
              "base-constructor"
            ]
          },
          {
            "line": 1,
            "action": "output",
            "description": "Output \"1\"",
            "output": "1"
          },
          {
            "line": 2,
            "action": "construct",
            "description": "B constructor",
            "concepts": [
              "derived-constructor"
            ]
          },
          {
            "line": 2,
            "action": "output",
            "description": "Output \"2\"",
            "output": "2"
          },
          {
            "line": 3,
            "action": "construct",
            "description": "C constructor (most derived)",
            "concepts": [
              "derived-constructor"
            ]
          },
          {
            "line": 3,
            "action": "output",
            "description": "Output \"3\"",
            "output": "3"
          }
        ],
        "finalOutput": "123",
        "keyInsight": "Constructors run top-down: base classes before derived classes"
      }
    },
    {
      "id": "inh-004",
      "categoryId": "inheritance-polymorphism",
      "concept": "Destructor order reversed from constructor",
      "code": "class Base {\npublic:\n    Base() { cout << \"+B\"; }\n    ~Base() { cout << \"-B\"; }\n};\nclass Derived : public Base {\npublic:\n    Derived() { cout << \"+D\"; }\n    ~Derived() { cout << \"-D\"; }\n};\nint main() { Derived d; }",
      "output": "+B+D-D-B",
      "tags": [
        "inheritance",
        "polymorphism",
        "oop",
        "const",
        "constructors",
        "destructors"
      ],
      "explanation": {
        "steps": [
          {
            "line": 8,
            "action": "construct",
            "description": "Create Derived d",
            "concepts": [
              "inheritance"
            ]
          },
          {
            "line": 3,
            "action": "construct",
            "description": "Base constructor",
            "concepts": [
              "constructor"
            ]
          },
          {
            "line": 3,
            "action": "output",
            "description": "Output \"+B\"",
            "output": "+B"
          },
          {
            "line": 6,
            "action": "construct",
            "description": "Derived constructor",
            "concepts": [
              "constructor"
            ]
          },
          {
            "line": 6,
            "action": "output",
            "description": "Output \"+D\"",
            "output": "+D"
          },
          {
            "line": null,
            "action": "destruct",
            "description": "End of main: destroy d",
            "concepts": [
              "destructor"
            ]
          },
          {
            "line": 7,
            "action": "destruct",
            "description": "Derived destructor FIRST",
            "concepts": [
              "destructor-order"
            ]
          },
          {
            "line": 7,
            "action": "output",
            "description": "Output \"-D\"",
            "output": "-D"
          },
          {
            "line": 4,
            "action": "destruct",
            "description": "Base destructor SECOND",
            "concepts": [
              "destructor-order"
            ]
          },
          {
            "line": 4,
            "action": "output",
            "description": "Output \"-B\"",
            "output": "-B"
          }
        ],
        "finalOutput": "+B+D-D-B",
        "keyInsight": "Destructors run in REVERSE order of constructors: derived first, then base"
      }
    },
    {
      "id": "inh-005",
      "categoryId": "inheritance-polymorphism",
      "concept": "Derived destructor first",
      "code": "class A { public: ~A() { cout << \"A\"; } };\nclass B : public A { public: ~B() { cout << \"B\"; } };\nint main() { B b; }",
      "output": "BA",
      "tags": [
        "inheritance",
        "polymorphism",
        "oop",
        "destructors"
      ],
      "explanation": {
        "steps": [
          {
            "line": 3,
            "action": "construct",
            "description": "Create B b",
            "concepts": [
              "inheritance"
            ]
          },
          {
            "line": null,
            "action": "destruct",
            "description": "End of main: destroy b",
            "concepts": [
              "destructor"
            ]
          },
          {
            "line": 2,
            "action": "destruct",
            "description": "B (derived) destructor first",
            "concepts": [
              "destructor-order"
            ]
          },
          {
            "line": 2,
            "action": "output",
            "description": "Output \"B\"",
            "output": "B"
          },
          {
            "line": 1,
            "action": "destruct",
            "description": "A (base) destructor second",
            "concepts": [
              "destructor-order"
            ]
          },
          {
            "line": 1,
            "action": "output",
            "description": "Output \"A\"",
            "output": "A"
          }
        ],
        "finalOutput": "BA",
        "keyInsight": "Derived destructor runs before base destructor"
      }
    },
    {
      "id": "inh-006",
      "categoryId": "inheritance-polymorphism",
      "concept": "Base destructor second",
      "code": "class X { public: ~X() { cout << \"X\"; } };\nclass Y : public X { public: ~Y() { cout << \"Y\"; } };\nclass Z : public Y { public: ~Z() { cout << \"Z\"; } };\nint main() { Z z; }",
      "output": "ZYX",
      "tags": [
        "inheritance",
        "polymorphism",
        "oop",
        "destructors"
      ],
      "explanation": {
        "steps": [
          {
            "line": 4,
            "action": "construct",
            "description": "Create Z z (X -> Y -> Z)",
            "concepts": [
              "multi-level-inheritance"
            ]
          },
          {
            "line": null,
            "action": "destruct",
            "description": "End of main: destroy z",
            "concepts": [
              "destructor"
            ]
          },
          {
            "line": 3,
            "action": "destruct",
            "description": "Z destructor (most derived)",
            "concepts": [
              "destructor-order"
            ]
          },
          {
            "line": 3,
            "action": "output",
            "description": "Output \"Z\"",
            "output": "Z"
          },
          {
            "line": 2,
            "action": "destruct",
            "description": "Y destructor",
            "concepts": [
              "destructor-order"
            ]
          },
          {
            "line": 2,
            "action": "output",
            "description": "Output \"Y\"",
            "output": "Y"
          },
          {
            "line": 1,
            "action": "destruct",
            "description": "X destructor (topmost base)",
            "concepts": [
              "destructor-order"
            ]
          },
          {
            "line": 1,
            "action": "output",
            "description": "Output \"X\"",
            "output": "X"
          }
        ],
        "finalOutput": "ZYX",
        "keyInsight": "Destructor order is bottom-up: most derived to topmost base"
      }
    },
    {
      "id": "inh-007",
      "categoryId": "inheritance-polymorphism",
      "concept": "`virtual` keyword",
      "code": "class Base {\npublic:\n    virtual void f() { cout << \"B\"; }\n};\nclass Derived : public Base {\npublic:\n    void f() override { cout << \"D\"; }\n};\nint main() {\n    Derived d;\n    Base* p = &d;\n    p->f();\n}",
      "output": "D",
      "tags": [
        "inheritance",
        "polymorphism",
        "oop",
        "virtual"
      ],
      "explanation": {
        "steps": [
          {
            "line": 7,
            "action": "construct",
            "description": "Create Derived d",
            "concepts": [
              "inheritance"
            ]
          },
          {
            "line": 8,
            "action": "assign",
            "description": "Base* p = &d (base pointer to derived)",
            "state": {
              "p": "&d"
            },
            "concepts": [
              "polymorphism"
            ]
          },
          {
            "line": 9,
            "action": "call",
            "description": "p->f(): virtual function lookup",
            "concepts": [
              "virtual-function"
            ]
          },
          {
            "line": 5,
            "action": "evaluate",
            "description": "Dynamic binding: call Derived::f()",
            "concepts": [
              "dynamic-binding"
            ]
          },
          {
            "line": 5,
            "action": "output",
            "description": "Output \"D\"",
            "output": "D"
          }
        ],
        "finalOutput": "D",
        "keyInsight": "Virtual functions enable dynamic binding: actual object type determines which function runs"
      }
    },
    {
      "id": "inh-008",
      "categoryId": "inheritance-polymorphism",
      "concept": "`override` specifier",
      "code": "class Base { public: virtual void f() { cout << \"B\"; } };\nclass Derived : public Base { public: void f() override { cout << \"D\"; } };\nint main() { Derived d; d.f(); }",
      "output": "D",
      "tags": [
        "inheritance",
        "polymorphism",
        "oop",
        "conditionals"
      ],
      "explanation": {
        "steps": [
          {
            "line": 3,
            "action": "construct",
            "description": "Create Derived d",
            "concepts": [
              "inheritance"
            ]
          },
          {
            "line": 3,
            "action": "call",
            "description": "Call d.f()",
            "concepts": [
              "virtual-function"
            ]
          },
          {
            "line": 2,
            "action": "output",
            "description": "Override outputs \"D\"",
            "output": "D"
          }
        ],
        "finalOutput": "D",
        "keyInsight": "`override` specifier documents intent and catches errors if signature doesn't match"
      }
    },
    {
      "id": "inh-009",
      "categoryId": "inheritance-polymorphism",
      "concept": "Dynamic binding",
      "code": "class A { public: virtual void say() { cout << \"A\"; } };\nclass B : public A { public: void say() override { cout << \"B\"; } };\nint main() {\n    B b;\n    A& ref = b;\n    ref.say();\n}",
      "output": "B",
      "tags": [
        "inheritance",
        "polymorphism",
        "oop"
      ],
      "explanation": {
        "steps": [
          {
            "line": 4,
            "action": "construct",
            "description": "Create B b",
            "concepts": [
              "inheritance"
            ]
          },
          {
            "line": 5,
            "action": "declare",
            "description": "A& ref = b (reference to derived)",
            "state": {
              "ref": "&b"
            },
            "concepts": [
              "reference"
            ]
          },
          {
            "line": 6,
            "action": "call",
            "description": "ref.say(): virtual lookup",
            "concepts": [
              "virtual-function"
            ]
          },
          {
            "line": 2,
            "action": "evaluate",
            "description": "Dynamic binding: actual type is B",
            "concepts": [
              "dynamic-binding"
            ]
          },
          {
            "line": 2,
            "action": "output",
            "description": "Output \"B\"",
            "output": "B"
          }
        ],
        "finalOutput": "B",
        "keyInsight": "References also support dynamic binding with virtual functions"
      }
    },
    {
      "id": "inh-010",
      "categoryId": "inheritance-polymorphism",
      "concept": "Runtime polymorphism",
      "code": "class Animal { public: virtual void speak() { cout << \"?\"; } };\nclass Dog : public Animal { public: void speak() override { cout << \"Woof\"; } };\nclass Cat : public Animal { public: void speak() override { cout << \"Meow\"; } };\nint main() {\n    Dog d; Cat c;\n    Animal* a1 = &d;\n    Animal* a2 = &c;\n    a1->speak();\n    a2->speak();\n}",
      "output": "WoofMeow",
      "tags": [
        "inheritance",
        "polymorphism",
        "oop"
      ],
      "explanation": {
        "steps": [
          {
            "line": 4,
            "action": "construct",
            "description": "Create Dog d, Cat c",
            "concepts": [
              "inheritance"
            ]
          },
          {
            "line": 5,
            "action": "assign",
            "description": "Animal* a1 = &d",
            "state": {
              "a1": "&d"
            },
            "concepts": [
              "polymorphism"
            ]
          },
          {
            "line": 6,
            "action": "assign",
            "description": "Animal* a2 = &c",
            "state": {
              "a2": "&c"
            }
          },
          {
            "line": 7,
            "action": "call",
            "description": "a1->speak(): Dog's speak()",
            "concepts": [
              "virtual-function"
            ]
          },
          {
            "line": 2,
            "action": "output",
            "description": "Output \"Woof\"",
            "output": "Woof"
          },
          {
            "line": 8,
            "action": "call",
            "description": "a2->speak(): Cat's speak()",
            "concepts": [
              "virtual-function"
            ]
          },
          {
            "line": 3,
            "action": "output",
            "description": "Output \"Meow\"",
            "output": "Meow"
          }
        ],
        "finalOutput": "WoofMeow",
        "keyInsight": "Runtime polymorphism: same base pointer, different derived behaviors"
      }
    },
    {
      "id": "inh-011",
      "categoryId": "inheritance-polymorphism",
      "concept": "Function hiding (non-virtual)",
      "code": "class Base { public: void f() { cout << \"B\"; } };\nclass Derived : public Base { public: void f() { cout << \"D\"; } };\nint main() {\n    Derived d;\n    Base* p = &d;\n    p->f();\n}",
      "output": "B",
      "tags": [
        "inheritance",
        "polymorphism",
        "oop",
        "virtual"
      ],
      "explanation": {
        "steps": [
          {
            "line": 4,
            "action": "construct",
            "description": "Create Derived d",
            "concepts": [
              "inheritance"
            ]
          },
          {
            "line": 5,
            "action": "assign",
            "description": "Base* p = &d",
            "state": {
              "p": "&d"
            },
            "concepts": [
              "polymorphism"
            ]
          },
          {
            "line": 6,
            "action": "call",
            "description": "p->f(): NOT virtual, use static type",
            "concepts": [
              "static-binding"
            ]
          },
          {
            "line": 1,
            "action": "evaluate",
            "description": "Static binding: p's type is Base*, call Base::f()",
            "concepts": [
              "function-hiding"
            ]
          },
          {
            "line": 1,
            "action": "output",
            "description": "Output \"B\"",
            "output": "B"
          }
        ],
        "finalOutput": "B",
        "keyInsight": "Without `virtual`, pointer type (not object type) determines which function is called"
      }
    },
    {
      "id": "inh-012",
      "categoryId": "inheritance-polymorphism",
      "concept": "Static binding",
      "code": "class A { public: void show() { cout << \"A\"; } };\nclass B : public A { public: void show() { cout << \"B\"; } };\nint main() {\n    B b;\n    A* ptr = &b;\n    ptr->show();  // Static type is A*\n}",
      "output": "A",
      "tags": [
        "inheritance",
        "polymorphism",
        "oop",
        "static"
      ],
      "explanation": {
        "steps": [
          {
            "line": 4,
            "action": "construct",
            "description": "Create B b",
            "concepts": [
              "inheritance"
            ]
          },
          {
            "line": 5,
            "action": "assign",
            "description": "A* ptr = &b",
            "state": {
              "ptr": "&b"
            },
            "concepts": [
              "polymorphism"
            ]
          },
          {
            "line": 6,
            "action": "call",
            "description": "ptr->show(): non-virtual, static binding",
            "concepts": [
              "static-binding"
            ]
          },
          {
            "line": 1,
            "action": "output",
            "description": "Output \"A\" (ptr's static type)",
            "output": "A"
          }
        ],
        "finalOutput": "A",
        "keyInsight": "Static binding: compiler uses pointer's declared type, ignoring runtime type"
      }
    },
    {
      "id": "inh-013",
      "categoryId": "inheritance-polymorphism",
      "concept": "Pointer type determines function called (non-virtual)",
      "code": "class X { public: void f() { cout << \"X\"; } };\nclass Y : public X { public: void f() { cout << \"Y\"; } };\nint main() {\n    Y y;\n    X* px = &y;\n    Y* py = &y;\n    px->f();\n    py->f();\n}",
      "output": "XY",
      "tags": [
        "inheritance",
        "polymorphism",
        "oop",
        "pointers",
        "virtual"
      ],
      "explanation": {
        "steps": [
          {
            "line": 4,
            "action": "construct",
            "description": "Create Y y",
            "concepts": [
              "inheritance"
            ]
          },
          {
            "line": 5,
            "action": "assign",
            "description": "X* px = &y",
            "state": {
              "px": "&y"
            },
            "concepts": [
              "polymorphism"
            ]
          },
          {
            "line": 6,
            "action": "assign",
            "description": "Y* py = &y",
            "state": {
              "py": "&y"
            }
          },
          {
            "line": 7,
            "action": "call",
            "description": "px->f(): X* type, calls X::f()",
            "concepts": [
              "static-binding"
            ]
          },
          {
            "line": 1,
            "action": "output",
            "description": "Output \"X\"",
            "output": "X"
          },
          {
            "line": 8,
            "action": "call",
            "description": "py->f(): Y* type, calls Y::f()",
            "concepts": [
              "static-binding"
            ]
          },
          {
            "line": 2,
            "action": "output",
            "description": "Output \"Y\"",
            "output": "Y"
          }
        ],
        "finalOutput": "XY",
        "keyInsight": "For non-virtual functions, pointer type determines function: X* calls X::f, Y* calls Y::f"
      }
    },
    {
      "id": "inh-014",
      "categoryId": "inheritance-polymorphism",
      "concept": "Copying derived to base",
      "code": "class Base { public: int x = 1; };\nclass Derived : public Base { public: int y = 2; };\nint main() {\n    Derived d;\n    Base b = d;  // Slicing\n    cout << b.x;\n}",
      "output": "1",
      "tags": [
        "inheritance",
        "polymorphism",
        "oop",
        "copy-semantics"
      ],
      "explanation": {
        "steps": [
          {
            "line": 3,
            "action": "construct",
            "description": "Create Derived d with x=1, y=2",
            "state": {
              "d.x": 1,
              "d.y": 2
            },
            "concepts": [
              "inheritance"
            ]
          },
          {
            "line": 4,
            "action": "copy",
            "description": "Base b = d: SLICING occurs",
            "concepts": [
              "object-slicing"
            ]
          },
          {
            "line": 4,
            "action": "evaluate",
            "description": "Only Base part (x) is copied, y is lost",
            "state": {
              "b.x": 1
            }
          },
          {
            "line": 5,
            "action": "output",
            "description": "Output b.x = 1",
            "output": "1"
          }
        ],
        "finalOutput": "1",
        "keyInsight": "Object slicing: copying derived to base loses the derived-specific members"
      }
    },
    {
      "id": "inh-015",
      "categoryId": "inheritance-polymorphism",
      "concept": "Slicing off derived part",
      "code": "class Base {\npublic:\n    virtual void f() { cout << \"B\"; }\n};\nclass Derived : public Base {\npublic:\n    void f() override { cout << \"D\"; }\n};\nint main() {\n    Derived d;\n    Base b = d;  // Sliced!\n    b.f();\n}",
      "output": "B",
      "tags": [
        "inheritance",
        "polymorphism",
        "oop"
      ],
      "explanation": {
        "steps": [
          {
            "line": 7,
            "action": "construct",
            "description": "Create Derived d",
            "concepts": [
              "inheritance"
            ]
          },
          {
            "line": 8,
            "action": "copy",
            "description": "Base b = d: slicing creates Base object",
            "concepts": [
              "object-slicing"
            ]
          },
          {
            "line": 9,
            "action": "call",
            "description": "b.f(): b is a Base, not Derived",
            "concepts": [
              "static-binding"
            ]
          },
          {
            "line": 3,
            "action": "output",
            "description": "Output \"B\" (Base::f called)",
            "output": "B"
          }
        ],
        "finalOutput": "B",
        "keyInsight": "After slicing, virtual table is Base's; polymorphism is lost"
      }
    },
    {
      "id": "inh-016",
      "categoryId": "inheritance-polymorphism",
      "concept": "Reference/pointer preserves polymorphism",
      "code": "class Base { public: virtual void f() { cout << \"B\"; } };\nclass Derived : public Base { public: void f() override { cout << \"D\"; } };\nint main() {\n    Derived d;\n    Base& ref = d;  // No slicing\n    ref.f();\n}",
      "output": "D",
      "tags": [
        "inheritance",
        "polymorphism",
        "oop",
        "pointers",
        "references"
      ],
      "explanation": {
        "steps": [
          {
            "line": 4,
            "action": "construct",
            "description": "Create Derived d",
            "concepts": [
              "inheritance"
            ]
          },
          {
            "line": 5,
            "action": "declare",
            "description": "Base& ref = d (reference, no slicing)",
            "state": {
              "ref": "&d"
            },
            "concepts": [
              "reference"
            ]
          },
          {
            "line": 6,
            "action": "call",
            "description": "ref.f(): virtual lookup through reference",
            "concepts": [
              "virtual-function"
            ]
          },
          {
            "line": 2,
            "action": "output",
            "description": "Output \"D\" (Derived::f)",
            "output": "D"
          }
        ],
        "finalOutput": "D",
        "keyInsight": "References and pointers preserve polymorphism; no slicing occurs"
      }
    },
    {
      "id": "inh-017",
      "categoryId": "inheritance-polymorphism",
      "concept": "Non-virtual destructor problems",
      "code": "class Base {\npublic:\n    ~Base() { cout << \"B\"; }  // Not virtual!\n};\nclass Derived : public Base {\npublic:\n    ~Derived() { cout << \"D\"; }\n};\nint main() {\n    Base* p = new Derived();\n    delete p;  // Only calls ~Base!\n}",
      "output": "B",
      "tags": [
        "inheritance",
        "polymorphism",
        "oop",
        "virtual",
        "destructors"
      ],
      "explanation": {
        "steps": [
          {
            "line": 6,
            "action": "allocate",
            "description": "new Derived() on heap",
            "concepts": [
              "heap-allocation"
            ]
          },
          {
            "line": 6,
            "action": "construct",
            "description": "Construct Derived object"
          },
          {
            "line": 6,
            "action": "assign",
            "description": "Store in Base* p",
            "state": {
              "p": "->Derived"
            }
          },
          {
            "line": 7,
            "action": "deallocate",
            "description": "delete p: destructor lookup",
            "concepts": [
              "non-virtual-destructor"
            ]
          },
          {
            "line": 2,
            "action": "destruct",
            "description": "Non-virtual: only ~Base() called!",
            "concepts": [
              "destructor"
            ]
          },
          {
            "line": 2,
            "action": "output",
            "description": "Output \"B\" (~Derived NOT called)",
            "output": "B"
          }
        ],
        "finalOutput": "B",
        "keyInsight": "Non-virtual destructor + base pointer = derived destructor NOT called (undefined behavior)"
      }
    },
    {
      "id": "inh-018",
      "categoryId": "inheritance-polymorphism",
      "concept": "Deleting through base pointer",
      "code": "class A { public: ~A() { cout << \"A\"; } };\nclass B : public A { public: ~B() { cout << \"B\"; } };\nint main() {\n    A* p = new B();\n    delete p;  // Non-virtual: only ~A called\n}",
      "output": "A",
      "tags": [
        "inheritance",
        "polymorphism",
        "oop",
        "pointers"
      ],
      "explanation": {
        "steps": [
          {
            "line": 3,
            "action": "allocate",
            "description": "new B() on heap",
            "concepts": [
              "heap-allocation"
            ]
          },
          {
            "line": 3,
            "action": "assign",
            "description": "A* p points to B object",
            "state": {
              "p": "->B"
            }
          },
          {
            "line": 4,
            "action": "deallocate",
            "description": "delete p: non-virtual destructor",
            "concepts": [
              "non-virtual-destructor"
            ]
          },
          {
            "line": 1,
            "action": "destruct",
            "description": "Only ~A called",
            "concepts": [
              "destructor"
            ]
          },
          {
            "line": 1,
            "action": "output",
            "description": "Output \"A\"",
            "output": "A"
          }
        ],
        "finalOutput": "A",
        "keyInsight": "Without virtual destructor, only base destructor runs through base pointer"
      }
    },
    {
      "id": "inh-019",
      "categoryId": "inheritance-polymorphism",
      "concept": "Derived destructor not called (without virtual)",
      "code": "class Base { public: ~Base() { cout << \"-B\"; } };\nclass Derived : public Base { public: ~Derived() { cout << \"-D\"; } };\nint main() {\n    Base* p = new Derived();\n    delete p;\n}",
      "output": "-B",
      "tags": [
        "inheritance",
        "polymorphism",
        "oop",
        "virtual",
        "destructors"
      ],
      "explanation": {
        "steps": [
          {
            "line": 4,
            "action": "allocate",
            "description": "new Derived()",
            "concepts": [
              "heap-allocation"
            ]
          },
          {
            "line": 4,
            "action": "assign",
            "description": "Base* p = &derived",
            "state": {
              "p": "->Derived"
            }
          },
          {
            "line": 5,
            "action": "deallocate",
            "description": "delete p",
            "concepts": [
              "non-virtual-destructor"
            ]
          },
          {
            "line": 1,
            "action": "destruct",
            "description": "Only ~Base called (-D missing!)",
            "concepts": [
              "destructor"
            ]
          },
          {
            "line": 1,
            "action": "output",
            "description": "Output \"-B\"",
            "output": "-B"
          }
        ],
        "finalOutput": "-B",
        "keyInsight": "Derived destructor is skipped when deleting through base pointer without virtual"
      }
    },
    {
      "id": "inh-020",
      "categoryId": "inheritance-polymorphism",
      "concept": "Memory leak/undefined behavior risk",
      "code": "class Base { public: ~Base() { cout << \"~B \"; } };\nclass Derived : public Base {\n    int* data;\npublic:\n    Derived() : data(new int(5)) {}\n    ~Derived() { delete data; cout << \"~D \"; }\n};\nint main() {\n    Base* p = new Derived();\n    delete p;  // Leak! ~Derived not called\n    cout << \"done\";\n}",
      "output": "~B done",
      "tags": [
        "inheritance",
        "polymorphism",
        "oop"
      ],
      "explanation": {
        "steps": [
          {
            "line": 7,
            "action": "allocate",
            "description": "new Derived(): allocates data",
            "concepts": [
              "heap-allocation"
            ]
          },
          {
            "line": 5,
            "action": "allocate",
            "description": "Constructor allocates data = new int(5)"
          },
          {
            "line": 8,
            "action": "deallocate",
            "description": "delete p: non-virtual destructor",
            "concepts": [
              "memory-leak"
            ]
          },
          {
            "line": 1,
            "action": "destruct",
            "description": "Only ~Base called",
            "concepts": [
              "non-virtual-destructor"
            ]
          },
          {
            "line": 1,
            "action": "output",
            "description": "Output \"~B \"",
            "output": "~B "
          },
          {
            "line": 9,
            "action": "output",
            "description": "Output \"done\"",
            "output": "done"
          }
        ],
        "finalOutput": "~B done",
        "keyInsight": "Memory leak: ~Derived not called, so `data` is never deleted"
      }
    },
    {
      "id": "inh-021",
      "categoryId": "inheritance-polymorphism",
      "concept": "`virtual ~Base()`",
      "code": "class Base {\npublic:\n    virtual ~Base() { cout << \"B\"; }\n};\nclass Derived : public Base {\npublic:\n    ~Derived() { cout << \"D\"; }\n};\nint main() {\n    Base* p = new Derived();\n    delete p;\n}",
      "output": "DB",
      "tags": [
        "inheritance",
        "polymorphism",
        "oop",
        "virtual"
      ],
      "explanation": {
        "steps": [
          {
            "line": 7,
            "action": "allocate",
            "description": "new Derived()",
            "concepts": [
              "heap-allocation"
            ]
          },
          {
            "line": 7,
            "action": "assign",
            "description": "Base* p points to Derived",
            "state": {
              "p": "->Derived"
            }
          },
          {
            "line": 8,
            "action": "deallocate",
            "description": "delete p: VIRTUAL destructor",
            "concepts": [
              "virtual-destructor"
            ]
          },
          {
            "line": 5,
            "action": "destruct",
            "description": "~Derived called FIRST",
            "concepts": [
              "destructor-order"
            ]
          },
          {
            "line": 5,
            "action": "output",
            "description": "Output \"D\"",
            "output": "D"
          },
          {
            "line": 2,
            "action": "destruct",
            "description": "~Base called SECOND",
            "concepts": [
              "destructor-order"
            ]
          },
          {
            "line": 2,
            "action": "output",
            "description": "Output \"B\"",
            "output": "B"
          }
        ],
        "finalOutput": "DB",
        "keyInsight": "Virtual destructor enables proper cleanup through base pointer"
      }
    },
    {
      "id": "inh-022",
      "categoryId": "inheritance-polymorphism",
      "concept": "Proper cleanup through base pointer",
      "code": "class A { public: virtual ~A() { cout << \"A\"; } };\nclass B : public A { public: ~B() { cout << \"B\"; } };\nclass C : public B { public: ~C() { cout << \"C\"; } };\nint main() {\n    A* p = new C();\n    delete p;\n}",
      "output": "CBA",
      "tags": [
        "inheritance",
        "polymorphism",
        "oop",
        "pointers"
      ],
      "explanation": {
        "steps": [
          {
            "line": 5,
            "action": "allocate",
            "description": "new C()",
            "concepts": [
              "heap-allocation"
            ]
          },
          {
            "line": 5,
            "action": "assign",
            "description": "A* p points to C",
            "state": {
              "p": "->C"
            }
          },
          {
            "line": 6,
            "action": "deallocate",
            "description": "delete p: virtual destructor chain",
            "concepts": [
              "virtual-destructor"
            ]
          },
          {
            "line": 3,
            "action": "destruct",
            "description": "~C first",
            "concepts": [
              "destructor-order"
            ]
          },
          {
            "line": 3,
            "action": "output",
            "description": "Output \"C\"",
            "output": "C"
          },
          {
            "line": 2,
            "action": "destruct",
            "description": "~B second"
          },
          {
            "line": 2,
            "action": "output",
            "description": "Output \"B\"",
            "output": "B"
          },
          {
            "line": 1,
            "action": "destruct",
            "description": "~A last"
          },
          {
            "line": 1,
            "action": "output",
            "description": "Output \"A\"",
            "output": "A"
          }
        ],
        "finalOutput": "CBA",
        "keyInsight": "Virtual destructor ensures entire chain runs: C -> B -> A"
      }
    },
    {
      "id": "inh-023",
      "categoryId": "inheritance-polymorphism",
      "concept": "Correct destruction order",
      "code": "class Base { public: virtual ~Base() { cout << \"1\"; } };\nclass Derived : public Base { public: ~Derived() { cout << \"2\"; } };\nint main() {\n    Base* p = new Derived();\n    delete p;\n}",
      "output": "21",
      "tags": [
        "inheritance",
        "polymorphism",
        "oop"
      ],
      "explanation": {
        "steps": [
          {
            "line": 4,
            "action": "allocate",
            "description": "new Derived()",
            "concepts": [
              "heap-allocation"
            ]
          },
          {
            "line": 4,
            "action": "assign",
            "description": "Base* p points to Derived"
          },
          {
            "line": 5,
            "action": "deallocate",
            "description": "delete p: virtual destructor",
            "concepts": [
              "virtual-destructor"
            ]
          },
          {
            "line": 2,
            "action": "destruct",
            "description": "~Derived (derived first)",
            "concepts": [
              "destructor-order"
            ]
          },
          {
            "line": 2,
            "action": "output",
            "description": "Output \"2\"",
            "output": "2"
          },
          {
            "line": 1,
            "action": "destruct",
            "description": "~Base (base second)",
            "concepts": [
              "destructor-order"
            ]
          },
          {
            "line": 1,
            "action": "output",
            "description": "Output \"1\"",
            "output": "1"
          }
        ],
        "finalOutput": "21",
        "keyInsight": "Correct destruction: derived (2) before base (1)"
      }
    },
    {
      "id": "inh-024",
      "categoryId": "inheritance-polymorphism",
      "concept": "`Base::method()` explicit call",
      "code": "class Base { public: void greet() { cout << \"Hi\"; } };\nclass Derived : public Base {\npublic:\n    void greet() {\n        Base::greet();\n        cout << \"!\";\n    }\n};\nint main() { Derived d; d.greet(); }",
      "output": "Hi!",
      "tags": [
        "inheritance",
        "polymorphism",
        "oop"
      ],
      "explanation": {
        "steps": [
          {
            "line": 7,
            "action": "construct",
            "description": "Create Derived d",
            "concepts": [
              "inheritance"
            ]
          },
          {
            "line": 7,
            "action": "call",
            "description": "Call d.greet()",
            "concepts": [
              "member-function"
            ]
          },
          {
            "line": 5,
            "action": "call",
            "description": "Base::greet() explicitly called",
            "concepts": [
              "base-call"
            ]
          },
          {
            "line": 1,
            "action": "output",
            "description": "Output \"Hi\"",
            "output": "Hi"
          },
          {
            "line": 6,
            "action": "output",
            "description": "Output \"!\"",
            "output": "!"
          }
        ],
        "finalOutput": "Hi!",
        "keyInsight": "Use `Base::method()` to explicitly call base class implementation"
      }
    },
    {
      "id": "inh-025",
      "categoryId": "inheritance-polymorphism",
      "concept": "Extending base behavior in derived",
      "code": "class A { public: virtual void f() { cout << \"A\"; } };\nclass B : public A {\npublic:\n    void f() override { A::f(); cout << \"B\"; }\n};\nint main() { B b; b.f(); }",
      "output": "AB",
      "tags": [
        "inheritance",
        "polymorphism",
        "oop"
      ],
      "explanation": {
        "steps": [
          {
            "line": 5,
            "action": "construct",
            "description": "Create B b",
            "concepts": [
              "inheritance"
            ]
          },
          {
            "line": 5,
            "action": "call",
            "description": "Call b.f()",
            "concepts": [
              "virtual-function"
            ]
          },
          {
            "line": 4,
            "action": "call",
            "description": "B::f() calls A::f() first",
            "concepts": [
              "base-call"
            ]
          },
          {
            "line": 1,
            "action": "output",
            "description": "Output \"A\"",
            "output": "A"
          },
          {
            "line": 4,
            "action": "output",
            "description": "Then output \"B\"",
            "output": "B"
          }
        ],
        "finalOutput": "AB",
        "keyInsight": "Override can extend base behavior by calling `Base::method()` then adding more"
      }
    },
    {
      "id": "inh-026",
      "categoryId": "inheritance-polymorphism",
      "concept": "Not recursive",
      "code": "class Base {\npublic:\n    virtual void show() { cout << \"Base\"; }\n};\nclass Derived : public Base {\npublic:\n    void show() override {\n        Base::show();  // Calls Base version, not recursive\n        cout << \"Derived\";\n    }\n};\nint main() { Derived d; d.show(); }",
      "output": "BaseDerived",
      "tags": [
        "inheritance",
        "polymorphism",
        "oop"
      ],
      "explanation": {
        "steps": [
          {
            "line": 9,
            "action": "construct",
            "description": "Create Derived d",
            "concepts": [
              "inheritance"
            ]
          },
          {
            "line": 9,
            "action": "call",
            "description": "Call d.show()",
            "concepts": [
              "virtual-function"
            ]
          },
          {
            "line": 7,
            "action": "call",
            "description": "Base::show() explicitly (not recursive)",
            "concepts": [
              "base-call"
            ]
          },
          {
            "line": 4,
            "action": "output",
            "description": "Output \"Base\"",
            "output": "Base"
          },
          {
            "line": 8,
            "action": "output",
            "description": "Output \"Derived\"",
            "output": "Derived"
          }
        ],
        "finalOutput": "BaseDerived",
        "keyInsight": "`Base::show()` calls base version directly; NOT recursive, even though show() is virtual"
      }
    },
    {
      "id": "inh-027",
      "categoryId": "inheritance-polymorphism",
      "concept": "`= 0` pure virtual",
      "code": "class Shape {\npublic:\n    virtual void draw() = 0;\n};\nclass Circle : public Shape {\npublic:\n    void draw() override { cout << \"O\"; }\n};\nint main() { Circle c; c.draw(); }",
      "output": "O",
      "tags": [
        "inheritance",
        "polymorphism",
        "oop",
        "virtual"
      ],
      "explanation": {
        "steps": [
          {
            "line": 7,
            "action": "construct",
            "description": "Create Circle c",
            "concepts": [
              "inheritance"
            ]
          },
          {
            "line": 7,
            "action": "call",
            "description": "Call c.draw()",
            "concepts": [
              "pure-virtual"
            ]
          },
          {
            "line": 6,
            "action": "output",
            "description": "Output \"O\"",
            "output": "O"
          }
        ],
        "finalOutput": "O",
        "keyInsight": "Pure virtual `= 0` has no base implementation; derived MUST override"
      }
    },
    {
      "id": "inh-028",
      "categoryId": "inheritance-polymorphism",
      "concept": "Abstract class",
      "code": "class Abstract {\npublic:\n    virtual void f() = 0;\n    void g() { cout << \"g\"; }\n};\nclass Concrete : public Abstract {\npublic:\n    void f() override { cout << \"f\"; }\n};\nint main() {\n    Concrete c;\n    c.f();\n    c.g();\n}",
      "output": "fg",
      "tags": [
        "inheritance",
        "polymorphism",
        "oop"
      ],
      "explanation": {
        "steps": [
          {
            "line": 7,
            "action": "construct",
            "description": "Create Concrete c",
            "concepts": [
              "abstract-class"
            ]
          },
          {
            "line": 8,
            "action": "call",
            "description": "Call c.f()",
            "concepts": [
              "virtual-function"
            ]
          },
          {
            "line": 6,
            "action": "output",
            "description": "Output \"f\"",
            "output": "f"
          },
          {
            "line": 9,
            "action": "call",
            "description": "Call c.g() (non-virtual, inherited)",
            "concepts": [
              "inherited-member"
            ]
          },
          {
            "line": 4,
            "action": "output",
            "description": "Output \"g\"",
            "output": "g"
          }
        ],
        "finalOutput": "fg",
        "keyInsight": "Abstract classes can have regular methods; only pure virtual must be overridden"
      }
    },
    {
      "id": "inh-029",
      "categoryId": "inheritance-polymorphism",
      "concept": "Cannot instantiate abstract class",
      "code": "class Base {\npublic:\n    virtual void f() = 0;\n};\nclass Derived : public Base {\npublic:\n    void f() override { cout << \"OK\"; }\n};\nint main() {\n    // Base b;  // Error: cannot instantiate\n    Derived d;\n    d.f();\n}",
      "output": "OK",
      "tags": [
        "inheritance",
        "polymorphism",
        "oop"
      ],
      "explanation": {
        "steps": [
          {
            "line": 7,
            "action": "construct",
            "description": "Create Derived d",
            "concepts": [
              "abstract-class"
            ]
          },
          {
            "line": 8,
            "action": "call",
            "description": "Call d.f()",
            "concepts": [
              "virtual-function"
            ]
          },
          {
            "line": 6,
            "action": "output",
            "description": "Output \"OK\"",
            "output": "OK"
          }
        ],
        "finalOutput": "OK",
        "keyInsight": "Cannot instantiate abstract class (Base); must use concrete derived class"
      }
    },
    {
      "id": "inh-030",
      "categoryId": "inheritance-polymorphism",
      "concept": "Concrete derived class",
      "code": "class Abstract { public: virtual void run() = 0; };\nclass Impl : public Abstract { public: void run() override { cout << \"Running\"; } };\nint main() {\n    Impl i;\n    Abstract* p = &i;\n    p->run();\n}",
      "output": "Running",
      "tags": [
        "inheritance",
        "polymorphism",
        "oop"
      ],
      "explanation": {
        "steps": [
          {
            "line": 3,
            "action": "construct",
            "description": "Create Impl i",
            "concepts": [
              "abstract-class"
            ]
          },
          {
            "line": 4,
            "action": "assign",
            "description": "Abstract* p = &i",
            "state": {
              "p": "&i"
            },
            "concepts": [
              "polymorphism"
            ]
          },
          {
            "line": 5,
            "action": "call",
            "description": "p->run(): virtual lookup",
            "concepts": [
              "virtual-function"
            ]
          },
          {
            "line": 2,
            "action": "output",
            "description": "Output \"Running\"",
            "output": "Running"
          }
        ],
        "finalOutput": "Running",
        "keyInsight": "Abstract pointer can point to concrete object; polymorphism still works"
      }
    },
    {
      "id": "inh-031",
      "categoryId": "inheritance-polymorphism",
      "concept": "Multi-level inheritance chain",
      "code": "class A { public: A() { cout << \"A\"; } };\nclass B : public A { public: B() { cout << \"B\"; } };\nclass C : public B { public: C() { cout << \"C\"; } };\nint main() { C c; }",
      "output": "ABC",
      "tags": [
        "inheritance",
        "polymorphism",
        "oop"
      ],
      "explanation": {
        "steps": [
          {
            "line": 4,
            "action": "construct",
            "description": "Create C c (A -> B -> C)",
            "concepts": [
              "multi-level-inheritance"
            ]
          },
          {
            "line": 1,
            "action": "construct",
            "description": "A constructor",
            "concepts": [
              "constructor-order"
            ]
          },
          {
            "line": 1,
            "action": "output",
            "description": "Output \"A\"",
            "output": "A"
          },
          {
            "line": 2,
            "action": "construct",
            "description": "B constructor"
          },
          {
            "line": 2,
            "action": "output",
            "description": "Output \"B\"",
            "output": "B"
          },
          {
            "line": 3,
            "action": "construct",
            "description": "C constructor"
          },
          {
            "line": 3,
            "action": "output",
            "description": "Output \"C\"",
            "output": "C"
          }
        ],
        "finalOutput": "ABC",
        "keyInsight": "Multi-level: constructors run A -> B -> C (base to derived)"
      }
    },
    {
      "id": "inh-032",
      "categoryId": "inheritance-polymorphism",
      "concept": "Constructor order top-down",
      "code": "class X { public: X() { cout << \"1\"; } };\nclass Y : public X { public: Y() { cout << \"2\"; } };\nclass Z : public Y { public: Z() { cout << \"3\"; } };\nint main() { Z z; }",
      "output": "123",
      "tags": [
        "inheritance",
        "polymorphism",
        "oop",
        "const",
        "constructors"
      ],
      "explanation": {
        "steps": [
          {
            "line": 4,
            "action": "construct",
            "description": "Create Z z",
            "concepts": [
              "multi-level-inheritance"
            ]
          },
          {
            "line": 1,
            "action": "construct",
            "description": "X (topmost base)",
            "concepts": [
              "constructor-order"
            ]
          },
          {
            "line": 1,
            "action": "output",
            "description": "Output \"1\"",
            "output": "1"
          },
          {
            "line": 2,
            "action": "construct",
            "description": "Y"
          },
          {
            "line": 2,
            "action": "output",
            "description": "Output \"2\"",
            "output": "2"
          },
          {
            "line": 3,
            "action": "construct",
            "description": "Z (most derived)"
          },
          {
            "line": 3,
            "action": "output",
            "description": "Output \"3\"",
            "output": "3"
          }
        ],
        "finalOutput": "123",
        "keyInsight": "Constructor order: top-down through inheritance hierarchy"
      }
    },
    {
      "id": "inh-033",
      "categoryId": "inheritance-polymorphism",
      "concept": "Destructor order bottom-up",
      "code": "class A { public: virtual ~A() { cout << \"A\"; } };\nclass B : public A { public: ~B() { cout << \"B\"; } };\nclass C : public B { public: ~C() { cout << \"C\"; } };\nint main() { C c; cout << \"|\"; }",
      "output": "|CBA",
      "tags": [
        "inheritance",
        "polymorphism",
        "oop",
        "destructors"
      ],
      "explanation": {
        "steps": [
          {
            "line": 4,
            "action": "construct",
            "description": "Create C c",
            "concepts": [
              "multi-level-inheritance"
            ]
          },
          {
            "line": 4,
            "action": "output",
            "description": "Output \"|\"",
            "output": "|"
          },
          {
            "line": null,
            "action": "destruct",
            "description": "End of main: destroy c",
            "concepts": [
              "destructor"
            ]
          },
          {
            "line": 3,
            "action": "destruct",
            "description": "~C (most derived first)",
            "concepts": [
              "destructor-order"
            ]
          },
          {
            "line": 3,
            "action": "output",
            "description": "Output \"C\"",
            "output": "C"
          },
          {
            "line": 2,
            "action": "destruct",
            "description": "~B"
          },
          {
            "line": 2,
            "action": "output",
            "description": "Output \"B\"",
            "output": "B"
          },
          {
            "line": 1,
            "action": "destruct",
            "description": "~A (topmost base last)"
          },
          {
            "line": 1,
            "action": "output",
            "description": "Output \"A\"",
            "output": "A"
          }
        ],
        "finalOutput": "|CBA",
        "keyInsight": "Destructor order: bottom-up (C -> B -> A), reverse of constructor"
      }
    },
    {
      "id": "mem-001",
      "categoryId": "dynamic-memory",
      "concept": "`new` operator",
      "code": "int main() {\n    int* p = new int(42);\n    cout << *p;\n    delete p;\n}",
      "output": "42",
      "tags": [
        "memory",
        "heap",
        "pointers",
        "operators",
        "dynamic-memory"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "allocate",
            "description": "Allocate `int` on heap with value 42, store address in `p`",
            "state": {
              "p": "\u2192heap(42)"
            },
            "concepts": [
              "new-operator",
              "heap-allocation"
            ]
          },
          {
            "line": 3,
            "action": "dereference",
            "description": "Dereference `p` to access heap value, print 42",
            "output": "42",
            "concepts": [
              "pointer-dereference"
            ]
          },
          {
            "line": 4,
            "action": "deallocate",
            "description": "Deallocate heap memory pointed to by `p`",
            "concepts": [
              "delete-operator"
            ]
          }
        ],
        "finalOutput": "42",
        "keyInsight": "The `new` operator allocates memory on the heap and returns a pointer to it; `delete` frees that memory."
      }
    },
    {
      "id": "mem-002",
      "categoryId": "dynamic-memory",
      "concept": "Heap allocation",
      "code": "int main() {\n    int* p = new int;\n    *p = 99;\n    cout << *p;\n    delete p;\n}",
      "output": "99",
      "tags": [
        "memory",
        "heap",
        "pointers"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "allocate",
            "description": "Allocate uninitialized `int` on heap, store address in `p`",
            "state": {
              "p": "\u2192heap(?)"
            },
            "concepts": [
              "heap-allocation"
            ]
          },
          {
            "line": 3,
            "action": "assign",
            "description": "Dereference `p` and assign 99 to heap location",
            "state": {
              "*p": 99
            },
            "concepts": [
              "pointer-dereference"
            ]
          },
          {
            "line": 4,
            "action": "output",
            "description": "Print dereferenced value",
            "output": "99"
          },
          {
            "line": 5,
            "action": "deallocate",
            "description": "Free the heap memory",
            "concepts": [
              "delete-operator"
            ]
          }
        ],
        "finalOutput": "99",
        "keyInsight": "`new int` without parentheses allocates uninitialized memory; we must assign a value through the pointer."
      }
    },
    {
      "id": "mem-003",
      "categoryId": "dynamic-memory",
      "concept": "`delete` operator",
      "code": "int main() {\n    int* p = new int(5);\n    cout << *p;\n    delete p;\n    cout << \"deleted\";\n}",
      "output": "5deleted",
      "tags": [
        "memory",
        "heap",
        "pointers",
        "operators",
        "dynamic-memory"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "allocate",
            "description": "Allocate `int(5)` on heap",
            "state": {
              "p": "\u2192heap(5)"
            },
            "concepts": [
              "new-operator"
            ]
          },
          {
            "line": 3,
            "action": "output",
            "description": "Dereference and print 5",
            "output": "5"
          },
          {
            "line": 4,
            "action": "deallocate",
            "description": "`delete p` frees heap memory",
            "concepts": [
              "delete-operator"
            ]
          },
          {
            "line": 5,
            "action": "output",
            "description": "Print literal string",
            "output": "deleted"
          }
        ],
        "finalOutput": "5deleted",
        "keyInsight": "After `delete`, the memory is freed but the pointer still exists (becomes dangling)."
      }
    },
    {
      "id": "mem-004",
      "categoryId": "dynamic-memory",
      "concept": "`nullptr` after delete",
      "code": "int main() {\n    int* p = new int(1);\n    delete p;\n    p = nullptr;\n    cout << (p == nullptr ? \"null\" : \"not\");\n}",
      "output": "null",
      "tags": [
        "memory",
        "heap",
        "pointers",
        "dynamic-memory"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "allocate",
            "description": "Allocate `int(1)` on heap",
            "state": {
              "p": "\u2192heap(1)"
            },
            "concepts": [
              "new-operator"
            ]
          },
          {
            "line": 3,
            "action": "deallocate",
            "description": "Delete the allocated memory; `p` is now dangling",
            "concepts": [
              "delete-operator",
              "dangling-pointer"
            ]
          },
          {
            "line": 4,
            "action": "assign",
            "description": "Set `p = nullptr` to safely mark as invalid",
            "state": {
              "p": "nullptr"
            },
            "concepts": [
              "nullptr"
            ]
          },
          {
            "line": 5,
            "action": "evaluate",
            "description": "Check if p is nullptr (true), print 'null'",
            "output": "null",
            "concepts": [
              "ternary-operator"
            ]
          }
        ],
        "finalOutput": "null",
        "keyInsight": "After `delete`, set pointers to `nullptr` to avoid dangling pointer bugs and enable safe null checks."
      }
    },
    {
      "id": "mem-005",
      "categoryId": "dynamic-memory",
      "concept": "`new T[n]` array allocation",
      "code": "int main() {\n    int* arr = new int[3];\n    arr[0] = 1; arr[1] = 2; arr[2] = 3;\n    cout << arr[0] << arr[1] << arr[2];\n    delete[] arr;\n}",
      "output": "123",
      "tags": [
        "memory",
        "heap",
        "pointers",
        "arrays",
        "dynamic-memory"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "allocate",
            "description": "Allocate array of 3 ints on heap",
            "state": {
              "arr": "\u2192heap[?, ?, ?]"
            },
            "concepts": [
              "new-array",
              "heap-allocation"
            ]
          },
          {
            "line": 3,
            "action": "assign",
            "description": "Assign values to array elements through pointer",
            "state": {
              "arr": "\u2192heap[1, 2, 3]"
            }
          },
          {
            "line": 4,
            "action": "output",
            "description": "Print all three elements",
            "output": "123"
          },
          {
            "line": 5,
            "action": "deallocate",
            "description": "`delete[]` frees the entire array",
            "concepts": [
              "delete-array"
            ]
          }
        ],
        "finalOutput": "123",
        "keyInsight": "`new T[n]` allocates an array on the heap; must use `delete[]` (not `delete`) to properly free it."
      }
    },
    {
      "id": "mem-006",
      "categoryId": "dynamic-memory",
      "concept": "`delete[]` for arrays",
      "code": "int main() {\n    int* arr = new int[3]{5, 6, 7};\n    cout << arr[1];\n    delete[] arr;  // Must use delete[], not delete\n}",
      "output": "6",
      "tags": [
        "memory",
        "heap",
        "pointers",
        "for-loop",
        "arrays",
        "dynamic-memory"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "allocate",
            "description": "Allocate array with initializer list {5, 6, 7}",
            "state": {
              "arr": "\u2192heap[5, 6, 7]"
            },
            "concepts": [
              "new-array",
              "initializer-list"
            ]
          },
          {
            "line": 3,
            "action": "output",
            "description": "Print arr[1] which is 6",
            "output": "6"
          },
          {
            "line": 4,
            "action": "deallocate",
            "description": "`delete[]` required for arrays (not `delete`)",
            "concepts": [
              "delete-array"
            ]
          }
        ],
        "finalOutput": "6",
        "keyInsight": "Arrays allocated with `new[]` MUST be freed with `delete[]`; using plain `delete` causes undefined behavior."
      }
    },
    {
      "id": "mem-007",
      "categoryId": "dynamic-memory",
      "concept": "Array initializer list with new",
      "code": "int main() {\n    int* arr = new int[4]{10, 20, 30, 40};\n    cout << arr[0] << arr[3];\n    delete[] arr;\n}",
      "output": "1040",
      "tags": [
        "memory",
        "heap",
        "pointers",
        "arrays",
        "dynamic-memory"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "allocate",
            "description": "Allocate 4-element array with initializer {10, 20, 30, 40}",
            "state": {
              "arr": "\u2192heap[10, 20, 30, 40]"
            },
            "concepts": [
              "new-array",
              "initializer-list"
            ]
          },
          {
            "line": 3,
            "action": "output",
            "description": "Print arr[0] (10) and arr[3] (40)",
            "output": "1040"
          },
          {
            "line": 4,
            "action": "deallocate",
            "description": "Free the array",
            "concepts": [
              "delete-array"
            ]
          }
        ],
        "finalOutput": "1040",
        "keyInsight": "C++11 allows brace initialization with `new T[n]{...}` to initialize heap arrays."
      }
    },
    {
      "id": "mem-008",
      "categoryId": "dynamic-memory",
      "concept": "Default copy constructor",
      "code": "class A {\npublic:\n    int x;\n    A(int v) : x(v) {}\n};\nint main() {\n    A a(5);\n    A b = a;  // Default copy\n    cout << b.x;\n}",
      "output": "5",
      "tags": [
        "memory",
        "heap",
        "pointers",
        "const",
        "constructors",
        "copy-semantics"
      ],
      "explanation": {
        "steps": [
          {
            "line": 6,
            "action": "construct",
            "description": "Construct `a` with x=5",
            "state": {
              "a.x": 5
            },
            "concepts": [
              "constructor"
            ]
          },
          {
            "line": 7,
            "action": "copy",
            "description": "Default copy constructor copies all members: `b.x = a.x`",
            "state": {
              "b.x": 5
            },
            "concepts": [
              "default-copy-constructor",
              "memberwise-copy"
            ]
          },
          {
            "line": 8,
            "action": "output",
            "description": "Print b.x",
            "output": "5"
          }
        ],
        "finalOutput": "5",
        "keyInsight": "The compiler-generated default copy constructor performs memberwise (shallow) copy of all data members."
      }
    },
    {
      "id": "mem-009",
      "categoryId": "dynamic-memory",
      "concept": "Shallow copy (pointer copied)",
      "code": "class Shallow {\npublic:\n    int* p;\n    Shallow(int v) : p(new int(v)) {}\n};\nint main() {\n    Shallow a(5);\n    Shallow b = a;  // Both point to same memory!\n    cout << (*a.p == *b.p);\n}",
      "output": "1",
      "tags": [
        "memory",
        "heap",
        "pointers",
        "copy-semantics"
      ],
      "explanation": {
        "steps": [
          {
            "line": 6,
            "action": "construct",
            "description": "Construct `a`: allocate int(5) on heap, store address in a.p",
            "state": {
              "a.p": "\u2192heap(5)"
            },
            "concepts": [
              "constructor",
              "new-operator"
            ]
          },
          {
            "line": 7,
            "action": "copy",
            "description": "Default copy: `b.p = a.p` (copies the pointer, NOT the data!)",
            "state": {
              "b.p": "\u2192heap(5)",
              "a.p": "\u2192heap(5)"
            },
            "concepts": [
              "shallow-copy"
            ]
          },
          {
            "line": 8,
            "action": "evaluate",
            "description": "*a.p and *b.p both access same memory location, so equal: prints 1",
            "output": "1",
            "concepts": [
              "pointer-aliasing"
            ]
          }
        ],
        "finalOutput": "1",
        "keyInsight": "Shallow copy only copies the pointer value, not the pointed-to data. Both objects share the same heap memory\u2014dangerous!"
      }
    },
    {
      "id": "mem-010",
      "categoryId": "dynamic-memory",
      "concept": "Double delete problem",
      "code": "class Bad {\npublic:\n    int* p;\n    Bad() : p(new int(1)) {}\n    ~Bad() { delete p; }\n};\nint main() {\n    // Bad a;\n    // Bad b = a;  // Would cause double delete!\n    cout << \"avoided\";\n}",
      "output": "avoided",
      "tags": [
        "memory",
        "heap",
        "pointers",
        "dynamic-memory"
      ],
      "explanation": {
        "steps": [
          {
            "line": null,
            "action": "evaluate",
            "description": "Code is commented out to avoid the bug",
            "concepts": [
              "double-delete"
            ]
          },
          {
            "line": 9,
            "action": "output",
            "description": "Print 'avoided' since dangerous code is commented",
            "output": "avoided"
          }
        ],
        "finalOutput": "avoided",
        "keyInsight": "If Bad was copied, both destructors would `delete p` on the same pointer\u2014double delete causes undefined behavior."
      }
    },
    {
      "id": "mem-011",
      "categoryId": "dynamic-memory",
      "concept": "Undefined behavior from shallow copy",
      "code": "class S {\npublic:\n    int* data;\n    S() : data(new int(10)) {}\n    ~S() { cout << \"D\"; delete data; }\n};\nint main() {\n    S a;\n    // S b = a;  // Would cause UB when both destruct\n    cout << \"X\";\n}",
      "output": "XD",
      "tags": [
        "memory",
        "heap",
        "pointers",
        "copy-semantics"
      ],
      "explanation": {
        "steps": [
          {
            "line": 8,
            "action": "construct",
            "description": "Construct `a`: allocates int(10) on heap",
            "state": {
              "a.data": "\u2192heap(10)"
            },
            "concepts": [
              "constructor"
            ]
          },
          {
            "line": 10,
            "action": "output",
            "description": "Print 'X'",
            "output": "X"
          },
          {
            "line": null,
            "action": "destruct",
            "description": "`a` goes out of scope: destructor prints 'D' and deletes data",
            "output": "D",
            "concepts": [
              "destructor",
              "delete-operator"
            ]
          }
        ],
        "finalOutput": "XD",
        "keyInsight": "If `S b = a` was uncommented, both would share the same pointer and double-delete on destruction (undefined behavior)."
      }
    },
    {
      "id": "mem-012",
      "categoryId": "dynamic-memory",
      "concept": "Custom copy constructor",
      "code": "class Deep {\npublic:\n    int* p;\n    Deep(int v) : p(new int(v)) {}\n    Deep(const Deep& o) : p(new int(*o.p)) { cout << \"C\"; }\n    ~Deep() { delete p; }\n};\nint main() {\n    Deep a(5);\n    Deep b = a;\n}",
      "output": "C",
      "tags": [
        "memory",
        "heap",
        "pointers",
        "const",
        "constructors",
        "copy-semantics"
      ],
      "explanation": {
        "steps": [
          {
            "line": 8,
            "action": "construct",
            "description": "Construct `a` with p pointing to heap(5)",
            "state": {
              "a.p": "\u2192heap(5)"
            },
            "concepts": [
              "constructor"
            ]
          },
          {
            "line": 9,
            "action": "copy",
            "description": "Copy constructor: allocate NEW heap memory, copy value, print 'C'",
            "state": {
              "b.p": "\u2192heap(5)"
            },
            "output": "C",
            "concepts": [
              "deep-copy",
              "copy-constructor"
            ]
          },
          {
            "line": null,
            "action": "destruct",
            "description": "Both objects safely deleted (independent memory)",
            "concepts": [
              "destructor"
            ]
          }
        ],
        "finalOutput": "C",
        "keyInsight": "A custom copy constructor that allocates new memory creates a deep copy\u2014each object owns independent heap memory."
      }
    },
    {
      "id": "mem-013",
      "categoryId": "dynamic-memory",
      "concept": "Deep copy (new allocation)",
      "code": "class D {\npublic:\n    int* p;\n    D(int v) : p(new int(v)) {}\n    D(const D& o) : p(new int(*o.p)) {}\n    ~D() { delete p; }\n};\nint main() {\n    D a(7);\n    D b = a;\n    *b.p = 99;\n    cout << *a.p << *b.p;\n}",
      "output": "799",
      "tags": [
        "memory",
        "heap",
        "pointers",
        "dynamic-memory",
        "copy-semantics"
      ],
      "explanation": {
        "steps": [
          {
            "line": 8,
            "action": "construct",
            "description": "Construct `a` with heap value 7",
            "state": {
              "a.p": "\u2192heap(7)"
            },
            "concepts": [
              "constructor"
            ]
          },
          {
            "line": 9,
            "action": "copy",
            "description": "Deep copy: `b` gets its own heap allocation with copied value 7",
            "state": {
              "b.p": "\u2192heap(7)"
            },
            "concepts": [
              "deep-copy"
            ]
          },
          {
            "line": 10,
            "action": "assign",
            "description": "Modify *b.p to 99 (only affects b's copy)",
            "state": {
              "*b.p": 99
            }
          },
          {
            "line": 11,
            "action": "output",
            "description": "Print *a.p (still 7) and *b.p (now 99)",
            "output": "799"
          }
        ],
        "finalOutput": "799",
        "keyInsight": "Deep copy means each object has its own heap memory\u2014modifying one doesn't affect the other."
      }
    },
    {
      "id": "mem-014",
      "categoryId": "dynamic-memory",
      "concept": "Independent heap memory",
      "code": "class Ind {\npublic:\n    int* v;\n    Ind(int x) : v(new int(x)) {}\n    Ind(const Ind& o) : v(new int(*o.v)) {}\n    ~Ind() { delete v; }\n};\nint main() {\n    Ind a(1);\n    Ind b = a;\n    cout << (a.v != b.v ? \"diff\" : \"same\");\n}",
      "output": "diff",
      "tags": [
        "memory",
        "heap",
        "pointers"
      ],
      "explanation": {
        "steps": [
          {
            "line": 8,
            "action": "construct",
            "description": "Construct `a` with v pointing to heap(1)",
            "state": {
              "a.v": "\u2192addr1"
            },
            "concepts": [
              "constructor"
            ]
          },
          {
            "line": 9,
            "action": "copy",
            "description": "Deep copy: b.v points to NEW address with copied value",
            "state": {
              "b.v": "\u2192addr2"
            },
            "concepts": [
              "deep-copy"
            ]
          },
          {
            "line": 10,
            "action": "evaluate",
            "description": "Compare addresses: a.v != b.v is true, print 'diff'",
            "output": "diff",
            "concepts": [
              "pointer-comparison"
            ]
          }
        ],
        "finalOutput": "diff",
        "keyInsight": "With deep copy, each object's pointer stores a DIFFERENT address\u2014they own independent heap memory."
      }
    },
    {
      "id": "mem-015",
      "categoryId": "dynamic-memory",
      "concept": "Copy constructor (initialization)",
      "code": "class A {\npublic:\n    A() { cout << \"D\"; }\n    A(const A&) { cout << \"C\"; }\n};\nint main() {\n    A a;\n    A b = a;  // Copy constructor\n}",
      "output": "DC",
      "tags": [
        "memory",
        "heap",
        "pointers",
        "const",
        "constructors",
        "copy-semantics"
      ],
      "explanation": {
        "steps": [
          {
            "line": 7,
            "action": "construct",
            "description": "Default construct `a`, print 'D'",
            "output": "D",
            "concepts": [
              "default-constructor"
            ]
          },
          {
            "line": 8,
            "action": "copy",
            "description": "`A b = a` is initialization (not assignment!), calls copy constructor, prints 'C'",
            "output": "C",
            "concepts": [
              "copy-constructor",
              "copy-initialization"
            ]
          }
        ],
        "finalOutput": "DC",
        "keyInsight": "`Type x = y` during declaration calls the copy constructor, not the assignment operator\u2014it's initialization, not assignment."
      }
    },
    {
      "id": "mem-016",
      "categoryId": "dynamic-memory",
      "concept": "Assignment operator (object already exists)",
      "code": "class A {\npublic:\n    A() { cout << \"D\"; }\n    A& operator=(const A&) { cout << \"=\"; return *this; }\n};\nint main() {\n    A a;\n    A b;\n    b = a;  // Assignment\n}",
      "output": "DD=",
      "tags": [
        "memory",
        "heap",
        "pointers",
        "operators"
      ],
      "explanation": {
        "steps": [
          {
            "line": 7,
            "action": "construct",
            "description": "Default construct `a`, print 'D'",
            "output": "D",
            "concepts": [
              "default-constructor"
            ]
          },
          {
            "line": 8,
            "action": "construct",
            "description": "Default construct `b`, print 'D'",
            "output": "D",
            "concepts": [
              "default-constructor"
            ]
          },
          {
            "line": 9,
            "action": "assign",
            "description": "`b = a` on existing objects calls operator=, prints '='",
            "output": "=",
            "concepts": [
              "assignment-operator"
            ]
          }
        ],
        "finalOutput": "DD=",
        "keyInsight": "Assignment operator is called when assigning to an ALREADY EXISTING object (`b = a` after `b` exists)."
      }
    },
    {
      "id": "mem-017",
      "categoryId": "dynamic-memory",
      "concept": "`Type x = y` vs `x = y` distinction",
      "code": "class A {\npublic:\n    A() { cout << \"D\"; }\n    A(const A&) { cout << \"C\"; }\n    A& operator=(const A&) { cout << \"=\"; return *this; }\n};\nint main() {\n    A a;       // D\n    A b = a;   // C (initialization)\n    A c;       // D\n    c = a;     // = (assignment)\n}",
      "output": "DCD=",
      "tags": [
        "memory",
        "heap",
        "pointers"
      ],
      "explanation": {
        "steps": [
          {
            "line": 8,
            "action": "construct",
            "description": "Default construct `a`, print 'D'",
            "output": "D",
            "concepts": [
              "default-constructor"
            ]
          },
          {
            "line": 9,
            "action": "copy",
            "description": "`A b = a` is copy initialization (copy constructor), print 'C'",
            "output": "C",
            "concepts": [
              "copy-constructor"
            ]
          },
          {
            "line": 10,
            "action": "construct",
            "description": "Default construct `c`, print 'D'",
            "output": "D",
            "concepts": [
              "default-constructor"
            ]
          },
          {
            "line": 11,
            "action": "assign",
            "description": "`c = a` is assignment (c exists), print '='",
            "output": "=",
            "concepts": [
              "assignment-operator"
            ]
          }
        ],
        "finalOutput": "DCD=",
        "keyInsight": "`Type x = y` (during declaration) uses copy constructor; `x = y` (after x exists) uses assignment operator."
      }
    },
    {
      "id": "mem-018",
      "categoryId": "dynamic-memory",
      "concept": "`operator=` implementation",
      "code": "class A {\n    int x;\npublic:\n    A(int v) : x(v) {}\n    A& operator=(const A& o) {\n        x = o.x;\n        cout << x;\n        return *this;\n    }\n};\nint main() { A a(1), b(5); a = b; }",
      "output": "5",
      "tags": [
        "memory",
        "heap",
        "pointers",
        "operators"
      ],
      "explanation": {
        "steps": [
          {
            "line": 9,
            "action": "construct",
            "description": "Construct `a` with x=1, then `b` with x=5",
            "state": {
              "a.x": 1,
              "b.x": 5
            },
            "concepts": [
              "constructor"
            ]
          },
          {
            "line": 9,
            "action": "assign",
            "description": "`a = b` calls operator=: copies o.x (5) to this->x, prints 5",
            "state": {
              "a.x": 5
            },
            "output": "5",
            "concepts": [
              "assignment-operator"
            ]
          }
        ],
        "finalOutput": "5",
        "keyInsight": "`operator=` typically copies member values and returns `*this` to allow chaining (a = b = c)."
      }
    },
    {
      "id": "mem-019",
      "categoryId": "dynamic-memory",
      "concept": "`this != &rhs` self-assignment check",
      "code": "class Safe {\n    int* p;\npublic:\n    Safe(int v) : p(new int(v)) {}\n    Safe& operator=(const Safe& o) {\n        if (this != &o) {\n            delete p;\n            p = new int(*o.p);\n        }\n        cout << *p;\n        return *this;\n    }\n    ~Safe() { delete p; }\n};\nint main() {\n    Safe a(5);\n    a = a;  // Self-assignment\n}",
      "output": "5",
      "tags": [
        "memory",
        "heap",
        "pointers"
      ],
      "explanation": {
        "steps": [
          {
            "line": 13,
            "action": "construct",
            "description": "Construct `a` with p pointing to heap(5)",
            "state": {
              "a.p": "\u2192heap(5)"
            },
            "concepts": [
              "constructor"
            ]
          },
          {
            "line": 14,
            "action": "assign",
            "description": "`a = a` (self-assignment) calls operator=",
            "concepts": [
              "self-assignment"
            ]
          },
          {
            "line": 6,
            "action": "branch",
            "description": "`this != &o` is FALSE (same object), skip delete/new",
            "concepts": [
              "self-assignment-check"
            ]
          },
          {
            "line": 10,
            "action": "output",
            "description": "Print *p which is still 5",
            "output": "5"
          }
        ],
        "finalOutput": "5",
        "keyInsight": "Self-assignment check (`this != &o`) prevents deleting your own data before copying\u2014essential for safe operator=."
      }
    },
    {
      "id": "mem-020",
      "categoryId": "dynamic-memory",
      "concept": "Avoiding delete-before-copy bug",
      "code": "class A {\n    int* data;\npublic:\n    A(int v) : data(new int(v)) {}\n    A& operator=(const A& o) {\n        if (this == &o) { cout << \"self\"; return *this; }\n        delete data;\n        data = new int(*o.data);\n        cout << *data;\n        return *this;\n    }\n    ~A() { delete data; }\n};\nint main() { A a(1); a = a; }",
      "output": "self",
      "tags": [
        "memory",
        "heap",
        "pointers",
        "for-loop",
        "dynamic-memory",
        "copy-semantics"
      ],
      "explanation": {
        "steps": [
          {
            "line": 13,
            "action": "construct",
            "description": "Construct `a` with data pointing to heap(1)",
            "state": {
              "a.data": "\u2192heap(1)"
            },
            "concepts": [
              "constructor"
            ]
          },
          {
            "line": 13,
            "action": "assign",
            "description": "`a = a` triggers operator=",
            "concepts": [
              "self-assignment"
            ]
          },
          {
            "line": 5,
            "action": "branch",
            "description": "`this == &o` is TRUE, print 'self' and return early",
            "output": "self",
            "concepts": [
              "self-assignment-check"
            ]
          }
        ],
        "finalOutput": "self",
        "keyInsight": "Without self-assignment check, `delete data` would destroy the data before copying it\u2014causing data loss."
      }
    },
    {
      "id": "mem-021",
      "categoryId": "dynamic-memory",
      "concept": "Rule of 3 concept",
      "code": "class R3 {\n    int* p;\npublic:\n    R3(int v) : p(new int(v)) { cout << \"N\"; }\n    R3(const R3& o) : p(new int(*o.p)) { cout << \"C\"; }\n    R3& operator=(const R3& o) {\n        if (this != &o) { delete p; p = new int(*o.p); }\n        cout << \"=\";\n        return *this;\n    }\n    ~R3() { cout << \"D\"; delete p; }\n};\nint main() { R3 a(1); R3 b = a; }",
      "output": "NCDD",
      "tags": [
        "memory",
        "heap",
        "pointers"
      ],
      "explanation": {
        "steps": [
          {
            "line": 11,
            "action": "construct",
            "description": "Construct `a`: allocate heap, print 'N'",
            "state": {
              "a.p": "\u2192heap(1)"
            },
            "output": "N",
            "concepts": [
              "constructor"
            ]
          },
          {
            "line": 11,
            "action": "copy",
            "description": "`b = a` copy initialization: deep copy, print 'C'",
            "state": {
              "b.p": "\u2192heap(1)"
            },
            "output": "C",
            "concepts": [
              "copy-constructor",
              "deep-copy"
            ]
          },
          {
            "line": null,
            "action": "destruct",
            "description": "b destructs first, print 'D'",
            "output": "D",
            "concepts": [
              "destructor"
            ]
          },
          {
            "line": null,
            "action": "destruct",
            "description": "a destructs, print 'D'",
            "output": "D",
            "concepts": [
              "destructor"
            ]
          }
        ],
        "finalOutput": "NCDD",
        "keyInsight": "Rule of 3: if you need a custom destructor, copy constructor, OR assignment operator, you likely need all three."
      }
    },
    {
      "id": "mem-022",
      "categoryId": "dynamic-memory",
      "concept": "Destructor requirement",
      "code": "class A {\n    int* p;\npublic:\n    A() : p(new int(5)) {}\n    ~A() { delete p; cout << \"~\"; }\n};\nint main() { A a; }",
      "output": "~",
      "tags": [
        "memory",
        "heap",
        "pointers",
        "destructors"
      ],
      "explanation": {
        "steps": [
          {
            "line": 6,
            "action": "construct",
            "description": "Construct `a`: allocate int(5) on heap",
            "state": {
              "a.p": "\u2192heap(5)"
            },
            "concepts": [
              "constructor"
            ]
          },
          {
            "line": null,
            "action": "destruct",
            "description": "`a` goes out of scope: destructor deletes p, prints '~'",
            "output": "~",
            "concepts": [
              "destructor",
              "delete-operator"
            ]
          }
        ],
        "finalOutput": "~",
        "keyInsight": "Classes with heap-allocated members need a destructor to `delete` them, preventing memory leaks."
      }
    },
    {
      "id": "mem-023",
      "categoryId": "dynamic-memory",
      "concept": "Copy constructor requirement",
      "code": "class A {\n    int* p;\npublic:\n    A(int v) : p(new int(v)) {}\n    A(const A& o) : p(new int(*o.p)) { cout << \"copied\"; }\n    ~A() { delete p; }\n};\nint main() { A a(1); A b = a; }",
      "output": "copied",
      "tags": [
        "memory",
        "heap",
        "pointers",
        "const",
        "constructors",
        "copy-semantics"
      ],
      "explanation": {
        "steps": [
          {
            "line": 8,
            "action": "construct",
            "description": "Construct `a` with heap value 1",
            "state": {
              "a.p": "\u2192heap(1)"
            },
            "concepts": [
              "constructor"
            ]
          },
          {
            "line": 8,
            "action": "copy",
            "description": "`A b = a` calls copy constructor: allocates new heap, prints 'copied'",
            "output": "copied",
            "concepts": [
              "copy-constructor",
              "deep-copy"
            ]
          }
        ],
        "finalOutput": "copied",
        "keyInsight": "A copy constructor is needed to perform deep copy\u2014otherwise default shallow copy leads to double-delete."
      }
    },
    {
      "id": "mem-024",
      "categoryId": "dynamic-memory",
      "concept": "Copy assignment requirement",
      "code": "class A {\n    int* p;\npublic:\n    A(int v) : p(new int(v)) {}\n    A& operator=(const A& o) {\n        if (this != &o) { delete p; p = new int(*o.p); }\n        cout << \"assigned\";\n        return *this;\n    }\n    ~A() { delete p; }\n};\nint main() { A a(1), b(2); a = b; }",
      "output": "assigned",
      "tags": [
        "memory",
        "heap",
        "pointers",
        "copy-semantics"
      ],
      "explanation": {
        "steps": [
          {
            "line": 10,
            "action": "construct",
            "description": "Construct `a` with heap(1), `b` with heap(2)",
            "state": {
              "a.p": "\u2192heap(1)",
              "b.p": "\u2192heap(2)"
            },
            "concepts": [
              "constructor"
            ]
          },
          {
            "line": 10,
            "action": "assign",
            "description": "`a = b` calls operator=: deletes old, copies new, prints 'assigned'",
            "output": "assigned",
            "concepts": [
              "assignment-operator",
              "deep-copy"
            ]
          }
        ],
        "finalOutput": "assigned",
        "keyInsight": "Assignment operator must delete old data before allocating new\u2014and handle self-assignment."
      }
    },
    {
      "id": "mem-025",
      "categoryId": "dynamic-memory",
      "concept": "All three needed together",
      "code": "class Full {\n    int* data;\npublic:\n    Full(int v) : data(new int(v)) { cout << \"C\"; }\n    Full(const Full& o) : data(new int(*o.data)) { cout << \"P\"; }\n    Full& operator=(const Full& o) {\n        if (this != &o) { delete data; data = new int(*o.data); }\n        cout << \"=\";\n        return *this;\n    }\n    ~Full() { cout << \"D\"; delete data; }\n};\nint main() {\n    Full a(1);  // C\n    Full b = a; // P\n    Full c(2);  // C\n    c = a;      // =\n}",
      "output": "CPC=DDD",
      "tags": [
        "memory",
        "heap",
        "pointers"
      ],
      "explanation": {
        "steps": [
          {
            "line": 13,
            "action": "construct",
            "description": "Construct `a` with heap(1), print 'C'",
            "output": "C",
            "concepts": [
              "constructor"
            ]
          },
          {
            "line": 14,
            "action": "copy",
            "description": "`b = a` copy init: deep copy, print 'P'",
            "output": "P",
            "concepts": [
              "copy-constructor"
            ]
          },
          {
            "line": 15,
            "action": "construct",
            "description": "Construct `c` with heap(2), print 'C'",
            "output": "C",
            "concepts": [
              "constructor"
            ]
          },
          {
            "line": 16,
            "action": "assign",
            "description": "`c = a` assignment: delete old, copy, print '='",
            "output": "=",
            "concepts": [
              "assignment-operator"
            ]
          },
          {
            "line": null,
            "action": "destruct",
            "description": "c destructs, print 'D'",
            "output": "D",
            "concepts": [
              "destructor"
            ]
          },
          {
            "line": null,
            "action": "destruct",
            "description": "b destructs, print 'D'",
            "output": "D",
            "concepts": [
              "destructor"
            ]
          },
          {
            "line": null,
            "action": "destruct",
            "description": "a destructs, print 'D'",
            "output": "D",
            "concepts": [
              "destructor"
            ]
          }
        ],
        "finalOutput": "CPC=DDD",
        "keyInsight": "All three (destructor, copy constructor, copy assignment) work together to manage heap memory safely."
      }
    },
    {
      "id": "mem-026",
      "categoryId": "dynamic-memory",
      "concept": "Return by value",
      "code": "class A {\npublic:\n    int x;\n    A(int v) : x(v) { cout << \"C\"; }\n    A(const A& o) : x(o.x) { cout << \"P\"; }\n};\nA make() { return A(5); }\nint main() { A a = make(); cout << a.x; }",
      "output": "C5 (or CP5 without elision)",
      "tags": [
        "memory",
        "heap",
        "pointers"
      ],
      "explanation": {
        "steps": [
          {
            "line": 7,
            "action": "call",
            "description": "Call make() function",
            "concepts": [
              "function-call"
            ]
          },
          {
            "line": 7,
            "action": "construct",
            "description": "Inside make(): construct A(5), print 'C'",
            "output": "C",
            "concepts": [
              "constructor"
            ]
          },
          {
            "line": 7,
            "action": "return",
            "description": "Return A(5)\u2014copy elision may skip copy constructor",
            "concepts": [
              "copy-elision",
              "return-value-optimization"
            ]
          },
          {
            "line": 8,
            "action": "output",
            "description": "Print a.x which is 5",
            "output": "5"
          }
        ],
        "finalOutput": "C5",
        "keyInsight": "Modern compilers use copy elision (RVO) to avoid unnecessary copies when returning objects by value."
      }
    },
    {
      "id": "mem-027",
      "categoryId": "dynamic-memory",
      "concept": "Copy constructor for return",
      "code": "class A {\npublic:\n    A() { cout << \"D\"; }\n    A(const A&) { cout << \"C\"; }\n};\nA get() { A a; return a; }\nint main() { A x = get(); }",
      "output": "D (with elision) or DC (without)",
      "tags": [
        "memory",
        "heap",
        "pointers",
        "for-loop",
        "const",
        "constructors",
        "copy-semantics"
      ],
      "explanation": {
        "steps": [
          {
            "line": 6,
            "action": "call",
            "description": "Call get() function",
            "concepts": [
              "function-call"
            ]
          },
          {
            "line": 6,
            "action": "construct",
            "description": "Inside get(): default construct `a`, print 'D'",
            "output": "D",
            "concepts": [
              "default-constructor"
            ]
          },
          {
            "line": 6,
            "action": "return",
            "description": "Return `a`\u2014with elision, no copy needed",
            "concepts": [
              "copy-elision"
            ]
          }
        ],
        "finalOutput": "D",
        "keyInsight": "Named Return Value Optimization (NRVO) can elide copy even for named local variables returned by value."
      }
    },
    {
      "id": "mem-028",
      "categoryId": "dynamic-memory",
      "concept": "Copy elision optimization",
      "code": "class A {\npublic:\n    A() { cout << \"1\"; }\n    A(const A&) { cout << \"2\"; }\n};\nA create() { return A(); }\nint main() { A a = create(); }",
      "output": "1 (with elision)",
      "tags": [
        "memory",
        "heap",
        "pointers",
        "copy-semantics"
      ],
      "explanation": {
        "steps": [
          {
            "line": 5,
            "action": "call",
            "description": "Call create() function",
            "concepts": [
              "function-call"
            ]
          },
          {
            "line": 5,
            "action": "construct",
            "description": "Construct temporary A(), print '1'",
            "output": "1",
            "concepts": [
              "constructor"
            ]
          },
          {
            "line": 5,
            "action": "return",
            "description": "Return value\u2014copy elision avoids calling copy constructor",
            "concepts": [
              "copy-elision"
            ]
          }
        ],
        "finalOutput": "1",
        "keyInsight": "Copy elision is mandatory in C++17 for returning temporaries\u2014the copy constructor may never be called."
      }
    },
    {
      "id": "mem-029",
      "categoryId": "dynamic-memory",
      "concept": "Memory leak concept",
      "code": "int main() {\n    int* p = new int(5);\n    p = new int(10);  // Leak: lost pointer to first allocation\n    cout << *p;\n    delete p;\n}",
      "output": "10",
      "tags": [
        "memory",
        "heap",
        "pointers"
      ],
      "explanation": {
        "steps": [
          {
            "line": 2,
            "action": "allocate",
            "description": "Allocate int(5) on heap, store address in p",
            "state": {
              "p": "\u2192heap(5)"
            },
            "concepts": [
              "new-operator"
            ]
          },
          {
            "line": 3,
            "action": "allocate",
            "description": "Allocate NEW int(10), reassign p\u2014LEAK: original heap(5) lost!",
            "state": {
              "p": "\u2192heap(10)"
            },
            "concepts": [
              "memory-leak"
            ]
          },
          {
            "line": 4,
            "action": "output",
            "description": "Print *p (10)",
            "output": "10"
          },
          {
            "line": 5,
            "action": "deallocate",
            "description": "Delete only the second allocation",
            "concepts": [
              "delete-operator"
            ]
          }
        ],
        "finalOutput": "10",
        "keyInsight": "Reassigning a pointer without first deleting causes a memory leak\u2014the old memory is lost forever."
      }
    },
    {
      "id": "mem-030",
      "categoryId": "dynamic-memory",
      "concept": "Forgetting `delete` before reassignment",
      "code": "class Leaky {\n    int* p;\npublic:\n    Leaky(int v) : p(new int(v)) {}\n    void reset(int v) {\n        // Should delete p first!\n        p = new int(v);  // Leak\n    }\n    ~Leaky() { delete p; }\n};\nint main() {\n    Leaky a(1);\n    a.reset(2);\n    cout << \"done\";\n}",
      "output": "done",
      "tags": [
        "memory",
        "heap",
        "pointers",
        "for-loop",
        "dynamic-memory"
      ],
      "explanation": {
        "steps": [
          {
            "line": 10,
            "action": "construct",
            "description": "Construct `a` with p=heap(1)",
            "state": {
              "a.p": "\u2192heap(1)"
            },
            "concepts": [
              "constructor"
            ]
          },
          {
            "line": 11,
            "action": "call",
            "description": "Call a.reset(2)",
            "concepts": [
              "method-call"
            ]
          },
          {
            "line": 6,
            "action": "allocate",
            "description": "Allocate new int(2) and reassign\u2014LEAK: old heap(1) not deleted!",
            "state": {
              "a.p": "\u2192heap(2)"
            },
            "concepts": [
              "memory-leak"
            ]
          },
          {
            "line": 12,
            "action": "output",
            "description": "Print 'done'",
            "output": "done"
          }
        ],
        "finalOutput": "done",
        "keyInsight": "Any method that replaces a pointer must `delete` the old memory first, or cause a leak."
      }
    },
    {
      "id": "mem-031",
      "categoryId": "dynamic-memory",
      "concept": "Proper `reset()` pattern",
      "code": "class Safe {\n    int* p;\npublic:\n    Safe(int v) : p(new int(v)) {}\n    void reset(int v) {\n        delete p;      // Delete old\n        p = new int(v);\n        cout << *p;\n    }\n    ~Safe() { delete p; }\n};\nint main() { Safe a(1); a.reset(9); }",
      "output": "9",
      "tags": [
        "memory",
        "heap",
        "pointers"
      ],
      "explanation": {
        "steps": [
          {
            "line": 10,
            "action": "construct",
            "description": "Construct `a` with p=heap(1)",
            "state": {
              "a.p": "\u2192heap(1)"
            },
            "concepts": [
              "constructor"
            ]
          },
          {
            "line": 10,
            "action": "call",
            "description": "Call a.reset(9)",
            "concepts": [
              "method-call"
            ]
          },
          {
            "line": 5,
            "action": "deallocate",
            "description": "Delete old memory first",
            "concepts": [
              "delete-operator"
            ]
          },
          {
            "line": 6,
            "action": "allocate",
            "description": "Allocate new int(9)",
            "state": {
              "a.p": "\u2192heap(9)"
            },
            "concepts": [
              "new-operator"
            ]
          },
          {
            "line": 7,
            "action": "output",
            "description": "Print *p (9)",
            "output": "9"
          }
        ],
        "finalOutput": "9",
        "keyInsight": "Proper reset pattern: delete old \u2192 allocate new. This prevents memory leaks."
      }
    },
    {
      "id": "mem-032",
      "categoryId": "dynamic-memory",
      "concept": "`new T[n]` object array",
      "code": "class A {\npublic:\n    A() { cout << \"+\"; }\n};\nint main() {\n    A* arr = new A[3];\n    delete[] arr;\n}",
      "output": "+++",
      "tags": [
        "memory",
        "heap",
        "pointers",
        "arrays",
        "dynamic-memory"
      ],
      "explanation": {
        "steps": [
          {
            "line": 5,
            "action": "allocate",
            "description": "Allocate array of 3 A objects on heap",
            "concepts": [
              "new-array"
            ]
          },
          {
            "line": null,
            "action": "construct",
            "description": "Default constructor called for arr[0], prints '+'",
            "output": "+",
            "concepts": [
              "constructor"
            ]
          },
          {
            "line": null,
            "action": "construct",
            "description": "Default constructor called for arr[1], prints '+'",
            "output": "+",
            "concepts": [
              "constructor"
            ]
          },
          {
            "line": null,
            "action": "construct",
            "description": "Default constructor called for arr[2], prints '+'",
            "output": "+",
            "concepts": [
              "constructor"
            ]
          },
          {
            "line": 6,
            "action": "deallocate",
            "description": "`delete[]` destroys all objects and frees array",
            "concepts": [
              "delete-array"
            ]
          }
        ],
        "finalOutput": "+++",
        "keyInsight": "`new T[n]` calls the default constructor for each element in the array."
      }
    },
    {
      "id": "mem-033",
      "categoryId": "dynamic-memory",
      "concept": "Constructor order for arrays",
      "code": "class A {\n    static int n;\npublic:\n    A() { cout << ++n; }\n};\nint A::n = 0;\nint main() { A* arr = new A[3]; delete[] arr; }",
      "output": "123",
      "tags": [
        "memory",
        "heap",
        "pointers",
        "for-loop",
        "const",
        "constructors",
        "arrays"
      ],
      "explanation": {
        "steps": [
          {
            "line": 6,
            "action": "allocate",
            "description": "Allocate array of 3 A objects",
            "concepts": [
              "new-array"
            ]
          },
          {
            "line": null,
            "action": "construct",
            "description": "Construct arr[0]: ++n makes n=1, print '1'",
            "state": {
              "A::n": 1
            },
            "output": "1",
            "concepts": [
              "static-member"
            ]
          },
          {
            "line": null,
            "action": "construct",
            "description": "Construct arr[1]: ++n makes n=2, print '2'",
            "state": {
              "A::n": 2
            },
            "output": "2",
            "concepts": [
              "static-member"
            ]
          },
          {
            "line": null,
            "action": "construct",
            "description": "Construct arr[2]: ++n makes n=3, print '3'",
            "state": {
              "A::n": 3
            },
            "output": "3",
            "concepts": [
              "static-member"
            ]
          },
          {
            "line": 6,
            "action": "deallocate",
            "description": "`delete[]` destroys in reverse order",
            "concepts": [
              "delete-array"
            ]
          }
        ],
        "finalOutput": "123",
        "keyInsight": "Array elements are constructed in index order (0, 1, 2, ...)."
      }
    },
    {
      "id": "mem-034",
      "categoryId": "dynamic-memory",
      "concept": "`delete[]` destructor order (reversed)",
      "code": "class A {\n    static int n;\n    int id;\npublic:\n    A() : id(++n) { cout << \"+\" << id; }\n    ~A() { cout << \"-\" << id; }\n};\nint A::n = 0;\nint main() {\n    A* arr = new A[3];\n    cout << \"|\";\n    delete[] arr;\n}",
      "output": "+1+2+3|-3-2-1",
      "tags": [
        "memory",
        "heap",
        "pointers",
        "destructors",
        "dynamic-memory"
      ],
      "explanation": {
        "steps": [
          {
            "line": 9,
            "action": "allocate",
            "description": "Allocate array of 3 A objects",
            "concepts": [
              "new-array"
            ]
          },
          {
            "line": null,
            "action": "construct",
            "description": "Construct arr[0]: id=1, print '+1'",
            "state": {
              "arr[0].id": 1
            },
            "output": "+1",
            "concepts": [
              "constructor"
            ]
          },
          {
            "line": null,
            "action": "construct",
            "description": "Construct arr[1]: id=2, print '+2'",
            "state": {
              "arr[1].id": 2
            },
            "output": "+2",
            "concepts": [
              "constructor"
            ]
          },
          {
            "line": null,
            "action": "construct",
            "description": "Construct arr[2]: id=3, print '+3'",
            "state": {
              "arr[2].id": 3
            },
            "output": "+3",
            "concepts": [
              "constructor"
            ]
          },
          {
            "line": 10,
            "action": "output",
            "description": "Print '|' separator",
            "output": "|"
          },
          {
            "line": 11,
            "action": "deallocate",
            "description": "`delete[]` destructs in REVERSE order",
            "concepts": [
              "delete-array"
            ]
          },
          {
            "line": null,
            "action": "destruct",
            "description": "Destruct arr[2]: print '-3'",
            "output": "-3",
            "concepts": [
              "destructor"
            ]
          },
          {
            "line": null,
            "action": "destruct",
            "description": "Destruct arr[1]: print '-2'",
            "output": "-2",
            "concepts": [
              "destructor"
            ]
          },
          {
            "line": null,
            "action": "destruct",
            "description": "Destruct arr[0]: print '-1'",
            "output": "-1",
            "concepts": [
              "destructor"
            ]
          }
        ],
        "finalOutput": "+1+2+3|-3-2-1",
        "keyInsight": "`delete[]` destructs in REVERSE order\u2014last constructed is first destructed (LIFO)."
      }
    }
  ]
}